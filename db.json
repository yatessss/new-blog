{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[],"Cache":[{"_id":"source/Untitled.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483414195000},{"_id":"source/_posts/Untitled.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483414195000},{"_id":"source/about/index.md","hash":"954dd06d96392ae7d780c78fc0062138002be80d","modified":1483414195000},{"_id":"source/categories/index.md","hash":"a0dadb32e14cec5cf91f4f203f347b41fbc54b0c","modified":1483414195000},{"_id":"source/tags/index.md","hash":"1d1e40849fbead18d56a0d57180e6aa06e9ce5c5","modified":1483414195000},{"_id":"source/_posts/1992-06-20-读完的书.md","hash":"12557114a40fbee36f33d5b8353f43460d27590b","modified":1483414195000},{"_id":"source/_posts/1992-06-20-下雨的时候最适合胡思乱想.md","hash":"781907522eca5abbead45db2e49ab5b3e5d29e18","modified":1483414195000},{"_id":"source/_posts/2016-01-08-markdown.md","hash":"c35d34df6d84f98410b768c2dbee6faffa9e9d4e","modified":1483414195000},{"_id":"source/_posts/2016-01-12-我为什么想要开一个博客.md","hash":"e79ace514b878b21e4f8fd7513f5ce92b150b3d2","modified":1483414195000},{"_id":"source/_posts/2016-01-22-ES6study-1.md","hash":"299e51545e61a64bbaa2e8ba2cce44d3d8db1e02","modified":1483414195000},{"_id":"source/_posts/2016-01-25-ES6study-2.md","hash":"5a35ea94f62de032251b1b4e8e5c302419cbcd32","modified":1483414195000},{"_id":"source/_posts/2016-01-25-好的博客及文章.md","hash":"f76d33f35b26922e4715251ce6c680f078dc2196","modified":1483414195000},{"_id":"source/_posts/2016-01-26-Charles解决跨域问题.md","hash":"0c0670ea25215fbfe3d39402b90400f96a1b9b6a","modified":1483414195000},{"_id":"source/_posts/2016-01-29-初学webpack遇到的坑.md","hash":"3a6f3353859e8b9480dcd9a5bdd50375dc5f929c","modified":1483414195000},{"_id":"source/_posts/2016-02-01-ES6study-3.md","hash":"6604275e5cf18fb3ce458f4f32e78f311488344b","modified":1483414195000},{"_id":"source/_posts/2016-02-01-温柔的对待每一个人.md","hash":"ed1ca675728b4a82dfe7f7f4951e55d90a11bd2c","modified":1483414195000},{"_id":"source/_posts/2016-02-15-2015小总结.md","hash":"79007b745b688c492270b9a199bdcc15d3021e0f","modified":1483414195000},{"_id":"source/_posts/2016-02-18-初学React遇到的坑.md","hash":"29e48c98e4faf132417956def13543d9cf3c6448","modified":1483414195000},{"_id":"source/_posts/2016-02-19-工作总结.md","hash":"575ec9c909f3732eba82854e756c7c9de14ce82b","modified":1483414195000},{"_id":"source/_posts/2016-03-10-工作总结.md","hash":"068aa37222e325f85acd4f3dc49d9ca474f91909","modified":1483414195000},{"_id":"source/_posts/2016-03-16-未来三个月自己的计划.md","hash":"196267957fae7ef5701be4500153dda4922801b8","modified":1483414195000},{"_id":"source/_posts/2016-03-18-HTML5的学习.md","hash":"c163465a25a7987e1633192038f435352ea1f7be","modified":1483414195000},{"_id":"source/_posts/2016-03-23-百度ife之html.md","hash":"ebacbbceb0953490a6185b15f8f40442fddec453","modified":1483414195000},{"_id":"source/_posts/2016-03-28-你不知道的JavaScript读书笔记——作用域.md","hash":"b83d170788f48cba8a975e3646e3916e243590f3","modified":1483414195000},{"_id":"source/_posts/2016-03-29-你不知道的JavaScript读书笔记——闭包.md","hash":"1f388b948bf22d54952750049459445317691b6f","modified":1483414195000},{"_id":"source/_posts/2016-03-29-内网穿透—外网可以访问到本地页面.md","hash":"39a6cdea84f2517d1abcf0419288421f8c17b3ab","modified":1483414195000},{"_id":"source/_posts/2016-03-30-微信JSSDK坑啊坑.md","hash":"9075bfeb91f671f74126b559cc7e2c569363ba54","modified":1483414195000},{"_id":"source/_posts/2016-03-31-你不知道的JavaScript读书笔记——this.md","hash":"21f5bfeb8fa5254ba4d5f4f65a89149a35c9db9d","modified":1483414195000},{"_id":"source/_posts/2016-04-15-WebStorage.md","hash":"217b812e69310f66cdb1d7574974ea97a8f21407","modified":1483414195000},{"_id":"source/_posts/2016-04-18-《JavaScript高级程序设计》读书笔记.md","hash":"ffecbcfbb3367ffd280b6282405dd051c6f035fd","modified":1483414195000},{"_id":"source/_posts/2016-04-29-重排reflow与重绘repaint.md","hash":"241f9f1fb4f31f4000543f0ceb5516a8ffc38a44","modified":1483414195000},{"_id":"source/_posts/2016-05-06-vue初体验.md","hash":"3860503245d0ddbf9efe7eb43e8d3a3282b2e0f4","modified":1483414195000},{"_id":"source/_posts/2016-05-17-webstorm项目下文件夹消失.md.md","hash":"c0791057861e6e5dca24510e01243ff23b466b29","modified":1483414195000},{"_id":"source/_posts/2016-06-08-使用vue完成上传文件页面.md","hash":"5d2f68ee976d166809d7bc02fb409bb07751cc2c","modified":1483414195000},{"_id":"source/_posts/2016-07-08-使用vue完成知乎日报web版.md","hash":"44cb89b0f8d893e295c67b6810cda0e2f5d482ae","modified":1483414195000},{"_id":"source/_posts/2016-07-28-ES6模块化.md","hash":"8e824152581372ec1e46d98bf7515cddaec49aff","modified":1483414195000},{"_id":"source/_posts/2016-08-01-一个前端的工作方法总结.md","hash":"1f36226f14f1bf7e790ba856ecca879b21e76a3b","modified":1483414195000},{"_id":"source/_posts/2016-08-05-和https有关的一些事.md","hash":"c258b5f50fda4db3f7bb1554e5eb8f18199dcefc","modified":1483414195000},{"_id":"source/_posts/2016-09-30-初试微信小程序需要注意的地方.md","hash":"7965466687d69be3a28a56ab8b55e03a60a56a4b","modified":1483414195000},{"_id":"source/_posts/2016-10-17-前端直接生成及下载二维码和使用七牛SDK上传图片.md","hash":"3c4c86d11f73baefb4360419efc41b172590eef6","modified":1483414195000},{"_id":"source/_posts/2016-12-02-时间是个贼啊.md","hash":"d4cc4db58a357aef25e072e9a497eef1799dfd06","modified":1483414195000},{"_id":"source/_posts/2017-01-01-写在2016年末.md","hash":"77515f831324734abde2203b2de3e6f5c3889ac0","modified":1483415228000},{"_id":"public/atom.xml","hash":"62d9a8855b9257bb589ef480d7ce83e1b61cc695","modified":1483415765939},{"_id":"public/sitemap.xml","hash":"a30538a14a8c71d818df0731de3b2749441a9ba0","modified":1483415765939},{"_id":"public/categories/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765953},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765953},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765953},{"_id":"public/2016/12/02/时间是个贼啊.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/10/17/前端直接生成及下载二维码和使用七牛SDK上传图片.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/09/30/初试微信小程序需要注意的地方.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/08/05/和https有关的一些事.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/08/01/一个前端的工作方法总结.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/07/28/ES6模块化.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/07/08/使用vue完成知乎日报web版.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/05/17/webstorm项目下文件夹消失.md.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/05/06/vue初体验.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/04/29/重排reflow与重绘repaint.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/04/18/《JavaScript高级程序设计》读书笔记.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/04/15/WebStorage.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/03/30/微信JSSDK坑啊坑.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/06/08/使用vue完成上传文件页面.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/03/29/内网穿透—外网可以访问到本地页面.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/03/31/你不知道的JavaScript读书笔记——this.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/03/23/百度ife之html.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/03/18/HTML5的学习.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/03/16/未来三个月自己的计划.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/03/28/你不知道的JavaScript读书笔记——作用域.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/02/19/工作总结.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/02/15/2015小总结.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/02/01/温柔的对待每一个人.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/03/29/你不知道的JavaScript读书笔记——闭包.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/01/29/初学webpack遇到的坑.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765954},{"_id":"public/2016/01/26/Charles解决跨域问题.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/2016/02/17/初学React遇到的坑.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/2016/03/10/工作总结.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/2016/01/25/好的博客及文章.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/2016/02/01/ES6study-3.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/2016/01/12/我为什么想要开一个博客.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/2016/01/25/ES6study-2.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/2016/01/08/markdown.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/1992/06/20/读完的书.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/1992/06/20/下雨的时候最适合胡思乱想.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/2016/01/22/ES6study-1.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/1992/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/1992/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/2016/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/2016/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/2016/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/2016/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/2016/01/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/2016/02/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/2016/03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/2016/04/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/2016/05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/2016/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765955},{"_id":"public/archives/2016/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/archives/2016/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/archives/2016/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/archives/2016/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/archives/2016/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/categories/杂事二三/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/categories/markdown/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/categories/ES6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/categories/Charles/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/categories/webpack/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/categories/工作总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/categories/React/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/categories/HTML/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/categories/JavaScript/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/categories/vue/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/categories/webstorm/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/categories/微信小程序/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/page/7/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/page/8/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/tags/杂事二三/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/tags/杂事二三/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/tags/markdown/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/tags/ES6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/tags/好的博客/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/tags/Charles/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/tags/跨域问题/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/tags/webpack/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765956},{"_id":"public/tags/handlebars/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/小数点精确/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/url携带参数/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/React/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/JSSDK/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/iOS微信二维码/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/JavaScript/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/作用域/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/闭包/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/ngrok/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/内网穿透/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/微信JSSDK/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/跨域/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/appid/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/referer/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/this/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/WebStorage/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/页面储存/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/vue/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/webstorm/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/文件上传/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/知乎日报/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/工作总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/tags/微信小程序/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765957},{"_id":"public/Untitled.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765963},{"_id":"public/2017/01/03/Untitled.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765963},{"_id":"public/2017/01/01/写在2016年末.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765963},{"_id":"public/archives/2017/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765963},{"_id":"public/archives/2017/01/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1483415765963}],"Category":[{"name":"杂事二三","_id":"cixgzg1xy0007sq5l9supfcr9"},{"name":"markdown","_id":"cixgzg1ye000psq5ll8db7f8b"},{"name":"ES6","_id":"cixgzg1yl000wsq5ldgoxdlub"},{"name":"Charles","_id":"cixgzg1ys001asq5l6xra40hr"},{"name":"webpack","_id":"cixgzg1yx001isq5l83us8sm2"},{"name":"工作总结","_id":"cixgzg1zc001usq5lpkpyexet"},{"name":"React","_id":"cixgzg1zf0021sq5lg48ju4rd"},{"name":"HTML","_id":"cixgzg1zs002esq5ling5yz0v"},{"name":"JavaScript","_id":"cixgzg202002psq5l4klm8zgp"},{"name":"vue","_id":"cixgzg20j003vsq5lgrp1qdx9"},{"name":"webstorm","_id":"cixgzg20k003ysq5l9zk1egf3"},{"name":"微信小程序","_id":"cixgzg20o0046sq5lgx5hgx56"}],"Data":[],"Page":[{"_content":"","source":"Untitled.md","raw":"","date":"2017-01-03T03:29:55.000Z","updated":"2017-01-03T03:29:55.000Z","path":"Untitled.html","title":"","comments":1,"layout":"page","_id":"cixgzg1x20000sq5lch5wxzzq","content":"","excerpt":"","more":""},{"title":"about","date":"2016-03-24T03:43:00.000Z","comments":0,"_content":"\n这是我的土豆频道~ 欢迎大家捧场~~~ ([这里](http://www.tudou.com/home/_63884113/))\n有什么问题可以留言或联系我的QQ: 897969073\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-03-24 11:43:00\ncomments: false\n---\n\n这是我的土豆频道~ 欢迎大家捧场~~~ ([这里](http://www.tudou.com/home/_63884113/))\n有什么问题可以留言或联系我的QQ: 897969073\n","updated":"2017-01-03T03:29:55.000Z","path":"about/index.html","layout":"page","_id":"cixgzg1xo0002sq5lim7iho5y","content":"<p>这是我的土豆频道~ 欢迎大家捧场~~~ (<a href=\"http://www.tudou.com/home/_63884113/\" target=\"_blank\" rel=\"external\">这里</a>)<br>有什么问题可以留言或联系我的QQ: 897969073</p>\n","excerpt":"","more":"<p>这是我的土豆频道~ 欢迎大家捧场~~~ (<a href=\"http://www.tudou.com/home/_63884113/\">这里</a>)<br>有什么问题可以留言或联系我的QQ: 897969073</p>\n"},{"title":"categories","type":"categories","date":"2016-03-24T03:43:24.000Z","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\ndate: 2016-03-24 11:43:24\ncomments: false\n---\n","updated":"2017-01-03T03:29:55.000Z","path":"categories/index.html","layout":"page","_id":"cixgzg1xr0004sq5lyrvh4hhf","content":"","excerpt":"","more":""},{"title":"tags","date":"2016-03-24T03:39:56.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-03-24 11:39:56\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-01-03T03:29:55.000Z","path":"tags/index.html","layout":"page","_id":"cixgzg1xz0008sq5lxssyvuej","content":"","excerpt":"","more":""}],"Post":[{"_content":"","source":"_posts/Untitled.md","raw":"","slug":"Untitled","published":1,"date":"2017-01-03T03:29:55.000Z","updated":"2017-01-03T03:29:55.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cixgzg1x60001sq5lt1gzgcjd","content":"","excerpt":"","more":""},{"layout":"post","title":"读完的书","date":"1992-06-19T16:00:00.000Z","_content":"\n### 读完的书\n\n- 嫌疑犯X的献身\n- 解忧杂货铺\n- 追风筝的人\n- 岛上书店\n- 图解HTTP\n- 贫民窟的百万富翁\n- 三体\n- 明朝那些事\n- 动物庄园\n- 看见\n- 偷影子的人\n- 白夜行\n- 小王子\n- 无声告白\n- 狼图腾\n- 百年孤独\n- 虚无的十字架\n- 哈利波特（在读）","source":"_posts/1992-06-20-读完的书.md","raw":"---\nlayout: post\ntitle: 读完的书\ndate: 1992-06-20\ntags: ['杂事二三']\ncategories: 杂事二三\n---\n\n### 读完的书\n\n- 嫌疑犯X的献身\n- 解忧杂货铺\n- 追风筝的人\n- 岛上书店\n- 图解HTTP\n- 贫民窟的百万富翁\n- 三体\n- 明朝那些事\n- 动物庄园\n- 看见\n- 偷影子的人\n- 白夜行\n- 小王子\n- 无声告白\n- 狼图腾\n- 百年孤独\n- 虚无的十字架\n- 哈利波特（在读）","slug":"读完的书","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1xq0003sq5lfclda3kh","content":"<h3 id=\"读完的书\"><a href=\"#读完的书\" class=\"headerlink\" title=\"读完的书\"></a>读完的书</h3><ul>\n<li>嫌疑犯X的献身</li>\n<li>解忧杂货铺</li>\n<li>追风筝的人</li>\n<li>岛上书店</li>\n<li>图解HTTP</li>\n<li>贫民窟的百万富翁</li>\n<li>三体</li>\n<li>明朝那些事</li>\n<li>动物庄园</li>\n<li>看见</li>\n<li>偷影子的人</li>\n<li>白夜行</li>\n<li>小王子</li>\n<li>无声告白</li>\n<li>狼图腾</li>\n<li>百年孤独</li>\n<li>虚无的十字架</li>\n<li>哈利波特（在读）</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"读完的书\"><a href=\"#读完的书\" class=\"headerlink\" title=\"读完的书\"></a>读完的书</h3><ul>\n<li>嫌疑犯X的献身</li>\n<li>解忧杂货铺</li>\n<li>追风筝的人</li>\n<li>岛上书店</li>\n<li>图解HTTP</li>\n<li>贫民窟的百万富翁</li>\n<li>三体</li>\n<li>明朝那些事</li>\n<li>动物庄园</li>\n<li>看见</li>\n<li>偷影子的人</li>\n<li>白夜行</li>\n<li>小王子</li>\n<li>无声告白</li>\n<li>狼图腾</li>\n<li>百年孤独</li>\n<li>虚无的十字架</li>\n<li>哈利波特（在读）</li>\n</ul>\n"},{"layout":"post","title":"下雨的时候最适合胡思乱想","date":"1992-06-19T16:00:00.000Z","_content":"\n夜晚下着雨的时候最适合胡思乱想了\n\n想现在\n想过去\n想将来\n\n已经工作一年了\n像我这样\n绕不开一个话题\n情\n我想知道别人是不是这样\n我觉得我都要失去爱一人的能力了\n在工作后\n除了公司的人很久没有再和其他陌生人产生交集了\n对于陌生的交际我显得毫无办法\n我不敢也不愿去融入不感兴趣的圈子\n来显得我很好相处\n我很合群\n我习惯了自己\n\n身上早已有了一个厚厚的壳\n能够抵御所有的苦难\n每个人在接近的时候\n都会受到一些阻挡\n唯有几个人他会穿过\n父母\n还有一个她\n那个未知名\n未曾谋面\n不曾相遇\n\n我很慌张\n我怕时间久了\n我不仅会失去爱一个人的能力\n我怕我变得市侩\n我怕我变得势利\n我怕我对单纯的爱一件事都会思前想后\n我怕不会再像小时候\n单纯喜欢一件事去做\n不考虑其他因素\n我怕时间过得太快\n快过我的成长赶不上父母的老去\n\n实话说我没有对人说过爱这个字\n我喜欢过很多人\n但爱\n我觉得他的分量很重很重\n说出这个字就意味着责任远大于其他\n所以我没有资本也没有勇气去说出他\n\n工作一年我越发觉得这个字的重要性\n未来我如果说出这个字\n我认为他指的一万年\n\n且不说我有没有脚踏七彩祥云\n但就算是五指山紧箍咒我也在所不惜\n\n晚安","source":"_posts/1992-06-20-下雨的时候最适合胡思乱想.md","raw":"---\nlayout: post\ntitle: 下雨的时候最适合胡思乱想\ndate: 1992-06-20\ntags: ['杂事二三']\ncategories: 杂事二三\n---\n\n夜晚下着雨的时候最适合胡思乱想了\n\n想现在\n想过去\n想将来\n\n已经工作一年了\n像我这样\n绕不开一个话题\n情\n我想知道别人是不是这样\n我觉得我都要失去爱一人的能力了\n在工作后\n除了公司的人很久没有再和其他陌生人产生交集了\n对于陌生的交际我显得毫无办法\n我不敢也不愿去融入不感兴趣的圈子\n来显得我很好相处\n我很合群\n我习惯了自己\n\n身上早已有了一个厚厚的壳\n能够抵御所有的苦难\n每个人在接近的时候\n都会受到一些阻挡\n唯有几个人他会穿过\n父母\n还有一个她\n那个未知名\n未曾谋面\n不曾相遇\n\n我很慌张\n我怕时间久了\n我不仅会失去爱一个人的能力\n我怕我变得市侩\n我怕我变得势利\n我怕我对单纯的爱一件事都会思前想后\n我怕不会再像小时候\n单纯喜欢一件事去做\n不考虑其他因素\n我怕时间过得太快\n快过我的成长赶不上父母的老去\n\n实话说我没有对人说过爱这个字\n我喜欢过很多人\n但爱\n我觉得他的分量很重很重\n说出这个字就意味着责任远大于其他\n所以我没有资本也没有勇气去说出他\n\n工作一年我越发觉得这个字的重要性\n未来我如果说出这个字\n我认为他指的一万年\n\n且不说我有没有脚踏七彩祥云\n但就算是五指山紧箍咒我也在所不惜\n\n晚安","slug":"下雨的时候最适合胡思乱想","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1xs0005sq5l09fs9cbv","content":"<p>夜晚下着雨的时候最适合胡思乱想了</p>\n<p>想现在<br>想过去<br>想将来</p>\n<p>已经工作一年了<br>像我这样<br>绕不开一个话题<br>情<br>我想知道别人是不是这样<br>我觉得我都要失去爱一人的能力了<br>在工作后<br>除了公司的人很久没有再和其他陌生人产生交集了<br>对于陌生的交际我显得毫无办法<br>我不敢也不愿去融入不感兴趣的圈子<br>来显得我很好相处<br>我很合群<br>我习惯了自己</p>\n<p>身上早已有了一个厚厚的壳<br>能够抵御所有的苦难<br>每个人在接近的时候<br>都会受到一些阻挡<br>唯有几个人他会穿过<br>父母<br>还有一个她<br>那个未知名<br>未曾谋面<br>不曾相遇</p>\n<p>我很慌张<br>我怕时间久了<br>我不仅会失去爱一个人的能力<br>我怕我变得市侩<br>我怕我变得势利<br>我怕我对单纯的爱一件事都会思前想后<br>我怕不会再像小时候<br>单纯喜欢一件事去做<br>不考虑其他因素<br>我怕时间过得太快<br>快过我的成长赶不上父母的老去</p>\n<p>实话说我没有对人说过爱这个字<br>我喜欢过很多人<br>但爱<br>我觉得他的分量很重很重<br>说出这个字就意味着责任远大于其他<br>所以我没有资本也没有勇气去说出他</p>\n<p>工作一年我越发觉得这个字的重要性<br>未来我如果说出这个字<br>我认为他指的一万年</p>\n<p>且不说我有没有脚踏七彩祥云<br>但就算是五指山紧箍咒我也在所不惜</p>\n<p>晚安</p>\n","excerpt":"","more":"<p>夜晚下着雨的时候最适合胡思乱想了</p>\n<p>想现在<br>想过去<br>想将来</p>\n<p>已经工作一年了<br>像我这样<br>绕不开一个话题<br>情<br>我想知道别人是不是这样<br>我觉得我都要失去爱一人的能力了<br>在工作后<br>除了公司的人很久没有再和其他陌生人产生交集了<br>对于陌生的交际我显得毫无办法<br>我不敢也不愿去融入不感兴趣的圈子<br>来显得我很好相处<br>我很合群<br>我习惯了自己</p>\n<p>身上早已有了一个厚厚的壳<br>能够抵御所有的苦难<br>每个人在接近的时候<br>都会受到一些阻挡<br>唯有几个人他会穿过<br>父母<br>还有一个她<br>那个未知名<br>未曾谋面<br>不曾相遇</p>\n<p>我很慌张<br>我怕时间久了<br>我不仅会失去爱一个人的能力<br>我怕我变得市侩<br>我怕我变得势利<br>我怕我对单纯的爱一件事都会思前想后<br>我怕不会再像小时候<br>单纯喜欢一件事去做<br>不考虑其他因素<br>我怕时间过得太快<br>快过我的成长赶不上父母的老去</p>\n<p>实话说我没有对人说过爱这个字<br>我喜欢过很多人<br>但爱<br>我觉得他的分量很重很重<br>说出这个字就意味着责任远大于其他<br>所以我没有资本也没有勇气去说出他</p>\n<p>工作一年我越发觉得这个字的重要性<br>未来我如果说出这个字<br>我认为他指的一万年</p>\n<p>且不说我有没有脚踏七彩祥云<br>但就算是五指山紧箍咒我也在所不惜</p>\n<p>晚安</p>\n"},{"layout":"post","title":"我为什么想要开一个博客","date":"2016-01-12T14:46:12.000Z","_content":"\n不知道什么时候开始，不喜欢在再QQ空间或者微信里发表最近的动态和心情，不再向无关紧要的人去表达自己的看法，也许和以前经历的一些事情有关，唯一能刷存在感的事情就是在朋友圈里发一下我最近练习的曲子，这也是在满足自己那一点小小的虚荣心吧。\n\n自从毕业以来，深深感觉到了之前对于学习确实是疏忽了，进而浪费了很多可以用来成长的机会。毕业之前从来没想过，以后要干什么，以后能干什么，以后想干什么。真正事情到了眼前不得不面对的时候才会幡然醒悟，原来自己错过了很多很多，听过这么一句话：如果总是在后悔中度过，那你一定没有进步。我也一样，总是在夜深的时候矫情起来，想着过去的点点滴滴，在盘算着原来如果这么做现在将会怎样，后悔、惋惜也怀念着当初，可是时间的车轮滚滚并不会留给我们这样的机会让我们停下脚步，唯有更加努力的向前奔跑才可能追回我们失去的、期待的和想要得到的。\n\n浑浑噩噩的活了这么多年，也应该对自己负责了。曾有人说过，每天拿出一个小时的时间，来学习一项技能，一年之后你将在这方面超过百分之九十九的人，我深以为然。两年的时间我一直坚持的练习吉他，现在虽说我并不能以其为生，但是他确实变成了我的一项额外技能。所以坚持的重要性不言而喻。\n\n说了这么多无非是对我想要建立这么一个博客阐述一下自己的观点。第一，长大后有一些话不想对任何人说，只是想找一个可能没有很多人关注却又开放的地方说说自己想说的话，原来这个地方其实是我的空间留言板和并没有人关注的微博，现在我觉得我应该换一种方式来重新开始这件事情了；第二，独立思考、学习、回顾和分享。以为学习和回顾其实是密不可分的，只有学习，而没有回顾和总结是不扎实的，而有了总结而没有分享是不可靠的，不是说如果你不能和别人讲清楚一件事情就意味着你并没有搞懂这件事情吗？所以一个分享的过程其实是一个在学习的过程，可以查漏补缺；第三，锻炼自己的恒心，不需要频繁不断，只要可以坚持不懈的坚持下去，就算一个月一篇，十年也是一个不小的数目；第四，是给自己年老以后留下一些纪念了，以至于老了之后我们回想起过去，不至于再回想起过去竟然毫无头绪，竟然没有能和外人炫耀的事情。\n\n目前，我能想到的原因大概就这么几点，如果再有想起我会再来补充，最后希望自己可以坚持下去，就像自己基本每个月一更的弹唱视频一样（虽说并没有几个人看），但也还在坚持着。\n\n已是深夜，关机，睡觉。\n","source":"_posts/2016-01-12-我为什么想要开一个博客.md","raw":"---\nlayout: post\ntitle: 我为什么想要开一个博客\ndate: 2016-01-12 22:46:12\ntags: [杂事二三]\ncategories: 杂事二三\n---\n\n不知道什么时候开始，不喜欢在再QQ空间或者微信里发表最近的动态和心情，不再向无关紧要的人去表达自己的看法，也许和以前经历的一些事情有关，唯一能刷存在感的事情就是在朋友圈里发一下我最近练习的曲子，这也是在满足自己那一点小小的虚荣心吧。\n\n自从毕业以来，深深感觉到了之前对于学习确实是疏忽了，进而浪费了很多可以用来成长的机会。毕业之前从来没想过，以后要干什么，以后能干什么，以后想干什么。真正事情到了眼前不得不面对的时候才会幡然醒悟，原来自己错过了很多很多，听过这么一句话：如果总是在后悔中度过，那你一定没有进步。我也一样，总是在夜深的时候矫情起来，想着过去的点点滴滴，在盘算着原来如果这么做现在将会怎样，后悔、惋惜也怀念着当初，可是时间的车轮滚滚并不会留给我们这样的机会让我们停下脚步，唯有更加努力的向前奔跑才可能追回我们失去的、期待的和想要得到的。\n\n浑浑噩噩的活了这么多年，也应该对自己负责了。曾有人说过，每天拿出一个小时的时间，来学习一项技能，一年之后你将在这方面超过百分之九十九的人，我深以为然。两年的时间我一直坚持的练习吉他，现在虽说我并不能以其为生，但是他确实变成了我的一项额外技能。所以坚持的重要性不言而喻。\n\n说了这么多无非是对我想要建立这么一个博客阐述一下自己的观点。第一，长大后有一些话不想对任何人说，只是想找一个可能没有很多人关注却又开放的地方说说自己想说的话，原来这个地方其实是我的空间留言板和并没有人关注的微博，现在我觉得我应该换一种方式来重新开始这件事情了；第二，独立思考、学习、回顾和分享。以为学习和回顾其实是密不可分的，只有学习，而没有回顾和总结是不扎实的，而有了总结而没有分享是不可靠的，不是说如果你不能和别人讲清楚一件事情就意味着你并没有搞懂这件事情吗？所以一个分享的过程其实是一个在学习的过程，可以查漏补缺；第三，锻炼自己的恒心，不需要频繁不断，只要可以坚持不懈的坚持下去，就算一个月一篇，十年也是一个不小的数目；第四，是给自己年老以后留下一些纪念了，以至于老了之后我们回想起过去，不至于再回想起过去竟然毫无头绪，竟然没有能和外人炫耀的事情。\n\n目前，我能想到的原因大概就这么几点，如果再有想起我会再来补充，最后希望自己可以坚持下去，就像自己基本每个月一更的弹唱视频一样（虽说并没有几个人看），但也还在坚持着。\n\n已是深夜，关机，睡觉。\n","slug":"我为什么想要开一个博客","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1y10009sq5ldajc4t6r","content":"<p>不知道什么时候开始，不喜欢在再QQ空间或者微信里发表最近的动态和心情，不再向无关紧要的人去表达自己的看法，也许和以前经历的一些事情有关，唯一能刷存在感的事情就是在朋友圈里发一下我最近练习的曲子，这也是在满足自己那一点小小的虚荣心吧。</p>\n<p>自从毕业以来，深深感觉到了之前对于学习确实是疏忽了，进而浪费了很多可以用来成长的机会。毕业之前从来没想过，以后要干什么，以后能干什么，以后想干什么。真正事情到了眼前不得不面对的时候才会幡然醒悟，原来自己错过了很多很多，听过这么一句话：如果总是在后悔中度过，那你一定没有进步。我也一样，总是在夜深的时候矫情起来，想着过去的点点滴滴，在盘算着原来如果这么做现在将会怎样，后悔、惋惜也怀念着当初，可是时间的车轮滚滚并不会留给我们这样的机会让我们停下脚步，唯有更加努力的向前奔跑才可能追回我们失去的、期待的和想要得到的。</p>\n<p>浑浑噩噩的活了这么多年，也应该对自己负责了。曾有人说过，每天拿出一个小时的时间，来学习一项技能，一年之后你将在这方面超过百分之九十九的人，我深以为然。两年的时间我一直坚持的练习吉他，现在虽说我并不能以其为生，但是他确实变成了我的一项额外技能。所以坚持的重要性不言而喻。</p>\n<p>说了这么多无非是对我想要建立这么一个博客阐述一下自己的观点。第一，长大后有一些话不想对任何人说，只是想找一个可能没有很多人关注却又开放的地方说说自己想说的话，原来这个地方其实是我的空间留言板和并没有人关注的微博，现在我觉得我应该换一种方式来重新开始这件事情了；第二，独立思考、学习、回顾和分享。以为学习和回顾其实是密不可分的，只有学习，而没有回顾和总结是不扎实的，而有了总结而没有分享是不可靠的，不是说如果你不能和别人讲清楚一件事情就意味着你并没有搞懂这件事情吗？所以一个分享的过程其实是一个在学习的过程，可以查漏补缺；第三，锻炼自己的恒心，不需要频繁不断，只要可以坚持不懈的坚持下去，就算一个月一篇，十年也是一个不小的数目；第四，是给自己年老以后留下一些纪念了，以至于老了之后我们回想起过去，不至于再回想起过去竟然毫无头绪，竟然没有能和外人炫耀的事情。</p>\n<p>目前，我能想到的原因大概就这么几点，如果再有想起我会再来补充，最后希望自己可以坚持下去，就像自己基本每个月一更的弹唱视频一样（虽说并没有几个人看），但也还在坚持着。</p>\n<p>已是深夜，关机，睡觉。</p>\n","excerpt":"","more":"<p>不知道什么时候开始，不喜欢在再QQ空间或者微信里发表最近的动态和心情，不再向无关紧要的人去表达自己的看法，也许和以前经历的一些事情有关，唯一能刷存在感的事情就是在朋友圈里发一下我最近练习的曲子，这也是在满足自己那一点小小的虚荣心吧。</p>\n<p>自从毕业以来，深深感觉到了之前对于学习确实是疏忽了，进而浪费了很多可以用来成长的机会。毕业之前从来没想过，以后要干什么，以后能干什么，以后想干什么。真正事情到了眼前不得不面对的时候才会幡然醒悟，原来自己错过了很多很多，听过这么一句话：如果总是在后悔中度过，那你一定没有进步。我也一样，总是在夜深的时候矫情起来，想着过去的点点滴滴，在盘算着原来如果这么做现在将会怎样，后悔、惋惜也怀念着当初，可是时间的车轮滚滚并不会留给我们这样的机会让我们停下脚步，唯有更加努力的向前奔跑才可能追回我们失去的、期待的和想要得到的。</p>\n<p>浑浑噩噩的活了这么多年，也应该对自己负责了。曾有人说过，每天拿出一个小时的时间，来学习一项技能，一年之后你将在这方面超过百分之九十九的人，我深以为然。两年的时间我一直坚持的练习吉他，现在虽说我并不能以其为生，但是他确实变成了我的一项额外技能。所以坚持的重要性不言而喻。</p>\n<p>说了这么多无非是对我想要建立这么一个博客阐述一下自己的观点。第一，长大后有一些话不想对任何人说，只是想找一个可能没有很多人关注却又开放的地方说说自己想说的话，原来这个地方其实是我的空间留言板和并没有人关注的微博，现在我觉得我应该换一种方式来重新开始这件事情了；第二，独立思考、学习、回顾和分享。以为学习和回顾其实是密不可分的，只有学习，而没有回顾和总结是不扎实的，而有了总结而没有分享是不可靠的，不是说如果你不能和别人讲清楚一件事情就意味着你并没有搞懂这件事情吗？所以一个分享的过程其实是一个在学习的过程，可以查漏补缺；第三，锻炼自己的恒心，不需要频繁不断，只要可以坚持不懈的坚持下去，就算一个月一篇，十年也是一个不小的数目；第四，是给自己年老以后留下一些纪念了，以至于老了之后我们回想起过去，不至于再回想起过去竟然毫无头绪，竟然没有能和外人炫耀的事情。</p>\n<p>目前，我能想到的原因大概就这么几点，如果再有想起我会再来补充，最后希望自己可以坚持下去，就像自己基本每个月一更的弹唱视频一样（虽说并没有几个人看），但也还在坚持着。</p>\n<p>已是深夜，关机，睡觉。</p>\n"},{"layout":"post","title":"markdown语法简介","date":"2016-01-08T12:46:12.000Z","_content":"\n在我看来markdown语法就是可以不需要了解html,来编写博客网页.\n总结这个也是为了将来自己有不会的地方可以很快的查看一下.\n\n### 1. 标题标签写法\n\n* ***markdown中的写法:***\n\n```bash\n一级标题\n=======\n\n二级标题\n-----------\n\n### 其他级别标题\n```\n\n* ***对应的html结构:***\n\n```html\n<h1>一级标题</h1>\n\n<h2>二级标题</h2>\n\n<h3>其他级别标题</h3>\n```\n\n### 2. 段落标签<p>写法\n\n* ***markdown中的写法:***\n\n```bash\n这是一个段落,段落分隔用一个空白行\n```\n\n* ***对应的html结构:***\n\n```html\n<p>这是一个段落,段落分隔用一个空白行</p>\n```\n\n* ***在页面中显示的效果:***\n\n这是一个段落,段落分隔用一个空白行\n\n---\n\n### 3. 强调< em >,粗体< strong >,代码< code >,删除< s >写法\n* ***markdown中的写法:***\n\n```bash\n各类标签:*强调标签em*,**加粗标签strong**,`代码标签code`\n```\n\n* ***对应的html结构:***\n\n```html\n<p>Text attributes <em>italic</em>, <strong>bold</strong>,<code>monospace</code></p>\n```\n\n* ***在页面中显示的效果:***\n\n各类标签:\n*强调标签em*,\n**加粗标签strong**,\n`代码标签code`\n\n---\n\n### 4. 有序列表<ol>和无序列表<ul>写法\n* ***markdown中的写法:***\n\n```bash\n有序列表:\n\n1. 列表1\n2. 列表2\n3. 列表3\n```\n\n```bash\n无序列表:\n\n* 列表1\n* 列表2\n* 列表3\n```\n\n* ***对应的html结构:***\n\n```html\n<p>有序列表:</p>\n\n<ol>\n<li>列表1</li>\n<li>列表2</li>\n<li>列表3</li>\n</ol>\n```\n\n```html\n<p>无序列表:</p>\n\n<ul>\n<li>列表1</li>\n<li>列表2</li>\n<li>列表3</li>\n</ul>\n```\n\n* ***在页面中显示的效果:***\n\n有序列表:\n\n1. 列表1\n2. 列表2\n3. 列表3\n\n无序列表:\n\n* 列表1\n* 列表2\n* 列表3\n\n---\n\n### 5. 链接的写法\n* ***markdown中的写法:***\n\n行内式写法:\n\n```bash\n这是行内式写法的[例子](http://example.com/ \"Title\")\n\n这是行内式写法没有title属性的[例子](http://example.net/)\n```\n参考式写法1:\n\n```bash\n这是参考式写法1的[例子][id]\n[id]: http://example.com/  \"Optional Title Here\"\n```\n参考式写法2:\n\n```bash\n这是参考式写法2的[例子][]\n[例子]: http://example.com/  \"Optional Title Here\"\n```\n\n* ***对应的html结构:***\n\n行内式:\n\n```html\n<p>这是行内式写法的<a href=\"http://example.com/\" title=\"Title\">例子</a></p>\n\n<p>这是行内式写法没有title属性的<a href=\"http://example.net/\">例子</a></p>\n```\n参考式1:\n\n```html\n<p>这是参考式写法1的<a href=\"http://example.com/\" title=\"Optional Title Here\">例子</a></p>\n```\n参考式2:\n\n```html\n<p>这是参考式写法2的<a href=\"http://example.com/\" title=\"Optional Title Here\">例子</a></p>\n```\n* ***在页面中显示的效果:***\n\n这是行内式写法的[例子](http://example.com/ \"Title\")\n\n这是行内式写法没有title属性的[例子](http://example.net/)\n\n这是参考式写法1的[例子] [id]\n\n[id]: http://example.com/  \"Optional Title Here\"\n\n这是参考式写法2的[例子][]\n\n[例子]: http://example.com/  \"Optional Title Here\"\n\n---\n\n### 6. 反斜杠转译\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n```bash\n\\   反斜线\n`   反引号\n*   星号\n_   底线\n{}  花括号\n[]  方括号\n()  括弧\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   惊叹号\n```\n\n以上,其实还有图片的插入,不过和添加链接类似,在此不再赘述了.\n","source":"_posts/2016-01-08-markdown.md","raw":"---\nlayout: post\ntitle:  \"markdown语法简介\"\ndate:   2016-01-08 20:46:12\ntags: [markdown]\ncategories: markdown\n---\n\n在我看来markdown语法就是可以不需要了解html,来编写博客网页.\n总结这个也是为了将来自己有不会的地方可以很快的查看一下.\n\n### 1. 标题标签写法\n\n* ***markdown中的写法:***\n\n```bash\n一级标题\n=======\n\n二级标题\n-----------\n\n### 其他级别标题\n```\n\n* ***对应的html结构:***\n\n```html\n<h1>一级标题</h1>\n\n<h2>二级标题</h2>\n\n<h3>其他级别标题</h3>\n```\n\n### 2. 段落标签<p>写法\n\n* ***markdown中的写法:***\n\n```bash\n这是一个段落,段落分隔用一个空白行\n```\n\n* ***对应的html结构:***\n\n```html\n<p>这是一个段落,段落分隔用一个空白行</p>\n```\n\n* ***在页面中显示的效果:***\n\n这是一个段落,段落分隔用一个空白行\n\n---\n\n### 3. 强调< em >,粗体< strong >,代码< code >,删除< s >写法\n* ***markdown中的写法:***\n\n```bash\n各类标签:*强调标签em*,**加粗标签strong**,`代码标签code`\n```\n\n* ***对应的html结构:***\n\n```html\n<p>Text attributes <em>italic</em>, <strong>bold</strong>,<code>monospace</code></p>\n```\n\n* ***在页面中显示的效果:***\n\n各类标签:\n*强调标签em*,\n**加粗标签strong**,\n`代码标签code`\n\n---\n\n### 4. 有序列表<ol>和无序列表<ul>写法\n* ***markdown中的写法:***\n\n```bash\n有序列表:\n\n1. 列表1\n2. 列表2\n3. 列表3\n```\n\n```bash\n无序列表:\n\n* 列表1\n* 列表2\n* 列表3\n```\n\n* ***对应的html结构:***\n\n```html\n<p>有序列表:</p>\n\n<ol>\n<li>列表1</li>\n<li>列表2</li>\n<li>列表3</li>\n</ol>\n```\n\n```html\n<p>无序列表:</p>\n\n<ul>\n<li>列表1</li>\n<li>列表2</li>\n<li>列表3</li>\n</ul>\n```\n\n* ***在页面中显示的效果:***\n\n有序列表:\n\n1. 列表1\n2. 列表2\n3. 列表3\n\n无序列表:\n\n* 列表1\n* 列表2\n* 列表3\n\n---\n\n### 5. 链接的写法\n* ***markdown中的写法:***\n\n行内式写法:\n\n```bash\n这是行内式写法的[例子](http://example.com/ \"Title\")\n\n这是行内式写法没有title属性的[例子](http://example.net/)\n```\n参考式写法1:\n\n```bash\n这是参考式写法1的[例子][id]\n[id]: http://example.com/  \"Optional Title Here\"\n```\n参考式写法2:\n\n```bash\n这是参考式写法2的[例子][]\n[例子]: http://example.com/  \"Optional Title Here\"\n```\n\n* ***对应的html结构:***\n\n行内式:\n\n```html\n<p>这是行内式写法的<a href=\"http://example.com/\" title=\"Title\">例子</a></p>\n\n<p>这是行内式写法没有title属性的<a href=\"http://example.net/\">例子</a></p>\n```\n参考式1:\n\n```html\n<p>这是参考式写法1的<a href=\"http://example.com/\" title=\"Optional Title Here\">例子</a></p>\n```\n参考式2:\n\n```html\n<p>这是参考式写法2的<a href=\"http://example.com/\" title=\"Optional Title Here\">例子</a></p>\n```\n* ***在页面中显示的效果:***\n\n这是行内式写法的[例子](http://example.com/ \"Title\")\n\n这是行内式写法没有title属性的[例子](http://example.net/)\n\n这是参考式写法1的[例子] [id]\n\n[id]: http://example.com/  \"Optional Title Here\"\n\n这是参考式写法2的[例子][]\n\n[例子]: http://example.com/  \"Optional Title Here\"\n\n---\n\n### 6. 反斜杠转译\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n```bash\n\\   反斜线\n`   反引号\n*   星号\n_   底线\n{}  花括号\n[]  方括号\n()  括弧\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   惊叹号\n```\n\n以上,其实还有图片的插入,不过和添加链接类似,在此不再赘述了.\n","slug":"markdown","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1y3000asq5l9j1h01sk","content":"<p>在我看来markdown语法就是可以不需要了解html,来编写博客网页.<br>总结这个也是为了将来自己有不会的地方可以很快的查看一下.</p>\n<h3 id=\"1-标题标签写法\"><a href=\"#1-标题标签写法\" class=\"headerlink\" title=\"1. 标题标签写法\"></a>1. 标题标签写法</h3><ul>\n<li><strong><em>markdown中的写法:</em></strong></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一级标题</span><br><span class=\"line\">=======</span><br><span class=\"line\"></span><br><span class=\"line\">二级标题</span><br><span class=\"line\">-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 其他级别标题</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>对应的html结构:</em></strong></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>一级标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>二级标题<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>其他级别标题<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-段落标签写法\"><a href=\"#2-段落标签写法\" class=\"headerlink\" title=\"2. 段落标签写法\"></a>2. 段落标签<p>写法</p></h3><ul>\n<li><strong><em>markdown中的写法:</em></strong></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一个段落,段落分隔用一个空白行</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>对应的html结构:</em></strong></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是一个段落,段落分隔用一个空白行<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>在页面中显示的效果:</em></strong></li>\n</ul>\n<p>这是一个段落,段落分隔用一个空白行</p>\n<hr>\n<h3 id=\"3-强调-lt-em-gt-粗体-lt-strong-gt-代码-lt-code-gt-删除-lt-s-gt-写法\"><a href=\"#3-强调-lt-em-gt-粗体-lt-strong-gt-代码-lt-code-gt-删除-lt-s-gt-写法\" class=\"headerlink\" title=\"3. 强调&lt; em &gt;,粗体&lt; strong &gt;,代码&lt; code &gt;,删除&lt; s &gt;写法\"></a>3. 强调&lt; em &gt;,粗体&lt; strong &gt;,代码&lt; code &gt;,删除&lt; s &gt;写法</h3><ul>\n<li><strong><em>markdown中的写法:</em></strong></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">各类标签:*强调标签em*,**加粗标签strong**,`代码标签code`</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>对应的html结构:</em></strong></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Text attributes <span class=\"tag\">&lt;<span class=\"name\">em</span>&gt;</span>italic<span class=\"tag\">&lt;/<span class=\"name\">em</span>&gt;</span>, <span class=\"tag\">&lt;<span class=\"name\">strong</span>&gt;</span>bold<span class=\"tag\">&lt;/<span class=\"name\">strong</span>&gt;</span>,<span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>monospace<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>在页面中显示的效果:</em></strong></li>\n</ul>\n<p>各类标签:<br><em>强调标签em</em>,<br><strong>加粗标签strong</strong>,<br><code>代码标签code</code></p>\n<hr>\n<h3 id=\"4-有序列表和无序列表写法\"><a href=\"#4-有序列表和无序列表写法\" class=\"headerlink\" title=\"4. 有序列表和无序列表写法\"></a>4. 有序列表<ol>和无序列表<ul>写法</ul></ol></h3><ul>\n<li><strong><em>markdown中的写法:</em></strong></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有序列表:</span><br><span class=\"line\"></span><br><span class=\"line\">1. 列表1</span><br><span class=\"line\">2. 列表2</span><br><span class=\"line\">3. 列表3</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无序列表:</span><br><span class=\"line\"></span><br><span class=\"line\">* 列表1</span><br><span class=\"line\">* 列表2</span><br><span class=\"line\">* 列表3</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>对应的html结构:</em></strong></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>有序列表:<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>无序列表:<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>在页面中显示的效果:</em></strong></li>\n</ul>\n<p>有序列表:</p>\n<ol>\n<li>列表1</li>\n<li>列表2</li>\n<li>列表3</li>\n</ol>\n<p>无序列表:</p>\n<ul>\n<li>列表1</li>\n<li>列表2</li>\n<li>列表3</li>\n</ul>\n<hr>\n<h3 id=\"5-链接的写法\"><a href=\"#5-链接的写法\" class=\"headerlink\" title=\"5. 链接的写法\"></a>5. 链接的写法</h3><ul>\n<li><strong><em>markdown中的写法:</em></strong></li>\n</ul>\n<p>行内式写法:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是行内式写法的[例子](http://example.com/ <span class=\"string\">\"Title\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">这是行内式写法没有title属性的[例子](http://example.net/)</span><br></pre></td></tr></table></figure>\n<p>参考式写法1:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是参考式写法1的[例子][id]</span><br><span class=\"line\">[id]: http://example.com/  <span class=\"string\">\"Optional Title Here\"</span></span><br></pre></td></tr></table></figure>\n<p>参考式写法2:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是参考式写法2的[例子][]</span><br><span class=\"line\">[例子]: http://example.com/  <span class=\"string\">\"Optional Title Here\"</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>对应的html结构:</em></strong></li>\n</ul>\n<p>行内式:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是行内式写法的<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://example.com/\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Title\"</span>&gt;</span>例子<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是行内式写法没有title属性的<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://example.net/\"</span>&gt;</span>例子<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>参考式1:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是参考式写法1的<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://example.com/\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Optional Title Here\"</span>&gt;</span>例子<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>参考式2:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是参考式写法2的<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://example.com/\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Optional Title Here\"</span>&gt;</span>例子<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>在页面中显示的效果:</em></strong></li>\n</ul>\n<p>这是行内式写法的<a href=\"http://example.com/\" title=\"Title\" target=\"_blank\" rel=\"external\">例子</a></p>\n<p>这是行内式写法没有title属性的<a href=\"http://example.net/\" target=\"_blank\" rel=\"external\">例子</a></p>\n<p>这是参考式写法1的<a href=\"http://example.com/\" title=\"Optional Title Here\" target=\"_blank\" rel=\"external\">例子</a></p>\n<p>这是参考式写法2的<a href=\"http://example.com/\" title=\"Optional Title Here\" target=\"_blank\" rel=\"external\">例子</a></p>\n<hr>\n<h3 id=\"6-反斜杠转译\"><a href=\"#6-反斜杠转译\" class=\"headerlink\" title=\"6. 反斜杠转译\"></a>6. 反斜杠转译</h3><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\   反斜线</span><br><span class=\"line\">`   反引号</span><br><span class=\"line\">*   星号</span><br><span class=\"line\">_   底线</span><br><span class=\"line\">&#123;&#125;  花括号</span><br><span class=\"line\">[]  方括号</span><br><span class=\"line\">()  括弧</span><br><span class=\"line\"><span class=\"comment\">#   井字号</span></span><br><span class=\"line\">+   加号</span><br><span class=\"line\">-   减号</span><br><span class=\"line\">.   英文句点</span><br><span class=\"line\">!   惊叹号</span><br></pre></td></tr></table></figure>\n<p>以上,其实还有图片的插入,不过和添加链接类似,在此不再赘述了.</p>\n","excerpt":"","more":"<p>在我看来markdown语法就是可以不需要了解html,来编写博客网页.<br>总结这个也是为了将来自己有不会的地方可以很快的查看一下.</p>\n<h3 id=\"1-标题标签写法\"><a href=\"#1-标题标签写法\" class=\"headerlink\" title=\"1. 标题标签写法\"></a>1. 标题标签写法</h3><ul>\n<li><strong><em>markdown中的写法:</em></strong></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一级标题</span><br><span class=\"line\">=======</span><br><span class=\"line\"></span><br><span class=\"line\">二级标题</span><br><span class=\"line\">-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 其他级别标题</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>对应的html结构:</em></strong></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>一级标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>二级标题<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>其他级别标题<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-段落标签写法\"><a href=\"#2-段落标签写法\" class=\"headerlink\" title=\"2. 段落标签写法\"></a>2. 段落标签<p>写法</h3><ul>\n<li><strong><em>markdown中的写法:</em></strong></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一个段落,段落分隔用一个空白行</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>对应的html结构:</em></strong></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是一个段落,段落分隔用一个空白行<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>在页面中显示的效果:</em></strong></li>\n</ul>\n<p>这是一个段落,段落分隔用一个空白行</p>\n<hr>\n<h3 id=\"3-强调-lt-em-gt-粗体-lt-strong-gt-代码-lt-code-gt-删除-lt-s-gt-写法\"><a href=\"#3-强调-lt-em-gt-粗体-lt-strong-gt-代码-lt-code-gt-删除-lt-s-gt-写法\" class=\"headerlink\" title=\"3. 强调&lt; em &gt;,粗体&lt; strong &gt;,代码&lt; code &gt;,删除&lt; s &gt;写法\"></a>3. 强调&lt; em &gt;,粗体&lt; strong &gt;,代码&lt; code &gt;,删除&lt; s &gt;写法</h3><ul>\n<li><strong><em>markdown中的写法:</em></strong></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">各类标签:*强调标签em*,**加粗标签strong**,`代码标签code`</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>对应的html结构:</em></strong></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Text attributes <span class=\"tag\">&lt;<span class=\"name\">em</span>&gt;</span>italic<span class=\"tag\">&lt;/<span class=\"name\">em</span>&gt;</span>, <span class=\"tag\">&lt;<span class=\"name\">strong</span>&gt;</span>bold<span class=\"tag\">&lt;/<span class=\"name\">strong</span>&gt;</span>,<span class=\"tag\">&lt;<span class=\"name\">code</span>&gt;</span>monospace<span class=\"tag\">&lt;/<span class=\"name\">code</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>在页面中显示的效果:</em></strong></li>\n</ul>\n<p>各类标签:<br><em>强调标签em</em>,<br><strong>加粗标签strong</strong>,<br><code>代码标签code</code></p>\n<hr>\n<h3 id=\"4-有序列表和无序列表写法\"><a href=\"#4-有序列表和无序列表写法\" class=\"headerlink\" title=\"4. 有序列表和无序列表写法\"></a>4. 有序列表<ol>和无序列表<ul>写法</h3><ul>\n<li><strong><em>markdown中的写法:</em></strong></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有序列表:</span><br><span class=\"line\"></span><br><span class=\"line\">1. 列表1</span><br><span class=\"line\">2. 列表2</span><br><span class=\"line\">3. 列表3</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无序列表:</span><br><span class=\"line\"></span><br><span class=\"line\">* 列表1</span><br><span class=\"line\">* 列表2</span><br><span class=\"line\">* 列表3</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>对应的html结构:</em></strong></li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>有序列表:<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ol</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>无序列表:<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表1<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表2<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>列表3<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>在页面中显示的效果:</em></strong></li>\n</ul>\n<p>有序列表:</p>\n<ol>\n<li>列表1</li>\n<li>列表2</li>\n<li>列表3</li>\n</ol>\n<p>无序列表:</p>\n<ul>\n<li>列表1</li>\n<li>列表2</li>\n<li>列表3</li>\n</ul>\n<hr>\n<h3 id=\"5-链接的写法\"><a href=\"#5-链接的写法\" class=\"headerlink\" title=\"5. 链接的写法\"></a>5. 链接的写法</h3><ul>\n<li><strong><em>markdown中的写法:</em></strong></li>\n</ul>\n<p>行内式写法:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是行内式写法的[例子](http://example.com/ <span class=\"string\">\"Title\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">这是行内式写法没有title属性的[例子](http://example.net/)</span><br></pre></td></tr></table></figure>\n<p>参考式写法1:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是参考式写法1的[例子][id]</span><br><span class=\"line\">[id]: http://example.com/  <span class=\"string\">\"Optional Title Here\"</span></span><br></pre></td></tr></table></figure>\n<p>参考式写法2:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是参考式写法2的[例子][]</span><br><span class=\"line\">[例子]: http://example.com/  <span class=\"string\">\"Optional Title Here\"</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>对应的html结构:</em></strong></li>\n</ul>\n<p>行内式:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是行内式写法的<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://example.com/\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Title\"</span>&gt;</span>例子<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是行内式写法没有title属性的<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://example.net/\"</span>&gt;</span>例子<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>参考式1:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是参考式写法1的<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://example.com/\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Optional Title Here\"</span>&gt;</span>例子<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>参考式2:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>这是参考式写法2的<span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"http://example.com/\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"Optional Title Here\"</span>&gt;</span>例子<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong><em>在页面中显示的效果:</em></strong></li>\n</ul>\n<p>这是行内式写法的<a href=\"http://example.com/\" title=\"Title\">例子</a></p>\n<p>这是行内式写法没有title属性的<a href=\"http://example.net/\">例子</a></p>\n<p>这是参考式写法1的<a href=\"http://example.com/\" title=\"Optional Title Here\">例子</a></p>\n<p>这是参考式写法2的<a href=\"http://example.com/\" title=\"Optional Title Here\">例子</a></p>\n<hr>\n<h3 id=\"6-反斜杠转译\"><a href=\"#6-反斜杠转译\" class=\"headerlink\" title=\"6. 反斜杠转译\"></a>6. 反斜杠转译</h3><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\   反斜线</span><br><span class=\"line\">`   反引号</span><br><span class=\"line\">*   星号</span><br><span class=\"line\">_   底线</span><br><span class=\"line\">&#123;&#125;  花括号</span><br><span class=\"line\">[]  方括号</span><br><span class=\"line\">()  括弧</span><br><span class=\"line\"><span class=\"comment\">#   井字号</span></span><br><span class=\"line\">+   加号</span><br><span class=\"line\">-   减号</span><br><span class=\"line\">.   英文句点</span><br><span class=\"line\">!   惊叹号</span><br></pre></td></tr></table></figure>\n<p>以上,其实还有图片的插入,不过和添加链接类似,在此不再赘述了.</p>\n"},{"layout":"post","title":"ES6学习笔记(let和const命令)","date":"2016-01-21T16:00:00.000Z","_content":"笔记根据阮一峰老师的[ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/let)，内容基本来自于此书，总结是为了理解学习和加深印象，把认为重要的部分记录下来。\n\n### 1. let命令\n\n**************************\n\n#### 基本用法\n\n\nES6中新增加了`let`用来声明变量,他和`var`的用法类似，但是let声明的变量只在let所在的代码块内有效。\n\n```js\n\n{\n  let a = 10;\n  var b = 1;\n  a // 10\n}\n\na // ReferenceError: a is not defined.\nb // 1\n\n```\n\n\n如上面代码所示，如果在代码块外面调用了let的话，结果会报错。这表明let声明的变量只在他所在的代码块有效。\n\n所以`for`循环中，我们用let声明会很合适。\n```js\n\nfor( let i = 0; i < arr.length; i++){}\n\nconsole.log(i)//ReferenceError: i is not defined\n\n```\n\n上面代码的计数器i,只在for循环内有效。\n\n<br>\n下面的代码如果使用`var`，最终的输出结果是10。\n\n```js\n\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 10\n\n```\n\n因为`var`声明的`i`在全局作用域中都有效，当在循环当中时`a[6]`返回`function () {console.log(i);};`，当在`for`循环执行完毕后`i`的值会变成10。当执行`a[6]()`时结果为10。\n\n<br>\n\n如果使用`let`，声明的变量只在块级作用域内有效，代码如下。\n\n```js\n\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 6\n\n```\n\n如上面代码所示，因为`i`只在本轮循环内有效，所以每一次循环的`i`其实都是一个新的变量，所以最后结果为6。\n\n*******************\n\n#### 不存在变量提升\n\n`let`不会像`var`存在变量提升的现象，所以`let`要在声明之后调用，否则会出现错误。\n\n```js\n\nconsole.log(foo); // 输出undefined\nconsole.log(bar); // 报错ReferenceError\n\nvar foo = 2;\nlet bar = 2;\n\n```\n\n如上代码，在执行代码前，js会提前读取声明的`var`和`function`的变量名（变量值没有预先加载），所以在执行代码前，变量`foo`已经存在了会输出`undefined`，而变量`bar`不会发生变量提升，所以会抛出一个错误。\n\n************\n\n#### 暂时性死区\n\n只要有块级作用域内存在`let`命令，他所声明的变量就绑定这个区域，不再受到外部影响。\n\n```js\n\nvar tmp = 123;\n\nif (true) {\n  tmp = 'abc'; // ReferenceError\n  let tmp;\n}\n\n```\n\n上面代码中，因为块级作用域内`let`声明了局部变量`tmp`，`tmp`就绑定到了这个块级作用域中，块级作用域外的`var`声明会失效，在块级作用域内在还没有`let`声明前就对`tmp`赋值的话就会报错。\n\nES6中规定，如果区块中存在`let`和`const`命令，这个区块对这两种声明的变量从一开始就形成了封闭的作用域，凡是在声明之前就使用这些变量的话就会报错。\n\n简单来说，在代码块内，如果使用`let`命令来声明变量，这个变量在声明之前都是不可用的。这个在语法上称为“暂时性死区”（temporal dead zone，简称TDZ）。\n\n```js\n\nif (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n}\n\n```\n\n上面的代码中，在`let`命令声明变量`tmp`前，都属于`tmp`的“死区”。\n\n“暂时性死区”也意味着`typeof`操作会出现错误。\n\n```js\n\ntypeof x; // ReferenceError\nlet x;\n\n```\n\n但是如果一个变量根本没有被声明，使用`typeof`反而不会报错。\n```js\n//undeclared_variable为为声明变量\ntypeof undeclared_variable // \"undefined\"\n\n```\n\n所以，新语法在有了`let`声明之后，一定要声明完变量之后再去使用，否则有可能会报错。\n\n<br>\n\n还有一些特别的“死区”。\n```js\n\nfunction bar(x = y, y = 2) {\n  return [x, y];\n}\n\nbar(); // 报错\n\n```\n\n上面代码运行会报错，因为在把`y`的值赋给`x`前，`y`还没有声明，属于死区。\n\n总之，暂时性死区的本质就是，在已进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有在声明变量后才可以获取和使用该变量。\n\n*******\n\n#### 不允许重复声明\n\n`let`不允许在相同作用域中，重复声明同一个变量。\n\n```js\n\n// 报错\nfunction () {\n  let a = 10;\n  var a = 1;\n}\n\n// 报错\nfunction () {\n  let a = 10;\n  let a = 1;\n}\n\n```\n\n也不能在函数内部重新声明参数。\n\n```js\n\nfunction func(arg) {\n  let arg; // 报错\n}\n\nfunction func(arg) {\n  {\n    let arg; // 不报错\n  }\n}\n```\n\n*******\n\n### 2. 块级作用域\n\n#### 为什么需要块级作用域？\n\n在ES5中只有全局作用域和函数作用域，没有块级作用域，这会造成很多问题。\n\n计数的循环变量泄露为全局变量。\n\n```js\n\nvar s = 'hello';\n\nfor (var i = 0; i < s.length; i++){\n  console.log(s[i]);\n}\n\nconsole.log(i); // 5\n\n```\n\n*******\n\n#### ES6的块级作用域\n\n`let`是为JavaScript新增了块级作用域。\n```js\n\nfunction f1() {\n  let n = 5;\n  if (true) {\n    let n = 10;\n  }\n  console.log(n); // 5\n}\n\n```\n\n最后输出的结果为5，这表示`let`声明的是一个块级作用域，外层的代码块不受内层的影响，如果使用`var`声明的话，最后输出结果为10。\n\n块级作用域出现后，立即执行匿名函数（IIFE）就不是唯一的选择了。\n```js\n\n// IIFE写法\n(function () {\n  var tmp = ...;\n  ...\n}());\n\n// 块级作用域写法\n{\n  let tmp = ...;\n  ...\n}\n\n```\n\n*******\n\n### 3. const命令\n\nconst也用来声明变量，这个变量是常量一旦声明，他的值是不可以改变的。\n\n```js\n\n'use strict';\nconst PI = 3.1415;\nPI // 3.1415\n\nPI = 3;\n// TypeError: \"PI\" is read-only\n\n```\n\n在严格模式下，改变声明的常量的值会报错。在常规模式下不会报错但也不起作用。\n```js\n\nconst PI = 3.1415;\nPI = 3; // 常规模式时，重新赋值无效，但不报错\nPI // 3.1415\n\n```\n\nconst声明的变量不可以改变值，所以一旦声明后必须立即初始化。\n\n```js\n\n'use strict';\nconst foo;\n// SyntaxError: missing = in const declaration\n\n```\n\n如上面代码所示，在严格模式下，如果没有立即初始化，会报错。在常规模式下，不会报错，但是以后对`foo`赋值的话也是无效的。\n\n```js\n\nconst foo;\nfoo = 1; // 常规模式，重新赋值无效\nfoo // undefined\n\n```\n\n`const`的作用与和`let`相同，都是在块级作用域之内有效，并且也不存在声明提升，会出现暂时性死区，只能在声明之后才能够调用。\n\n```js\n\nif (true) {\n  console.log(MAX); // ReferenceError\n  const MAX = 5;\n}\n\n```\n\n`const`声明的常量，也和`let`一样不可以重复声明。\n\n```js\n\nvar message = \"Hello!\";\nlet age = 25;\n\n// 以下两行都会报错\nconst message = \"Goodbye!\";\nconst age = 30;\n\n```\n\n对于复合型变量名，变量名不会指向数据，而是指向数据所在的地址。`const`命令可以使指向的地址不变，但是不能保证地址内的数据不变。比如，如果使用`const`声明了一个对象，其实是声明了一个指向对象的地址，这个地址是不可变的，但是可以为这个对象来添加新的属性。\n\n```js\n\nconst a = [];\na.push(\"Hello\"); // 可执行\na.length = 0;    // 可执行\na = [\"Dave\"];    // 报错\n\n```\n\n如上，变量`a`是一个数组，数组本身是可以改写的，但是如果将另一个数组赋值给`a`，就会报错。\n\n如果想让一个对象，不能添加新的属性，可以使用`Object.freeze`的方法。\n\n```js\n\nconst foo = Object.freeze({});\n\n// 常规模式时，下面一行不起作用；\n// 严格模式时，该行会报错\nfoo.prop = 123;\n\n```\n\n如上，添加新的属性不会起作用，在严格模式下还会报错。\n\nES5声明变量的方法有两个：`var`,`function`。ES6除了这两种方法外，还有`let`，`const`，`import`和`class`这四种方法。\n\n*******\n\n### 4. 跨模块常量\n\n`const`声明的常量只在当前代码块有效。如果想设置跨模块的常量，可以采用下面的写法。\n\n```js\n\nconst foo = Object.freeze({});\n\n// constants.js 模块\nexport const A = 1;\nexport const B = 3;\nexport const C = 4;\n\n// test1.js 模块\nimport * as constants from './constants';\nconsole.log(constants.A); // 1\nconsole.log(constants.B); // 3\n\n// test2.js 模块\nimport {A, B} from './constants';\nconsole.log(A); // 1\nconsole.log(B); // 3\n\n```\n\n******\n\n### 5. 全局对象的属性\n\nES6规定了，使用`var`和`function`声明的全局变量，依旧是全局对象的属性；使用`let`命令，`const`命令和`class`命令声明的全局变量，不属于全局对象的属性。\n\n```js\n\nvar a = 1;\n// 如果在Node的REPL环境，可以写成global.a\n// 或者采用通用方法，写成this.a\nwindow.a // 1\n\nlet b = 1;\nwindow.b // undefined\n\n```\n\n*******\n\n以上。\n","source":"_posts/2016-01-22-ES6study-1.md","raw":"---\nlayout: post\ntitle: ES6学习笔记(let和const命令)\ndate: 2016-01-22\ntags: [ES6]\ncategories: ES6\n---\n笔记根据阮一峰老师的[ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/let)，内容基本来自于此书，总结是为了理解学习和加深印象，把认为重要的部分记录下来。\n\n### 1. let命令\n\n**************************\n\n#### 基本用法\n\n\nES6中新增加了`let`用来声明变量,他和`var`的用法类似，但是let声明的变量只在let所在的代码块内有效。\n\n```js\n\n{\n  let a = 10;\n  var b = 1;\n  a // 10\n}\n\na // ReferenceError: a is not defined.\nb // 1\n\n```\n\n\n如上面代码所示，如果在代码块外面调用了let的话，结果会报错。这表明let声明的变量只在他所在的代码块有效。\n\n所以`for`循环中，我们用let声明会很合适。\n```js\n\nfor( let i = 0; i < arr.length; i++){}\n\nconsole.log(i)//ReferenceError: i is not defined\n\n```\n\n上面代码的计数器i,只在for循环内有效。\n\n<br>\n下面的代码如果使用`var`，最终的输出结果是10。\n\n```js\n\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 10\n\n```\n\n因为`var`声明的`i`在全局作用域中都有效，当在循环当中时`a[6]`返回`function () {console.log(i);};`，当在`for`循环执行完毕后`i`的值会变成10。当执行`a[6]()`时结果为10。\n\n<br>\n\n如果使用`let`，声明的变量只在块级作用域内有效，代码如下。\n\n```js\n\nvar a = [];\nfor (let i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 6\n\n```\n\n如上面代码所示，因为`i`只在本轮循环内有效，所以每一次循环的`i`其实都是一个新的变量，所以最后结果为6。\n\n*******************\n\n#### 不存在变量提升\n\n`let`不会像`var`存在变量提升的现象，所以`let`要在声明之后调用，否则会出现错误。\n\n```js\n\nconsole.log(foo); // 输出undefined\nconsole.log(bar); // 报错ReferenceError\n\nvar foo = 2;\nlet bar = 2;\n\n```\n\n如上代码，在执行代码前，js会提前读取声明的`var`和`function`的变量名（变量值没有预先加载），所以在执行代码前，变量`foo`已经存在了会输出`undefined`，而变量`bar`不会发生变量提升，所以会抛出一个错误。\n\n************\n\n#### 暂时性死区\n\n只要有块级作用域内存在`let`命令，他所声明的变量就绑定这个区域，不再受到外部影响。\n\n```js\n\nvar tmp = 123;\n\nif (true) {\n  tmp = 'abc'; // ReferenceError\n  let tmp;\n}\n\n```\n\n上面代码中，因为块级作用域内`let`声明了局部变量`tmp`，`tmp`就绑定到了这个块级作用域中，块级作用域外的`var`声明会失效，在块级作用域内在还没有`let`声明前就对`tmp`赋值的话就会报错。\n\nES6中规定，如果区块中存在`let`和`const`命令，这个区块对这两种声明的变量从一开始就形成了封闭的作用域，凡是在声明之前就使用这些变量的话就会报错。\n\n简单来说，在代码块内，如果使用`let`命令来声明变量，这个变量在声明之前都是不可用的。这个在语法上称为“暂时性死区”（temporal dead zone，简称TDZ）。\n\n```js\n\nif (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n}\n\n```\n\n上面的代码中，在`let`命令声明变量`tmp`前，都属于`tmp`的“死区”。\n\n“暂时性死区”也意味着`typeof`操作会出现错误。\n\n```js\n\ntypeof x; // ReferenceError\nlet x;\n\n```\n\n但是如果一个变量根本没有被声明，使用`typeof`反而不会报错。\n```js\n//undeclared_variable为为声明变量\ntypeof undeclared_variable // \"undefined\"\n\n```\n\n所以，新语法在有了`let`声明之后，一定要声明完变量之后再去使用，否则有可能会报错。\n\n<br>\n\n还有一些特别的“死区”。\n```js\n\nfunction bar(x = y, y = 2) {\n  return [x, y];\n}\n\nbar(); // 报错\n\n```\n\n上面代码运行会报错，因为在把`y`的值赋给`x`前，`y`还没有声明，属于死区。\n\n总之，暂时性死区的本质就是，在已进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有在声明变量后才可以获取和使用该变量。\n\n*******\n\n#### 不允许重复声明\n\n`let`不允许在相同作用域中，重复声明同一个变量。\n\n```js\n\n// 报错\nfunction () {\n  let a = 10;\n  var a = 1;\n}\n\n// 报错\nfunction () {\n  let a = 10;\n  let a = 1;\n}\n\n```\n\n也不能在函数内部重新声明参数。\n\n```js\n\nfunction func(arg) {\n  let arg; // 报错\n}\n\nfunction func(arg) {\n  {\n    let arg; // 不报错\n  }\n}\n```\n\n*******\n\n### 2. 块级作用域\n\n#### 为什么需要块级作用域？\n\n在ES5中只有全局作用域和函数作用域，没有块级作用域，这会造成很多问题。\n\n计数的循环变量泄露为全局变量。\n\n```js\n\nvar s = 'hello';\n\nfor (var i = 0; i < s.length; i++){\n  console.log(s[i]);\n}\n\nconsole.log(i); // 5\n\n```\n\n*******\n\n#### ES6的块级作用域\n\n`let`是为JavaScript新增了块级作用域。\n```js\n\nfunction f1() {\n  let n = 5;\n  if (true) {\n    let n = 10;\n  }\n  console.log(n); // 5\n}\n\n```\n\n最后输出的结果为5，这表示`let`声明的是一个块级作用域，外层的代码块不受内层的影响，如果使用`var`声明的话，最后输出结果为10。\n\n块级作用域出现后，立即执行匿名函数（IIFE）就不是唯一的选择了。\n```js\n\n// IIFE写法\n(function () {\n  var tmp = ...;\n  ...\n}());\n\n// 块级作用域写法\n{\n  let tmp = ...;\n  ...\n}\n\n```\n\n*******\n\n### 3. const命令\n\nconst也用来声明变量，这个变量是常量一旦声明，他的值是不可以改变的。\n\n```js\n\n'use strict';\nconst PI = 3.1415;\nPI // 3.1415\n\nPI = 3;\n// TypeError: \"PI\" is read-only\n\n```\n\n在严格模式下，改变声明的常量的值会报错。在常规模式下不会报错但也不起作用。\n```js\n\nconst PI = 3.1415;\nPI = 3; // 常规模式时，重新赋值无效，但不报错\nPI // 3.1415\n\n```\n\nconst声明的变量不可以改变值，所以一旦声明后必须立即初始化。\n\n```js\n\n'use strict';\nconst foo;\n// SyntaxError: missing = in const declaration\n\n```\n\n如上面代码所示，在严格模式下，如果没有立即初始化，会报错。在常规模式下，不会报错，但是以后对`foo`赋值的话也是无效的。\n\n```js\n\nconst foo;\nfoo = 1; // 常规模式，重新赋值无效\nfoo // undefined\n\n```\n\n`const`的作用与和`let`相同，都是在块级作用域之内有效，并且也不存在声明提升，会出现暂时性死区，只能在声明之后才能够调用。\n\n```js\n\nif (true) {\n  console.log(MAX); // ReferenceError\n  const MAX = 5;\n}\n\n```\n\n`const`声明的常量，也和`let`一样不可以重复声明。\n\n```js\n\nvar message = \"Hello!\";\nlet age = 25;\n\n// 以下两行都会报错\nconst message = \"Goodbye!\";\nconst age = 30;\n\n```\n\n对于复合型变量名，变量名不会指向数据，而是指向数据所在的地址。`const`命令可以使指向的地址不变，但是不能保证地址内的数据不变。比如，如果使用`const`声明了一个对象，其实是声明了一个指向对象的地址，这个地址是不可变的，但是可以为这个对象来添加新的属性。\n\n```js\n\nconst a = [];\na.push(\"Hello\"); // 可执行\na.length = 0;    // 可执行\na = [\"Dave\"];    // 报错\n\n```\n\n如上，变量`a`是一个数组，数组本身是可以改写的，但是如果将另一个数组赋值给`a`，就会报错。\n\n如果想让一个对象，不能添加新的属性，可以使用`Object.freeze`的方法。\n\n```js\n\nconst foo = Object.freeze({});\n\n// 常规模式时，下面一行不起作用；\n// 严格模式时，该行会报错\nfoo.prop = 123;\n\n```\n\n如上，添加新的属性不会起作用，在严格模式下还会报错。\n\nES5声明变量的方法有两个：`var`,`function`。ES6除了这两种方法外，还有`let`，`const`，`import`和`class`这四种方法。\n\n*******\n\n### 4. 跨模块常量\n\n`const`声明的常量只在当前代码块有效。如果想设置跨模块的常量，可以采用下面的写法。\n\n```js\n\nconst foo = Object.freeze({});\n\n// constants.js 模块\nexport const A = 1;\nexport const B = 3;\nexport const C = 4;\n\n// test1.js 模块\nimport * as constants from './constants';\nconsole.log(constants.A); // 1\nconsole.log(constants.B); // 3\n\n// test2.js 模块\nimport {A, B} from './constants';\nconsole.log(A); // 1\nconsole.log(B); // 3\n\n```\n\n******\n\n### 5. 全局对象的属性\n\nES6规定了，使用`var`和`function`声明的全局变量，依旧是全局对象的属性；使用`let`命令，`const`命令和`class`命令声明的全局变量，不属于全局对象的属性。\n\n```js\n\nvar a = 1;\n// 如果在Node的REPL环境，可以写成global.a\n// 或者采用通用方法，写成this.a\nwindow.a // 1\n\nlet b = 1;\nwindow.b // undefined\n\n```\n\n*******\n\n以上。\n","slug":"ES6study-1","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1y4000csq5lsa29tqov","content":"<p>笔记根据阮一峰老师的<a href=\"http://es6.ruanyifeng.com/#docs/let\" target=\"_blank\" rel=\"external\">ECMAScript 6 入门</a>，内容基本来自于此书，总结是为了理解学习和加深印象，把认为重要的部分记录下来。</p>\n<h3 id=\"1-let命令\"><a href=\"#1-let命令\" class=\"headerlink\" title=\"1. let命令\"></a>1. let命令</h3><hr>\n<h4 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h4><p>ES6中新增加了<code>let</code>用来声明变量,他和<code>var</code>的用法类似，但是let声明的变量只在let所在的代码块内有效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">  a <span class=\"comment\">// 10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a <span class=\"comment\">// ReferenceError: a is not defined.</span></span><br><span class=\"line\">b <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>如上面代码所示，如果在代码块外面调用了let的话，结果会报错。这表明let声明的变量只在他所在的代码块有效。</p>\n<p>所以<code>for</code>循环中，我们用let声明会很合适。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>( <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i)<span class=\"comment\">//ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码的计数器i,只在for循环内有效。</p>\n<p><br><br>下面的代码如果使用<code>var</code>，最终的输出结果是10。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  a[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n<p>因为<code>var</code>声明的<code>i</code>在全局作用域中都有效，当在循环当中时<code>a[6]</code>返回<code>function () {console.log(i);};</code>，当在<code>for</code>循环执行完毕后<code>i</code>的值会变成10。当执行<code>a[6]()</code>时结果为10。</p>\n<p><br></p>\n<p>如果使用<code>let</code>，声明的变量只在块级作用域内有效，代码如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  a[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n<p>如上面代码所示，因为<code>i</code>只在本轮循环内有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后结果为6。</p>\n<hr>\n<h4 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h4><p><code>let</code>不会像<code>var</code>存在变量提升的现象，所以<code>let</code>要在声明之后调用，否则会出现错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 报错ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>如上代码，在执行代码前，js会提前读取声明的<code>var</code>和<code>function</code>的变量名（变量值没有预先加载），所以在执行代码前，变量<code>foo</code>已经存在了会输出<code>undefined</code>，而变量<code>bar</code>不会发生变量提升，所以会抛出一个错误。</p>\n<hr>\n<h4 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h4><p>只要有块级作用域内存在<code>let</code>命令，他所声明的变量就绑定这个区域，不再受到外部影响。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"number\">123</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  tmp = <span class=\"string\">'abc'</span>; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，因为块级作用域内<code>let</code>声明了局部变量<code>tmp</code>，<code>tmp</code>就绑定到了这个块级作用域中，块级作用域外的<code>var</code>声明会失效，在块级作用域内在还没有<code>let</code>声明前就对<code>tmp</code>赋值的话就会报错。</p>\n<p>ES6中规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这两种声明的变量从一开始就形成了封闭的作用域，凡是在声明之前就使用这些变量的话就会报错。</p>\n<p>简单来说，在代码块内，如果使用<code>let</code>命令来声明变量，这个变量在声明之前都是不可用的。这个在语法上称为“暂时性死区”（temporal dead zone，简称TDZ）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TDZ开始</span></span><br><span class=\"line\">  tmp = <span class=\"string\">'abc'</span>; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp; <span class=\"comment\">// TDZ结束</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"number\">123</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码中，在<code>let</code>命令声明变量<code>tmp</code>前，都属于<code>tmp</code>的“死区”。</p>\n<p>“暂时性死区”也意味着<code>typeof</code>操作会出现错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> x; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x;</span><br></pre></td></tr></table></figure>\n<p>但是如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//undeclared_variable为为声明变量</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> undeclared_variable <span class=\"comment\">// \"undefined\"</span></span><br></pre></td></tr></table></figure></p>\n<p>所以，新语法在有了<code>let</code>声明之后，一定要声明完变量之后再去使用，否则有可能会报错。</p>\n<p><br></p>\n<p>还有一些特别的“死区”。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">x = y, y = 2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar(); <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码运行会报错，因为在把<code>y</code>的值赋给<code>x</code>前，<code>y</code>还没有声明，属于死区。</p>\n<p>总之，暂时性死区的本质就是，在已进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有在声明变量后才可以获取和使用该变量。</p>\n<hr>\n<h4 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h4><p><code>let</code>不允许在相同作用域中，重复声明同一个变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也不能在函数内部重新声明参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg; <span class=\"comment\">// 报错</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arg; <span class=\"comment\">// 不报错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"2-块级作用域\"><a href=\"#2-块级作用域\" class=\"headerlink\" title=\"2. 块级作用域\"></a>2. 块级作用域</h3><h4 id=\"为什么需要块级作用域？\"><a href=\"#为什么需要块级作用域？\" class=\"headerlink\" title=\"为什么需要块级作用域？\"></a>为什么需要块级作用域？</h4><p>在ES5中只有全局作用域和函数作用域，没有块级作用域，这会造成很多问题。</p>\n<p>计数的循环变量泄露为全局变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; s.length; i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"ES6的块级作用域\"><a href=\"#ES6的块级作用域\" class=\"headerlink\" title=\"ES6的块级作用域\"></a>ES6的块级作用域</h4><p><code>let</code>是为JavaScript新增了块级作用域。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = <span class=\"number\">10</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后输出的结果为5，这表示<code>let</code>声明的是一个块级作用域，外层的代码块不受内层的影响，如果使用<code>var</code>声明的话，最后输出结果为10。</p>\n<p>块级作用域出现后，立即执行匿名函数（IIFE）就不是唯一的选择了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IIFE写法</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tmp = ...;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 块级作用域写法</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp = ...;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"3-const命令\"><a href=\"#3-const命令\" class=\"headerlink\" title=\"3. const命令\"></a>3. const命令</h3><p>const也用来声明变量，这个变量是常量一旦声明，他的值是不可以改变的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"></span><br><span class=\"line\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> PI = <span class=\"number\">3.1415</span>;</span><br><span class=\"line\">PI <span class=\"comment\">// 3.1415</span></span><br><span class=\"line\"></span><br><span class=\"line\">PI = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// TypeError: \"PI\" is read-only</span></span><br></pre></td></tr></table></figure>\n<p>在严格模式下，改变声明的常量的值会报错。在常规模式下不会报错但也不起作用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> PI = <span class=\"number\">3.1415</span>;</span><br><span class=\"line\">PI = <span class=\"number\">3</span>; <span class=\"comment\">// 常规模式时，重新赋值无效，但不报错</span></span><br><span class=\"line\">PI <span class=\"comment\">// 3.1415</span></span><br></pre></td></tr></table></figure></p>\n<p>const声明的变量不可以改变值，所以一旦声明后必须立即初始化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"></span><br><span class=\"line\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> foo;</span><br><span class=\"line\"><span class=\"comment\">// SyntaxError: missing = in const declaration</span></span><br></pre></td></tr></table></figure>\n<p>如上面代码所示，在严格模式下，如果没有立即初始化，会报错。在常规模式下，不会报错，但是以后对<code>foo</code>赋值的话也是无效的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo;</span><br><span class=\"line\">foo = <span class=\"number\">1</span>; <span class=\"comment\">// 常规模式，重新赋值无效</span></span><br><span class=\"line\">foo <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p><code>const</code>的作用与和<code>let</code>相同，都是在块级作用域之内有效，并且也不存在声明提升，会出现暂时性死区，只能在声明之后才能够调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(MAX); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> MAX = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>const</code>声明的常量，也和<code>let</code>一样不可以重复声明。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">\"Hello!\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">25</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下两行都会报错</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">\"Goodbye!\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">30</span>;</span><br></pre></td></tr></table></figure>\n<p>对于复合型变量名，变量名不会指向数据，而是指向数据所在的地址。<code>const</code>命令可以使指向的地址不变，但是不能保证地址内的数据不变。比如，如果使用<code>const</code>声明了一个对象，其实是声明了一个指向对象的地址，这个地址是不可变的，但是可以为这个对象来添加新的属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\">a.push(<span class=\"string\">\"Hello\"</span>); <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a.length = <span class=\"number\">0</span>;    <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a = [<span class=\"string\">\"Dave\"</span>];    <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n<p>如上，变量<code>a</code>是一个数组，数组本身是可以改写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p>\n<p>如果想让一个对象，不能添加新的属性，可以使用<code>Object.freeze</code>的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">Object</span>.freeze(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 常规模式时，下面一行不起作用；</span></span><br><span class=\"line\"><span class=\"comment\">// 严格模式时，该行会报错</span></span><br><span class=\"line\">foo.prop = <span class=\"number\">123</span>;</span><br></pre></td></tr></table></figure>\n<p>如上，添加新的属性不会起作用，在严格模式下还会报错。</p>\n<p>ES5声明变量的方法有两个：<code>var</code>,<code>function</code>。ES6除了这两种方法外，还有<code>let</code>，<code>const</code>，<code>import</code>和<code>class</code>这四种方法。</p>\n<hr>\n<h3 id=\"4-跨模块常量\"><a href=\"#4-跨模块常量\" class=\"headerlink\" title=\"4. 跨模块常量\"></a>4. 跨模块常量</h3><p><code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量，可以采用下面的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">Object</span>.freeze(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// constants.js 模块</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> A = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> B = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> C = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test1.js 模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> constants <span class=\"keyword\">from</span> <span class=\"string\">'./constants'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(constants.A); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(constants.B); <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test2.js 模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;A, B&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./constants'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(A); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(B); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"5-全局对象的属性\"><a href=\"#5-全局对象的属性\" class=\"headerlink\" title=\"5. 全局对象的属性\"></a>5. 全局对象的属性</h3><p>ES6规定了，使用<code>var</code>和<code>function</code>声明的全局变量，依旧是全局对象的属性；使用<code>let</code>命令，<code>const</code>命令和<code>class</code>命令声明的全局变量，不属于全局对象的属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 如果在Node的REPL环境，可以写成global.a</span></span><br><span class=\"line\"><span class=\"comment\">// 或者采用通用方法，写成this.a</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.a <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.b <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p>以上。</p>\n","excerpt":"","more":"<p>笔记根据阮一峰老师的<a href=\"http://es6.ruanyifeng.com/#docs/let\">ECMAScript 6 入门</a>，内容基本来自于此书，总结是为了理解学习和加深印象，把认为重要的部分记录下来。</p>\n<h3 id=\"1-let命令\"><a href=\"#1-let命令\" class=\"headerlink\" title=\"1. let命令\"></a>1. let命令</h3><hr>\n<h4 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h4><p>ES6中新增加了<code>let</code>用来声明变量,他和<code>var</code>的用法类似，但是let声明的变量只在let所在的代码块内有效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">  a <span class=\"comment\">// 10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a <span class=\"comment\">// ReferenceError: a is not defined.</span></span><br><span class=\"line\">b <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>如上面代码所示，如果在代码块外面调用了let的话，结果会报错。这表明let声明的变量只在他所在的代码块有效。</p>\n<p>所以<code>for</code>循环中，我们用let声明会很合适。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>( <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i)<span class=\"comment\">//ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码的计数器i,只在for循环内有效。</p>\n<p><br><br>下面的代码如果使用<code>var</code>，最终的输出结果是10。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  a[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n<p>因为<code>var</code>声明的<code>i</code>在全局作用域中都有效，当在循环当中时<code>a[6]</code>返回<code>function () {console.log(i);};</code>，当在<code>for</code>循环执行完毕后<code>i</code>的值会变成10。当执行<code>a[6]()</code>时结果为10。</p>\n<p><br></p>\n<p>如果使用<code>let</code>，声明的变量只在块级作用域内有效，代码如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  a[i] = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n<p>如上面代码所示，因为<code>i</code>只在本轮循环内有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后结果为6。</p>\n<hr>\n<h4 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h4><p><code>let</code>不会像<code>var</code>存在变量提升的现象，所以<code>let</code>要在声明之后调用，否则会出现错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">// 输出undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">// 报错ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>如上代码，在执行代码前，js会提前读取声明的<code>var</code>和<code>function</code>的变量名（变量值没有预先加载），所以在执行代码前，变量<code>foo</code>已经存在了会输出<code>undefined</code>，而变量<code>bar</code>不会发生变量提升，所以会抛出一个错误。</p>\n<hr>\n<h4 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h4><p>只要有块级作用域内存在<code>let</code>命令，他所声明的变量就绑定这个区域，不再受到外部影响。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"number\">123</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  tmp = <span class=\"string\">'abc'</span>; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，因为块级作用域内<code>let</code>声明了局部变量<code>tmp</code>，<code>tmp</code>就绑定到了这个块级作用域中，块级作用域外的<code>var</code>声明会失效，在块级作用域内在还没有<code>let</code>声明前就对<code>tmp</code>赋值的话就会报错。</p>\n<p>ES6中规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这两种声明的变量从一开始就形成了封闭的作用域，凡是在声明之前就使用这些变量的话就会报错。</p>\n<p>简单来说，在代码块内，如果使用<code>let</code>命令来声明变量，这个变量在声明之前都是不可用的。这个在语法上称为“暂时性死区”（temporal dead zone，简称TDZ）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// TDZ开始</span></span><br><span class=\"line\">  tmp = <span class=\"string\">'abc'</span>; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp; <span class=\"comment\">// TDZ结束</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">  tmp = <span class=\"number\">123</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// 123</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码中，在<code>let</code>命令声明变量<code>tmp</code>前，都属于<code>tmp</code>的“死区”。</p>\n<p>“暂时性死区”也意味着<code>typeof</code>操作会出现错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> x; <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x;</span><br></pre></td></tr></table></figure>\n<p>但是如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//undeclared_variable为为声明变量</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> undeclared_variable <span class=\"comment\">// \"undefined\"</span></span><br></pre></td></tr></table></figure></p>\n<p>所以，新语法在有了<code>let</code>声明之后，一定要声明完变量之后再去使用，否则有可能会报错。</p>\n<p><br></p>\n<p>还有一些特别的“死区”。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">x = y, y = 2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar(); <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码运行会报错，因为在把<code>y</code>的值赋给<code>x</code>前，<code>y</code>还没有声明，属于死区。</p>\n<p>总之，暂时性死区的本质就是，在已进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有在声明变量后才可以获取和使用该变量。</p>\n<hr>\n<h4 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h4><p><code>let</code>不允许在相同作用域中，重复声明同一个变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也不能在函数内部重新声明参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg; <span class=\"comment\">// 报错</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">arg</span>) </span>&#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arg; <span class=\"comment\">// 不报错</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"2-块级作用域\"><a href=\"#2-块级作用域\" class=\"headerlink\" title=\"2. 块级作用域\"></a>2. 块级作用域</h3><h4 id=\"为什么需要块级作用域？\"><a href=\"#为什么需要块级作用域？\" class=\"headerlink\" title=\"为什么需要块级作用域？\"></a>为什么需要块级作用域？</h4><p>在ES5中只有全局作用域和函数作用域，没有块级作用域，这会造成很多问题。</p>\n<p>计数的循环变量泄露为全局变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; s.length; i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(s[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"ES6的块级作用域\"><a href=\"#ES6的块级作用域\" class=\"headerlink\" title=\"ES6的块级作用域\"></a>ES6的块级作用域</h4><p><code>let</code>是为JavaScript新增了块级作用域。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = <span class=\"number\">10</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后输出的结果为5，这表示<code>let</code>声明的是一个块级作用域，外层的代码块不受内层的影响，如果使用<code>var</code>声明的话，最后输出结果为10。</p>\n<p>块级作用域出现后，立即执行匿名函数（IIFE）就不是唯一的选择了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IIFE写法</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tmp = ...;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 块级作用域写法</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp = ...;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h3 id=\"3-const命令\"><a href=\"#3-const命令\" class=\"headerlink\" title=\"3. const命令\"></a>3. const命令</h3><p>const也用来声明变量，这个变量是常量一旦声明，他的值是不可以改变的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"></span><br><span class=\"line\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> PI = <span class=\"number\">3.1415</span>;</span><br><span class=\"line\">PI <span class=\"comment\">// 3.1415</span></span><br><span class=\"line\"></span><br><span class=\"line\">PI = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// TypeError: \"PI\" is read-only</span></span><br></pre></td></tr></table></figure>\n<p>在严格模式下，改变声明的常量的值会报错。在常规模式下不会报错但也不起作用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> PI = <span class=\"number\">3.1415</span>;</span><br><span class=\"line\">PI = <span class=\"number\">3</span>; <span class=\"comment\">// 常规模式时，重新赋值无效，但不报错</span></span><br><span class=\"line\">PI <span class=\"comment\">// 3.1415</span></span><br></pre></td></tr></table></figure></p>\n<p>const声明的变量不可以改变值，所以一旦声明后必须立即初始化。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"></span><br><span class=\"line\">'use strict'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> foo;</span><br><span class=\"line\"><span class=\"comment\">// SyntaxError: missing = in const declaration</span></span><br></pre></td></tr></table></figure>\n<p>如上面代码所示，在严格模式下，如果没有立即初始化，会报错。在常规模式下，不会报错，但是以后对<code>foo</code>赋值的话也是无效的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo;</span><br><span class=\"line\">foo = <span class=\"number\">1</span>; <span class=\"comment\">// 常规模式，重新赋值无效</span></span><br><span class=\"line\">foo <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p><code>const</code>的作用与和<code>let</code>相同，都是在块级作用域之内有效，并且也不存在声明提升，会出现暂时性死区，只能在声明之后才能够调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(MAX); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> MAX = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>const</code>声明的常量，也和<code>let</code>一样不可以重复声明。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">\"Hello!\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">25</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下两行都会报错</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">\"Goodbye!\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">30</span>;</span><br></pre></td></tr></table></figure>\n<p>对于复合型变量名，变量名不会指向数据，而是指向数据所在的地址。<code>const</code>命令可以使指向的地址不变，但是不能保证地址内的数据不变。比如，如果使用<code>const</code>声明了一个对象，其实是声明了一个指向对象的地址，这个地址是不可变的，但是可以为这个对象来添加新的属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\">a.push(<span class=\"string\">\"Hello\"</span>); <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a.length = <span class=\"number\">0</span>;    <span class=\"comment\">// 可执行</span></span><br><span class=\"line\">a = [<span class=\"string\">\"Dave\"</span>];    <span class=\"comment\">// 报错</span></span><br></pre></td></tr></table></figure>\n<p>如上，变量<code>a</code>是一个数组，数组本身是可以改写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p>\n<p>如果想让一个对象，不能添加新的属性，可以使用<code>Object.freeze</code>的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">Object</span>.freeze(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 常规模式时，下面一行不起作用；</span></span><br><span class=\"line\"><span class=\"comment\">// 严格模式时，该行会报错</span></span><br><span class=\"line\">foo.prop = <span class=\"number\">123</span>;</span><br></pre></td></tr></table></figure>\n<p>如上，添加新的属性不会起作用，在严格模式下还会报错。</p>\n<p>ES5声明变量的方法有两个：<code>var</code>,<code>function</code>。ES6除了这两种方法外，还有<code>let</code>，<code>const</code>，<code>import</code>和<code>class</code>这四种方法。</p>\n<hr>\n<h3 id=\"4-跨模块常量\"><a href=\"#4-跨模块常量\" class=\"headerlink\" title=\"4. 跨模块常量\"></a>4. 跨模块常量</h3><p><code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量，可以采用下面的写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"built_in\">Object</span>.freeze(&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// constants.js 模块</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> A = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> B = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> C = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test1.js 模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> constants <span class=\"keyword\">from</span> <span class=\"string\">'./constants'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(constants.A); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(constants.B); <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test2.js 模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;A, B&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./constants'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(A); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(B); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"5-全局对象的属性\"><a href=\"#5-全局对象的属性\" class=\"headerlink\" title=\"5. 全局对象的属性\"></a>5. 全局对象的属性</h3><p>ES6规定了，使用<code>var</code>和<code>function</code>声明的全局变量，依旧是全局对象的属性；使用<code>let</code>命令，<code>const</code>命令和<code>class</code>命令声明的全局变量，不属于全局对象的属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 如果在Node的REPL环境，可以写成global.a</span></span><br><span class=\"line\"><span class=\"comment\">// 或者采用通用方法，写成this.a</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.a <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.b <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<hr>\n<p>以上。</p>\n"},{"layout":"post","title":"好的博客及文章","date":"2016-01-24T16:00:00.000Z","_content":"\n\n这个可能会不定时的放一些看到的比较好的博客和文章。\n\n可能会更新，也可能会一直不更新 /抠鼻\n\nairbnb程序编写规范——[这里](https://github.com/vikingmute/javascript)\n","source":"_posts/2016-01-25-好的博客及文章.md","raw":"---\nlayout: post\ntitle: 好的博客及文章\ndate: 2016-01-25\ntags: [好的博客]\ncategories: 杂事二三\n---\n\n\n这个可能会不定时的放一些看到的比较好的博客和文章。\n\n可能会更新，也可能会一直不更新 /抠鼻\n\nairbnb程序编写规范——[这里](https://github.com/vikingmute/javascript)\n","slug":"好的博客及文章","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1y7000fsq5lffe8tiha","content":"<p>这个可能会不定时的放一些看到的比较好的博客和文章。</p>\n<p>可能会更新，也可能会一直不更新 /抠鼻</p>\n<p>airbnb程序编写规范——<a href=\"https://github.com/vikingmute/javascript\" target=\"_blank\" rel=\"external\">这里</a></p>\n","excerpt":"","more":"<p>这个可能会不定时的放一些看到的比较好的博客和文章。</p>\n<p>可能会更新，也可能会一直不更新 /抠鼻</p>\n<p>airbnb程序编写规范——<a href=\"https://github.com/vikingmute/javascript\">这里</a></p>\n"},{"layout":"post","title":"ES6学习笔记(变量的解构赋值)","date":"2016-01-24T16:00:00.000Z","_content":"\n解构赋值这块，主要讲了数组，对象，字符串，数值和布尔值，函数参数这五类的解构赋值。\n\n### 1. 结构赋值的用途\n\n首先，我们先不看具体的用法，来看看结构赋值会运用到哪些地方，先有一个大概的印象。\n\n#### 交换变量的值\n\n```js\n\n[x, y] = [y, x];\n\n```\n\n如上代码，这样写交换变量，简洁易懂，语义清晰。\n\n******\n\n#### 从函数返回多个值\n\n原来函数只能返回一个值，如果需要返回多个值需要把他们放到一个数组或者是对象里返回。有了解构赋值之后，一切就方便多了。\n\n```js\n\n// 返回一个数组\n\nfunction example() {\n  return [1, 2, 3];\n}\nvar [a, b, c] = example();\n\n// 返回一个对象\n\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2\n  };\n}\nvar { foo, bar } = example();\n\n```\n\n******\n\n#### 函数参数的定义\n\n```js\n\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3])\n\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1})\n\n```\n\n*******\n\n#### 提取JSON数据\n\n解构赋值对提取JSON对象中的数据，尤其有用。\n\n```js\n\nvar jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]\n}\n\nlet { id, status, data: number } = jsonData;\n\nconsole.log(id, status, number)\n// 42, OK, [867, 5309]\n\n```\n\n*****\n\n#### 函数参数的默认值\n\n```js\n\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function () {},\n  cache = true,\n  complete = function () {},\n  crossDomain = false,\n  global = true,\n  // ... more config\n}) {\n  // ... do stuff\n};\n\n```\n\n可以指定参数的默认值，避免了在函数体当中写`var foo = config.foo || 'default foo';`这样的语句。\n\n*****\n\n#### 遍历Map结构\n\n任何部署了Iterator接口的对象，都可以用`for...of`循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就很方便了。\n\n```js\n\nvar map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n// first is hello\n// second is world\n\n```\n\n如上，声明了两个变量`key`和`value`去接收了键值对。如果想只接收键名或者键值，可以运用如下写法。\n\n```js\n\n// 获取键名\nfor (let [key] of map) {\n  // ...\n}\n\n// 获取键值\nfor (let [,value] of map) {\n  // ...\n}\n\n```\n\n****\n\n#### 输入模块的制定方法\n\n加载模块时，往往需要制定输入哪些方法，解构赋值使得输入语句非常清晰。（我没懂。。。。）\n\n```js\n\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n\n```\n\n****\n\n### 2. 数组的解构赋值\n\n#### 基本用法\n\n按照一定的模式（格式），从数组和对象中取值来赋值给变量，这个过程被称为解构赋值。\n\n以前，为变量赋值，只能是以下的形式：\n\n```js\n\nvar a = 1;\nvar b = 2;\nvar c = 3;\n\n```\n\n而ES6允许以这种形式来赋值：\n\n```js\n\nvar [a, b, c] = [1, 2, 3];\n\n```\n\n如上代码，等号两边可以按照对应位置，去对变量赋值。\n\n这种写法属于“模式匹配”，只要等号两边的模式相同，右边的值就会赋给左边的变量中去。下面是一些解构的例子。\n\n```js\n\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = ['a'];\nx // \"a\"\ny // undefined\nz // []\n\n```\n\n如果解构不成功，变量的值就为`undefined`。\n\n```js\n\nvar [foo] = [];\nvar [bar, foo] = [1];\n\n```\n\n还有一种情况是不完全解构，等号左边的模式只可以匹配到一部分等号右边的数组，这种情况依然可以解构成功。\n\n如果等号的右边不是一个可以遍历的解构（[具体看这里](http://es6.ruanyifeng.com/#docs/iterator)），那么就会报错。\n\n```js\n\n// 报错\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n\n```\n\n上面的式子都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。\n\n解构赋值不仅适用于`var`命令，也适用于`let`和`const`命令。对于Set解构，也可以使用数组的解构赋值。\n\n```js\n\nlet [x, y, z] = new Set([\"a\", \"b\", \"c\"])\nx // \"a\"\n\n```\n\n*****\n\n#### 默认值\n\n解构赋值允许指定默认值。\n\n```js\n\nvar [foo = true] = [];\nfoo // true\n\n[x, y = 'b'] = ['a'] // x='a', y='b'\n[x, y = 'b'] = ['a', undefined] // x='a', y='b'\n\n```\n\n这里要注意的是，如果要使用默认的值，一定要严责等于`undefined`，否则默认值是不会生效的。\n\n```js\n\nvar [x = 1] = [undefined];\nx // 1\n\nvar [x = 1] = [null];\nx // null\n\n```\n\n如上代码，如果等号右边是`null`的话，默认值就不会生效，因为`null`不严格等于`undefiend`。\n\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n\n```js\n\nlet [x = 1, y = x] = [];     // x=1; y=1\nlet [x = 1, y = x] = [2];    // x=2; y=2\nlet [x = 1, y = x] = [1, 2]; // x=1; y=2\nlet [x = y, y = 1] = [];     // ReferenceError\n\n```\n\n如果代码，最后一个表达式报错是因为在`x`用到`y`时，`y`还没有声明。\n\n******\n\n### 3. 对象的解构赋值\n\n解构不仅可以用于数组，还可以用于对象。\n\n```js\n\nvar { foo, bar } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n\n```\n\n对象的解构和数组不同的是，数组的解构是有顺序限制的，变量的取值是由他的位置决定的，而对象的属性没有次序，变量必须与属性同名才能取到正确的值。\n\n```js\n\nvar { bar, foo } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n\nvar { baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // undefined\n\n```\n\n如上代码，等号左边两个变量的次序与等号右边两个属性的次序不一致，但是取值正确，如果变量没有对应的同名属性的话会取不到值。\n\n如果变量名和属性名不一致，我们必须引用一个叫`模式`的东西，我可能理解的比较通俗，先看以下的代码，在做解释。\n\n```js\n\nvar { foo: baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // \"aaa\"\n\nlet obj = { first: 'hello', last: 'world' };\nlet { first: f, last: l } = obj;\nf // 'hello'\nl // 'world'\n\n```\n\n对象的赋值解构的内部机制其实是这样的：\n\n```js\n\nvar { foo: foo, bar: bar } = { foo: \"aaa\", bar: \"bbb\" };\n\n```\n\n`:`之前的部分我们叫做`模式`，`:`之后的部分才是`变量`，在解构赋值内部机制是先根据模式找到同名的属性，再给对应的变量赋值，真正被赋值的是`：`后面的变量。\n\n在平时对象解构赋值的时候我们把`:`之后的变量给省略掉了，这样在内部他会加上一个和模式名字相同的变量名，在省略了变量名的情况下，我们打印模式名是不会出错的。\n\n但如果`变量`名和`模式`名是不一样的时候，比如下面这种情况：\n\n```js\n\nvar { foo: baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // \"aaa\"\nfoo // error: foo is not defined\n\n```\n\n如上这样，真正被赋值的就是变量`baz`，而不是模式`foo`。\n\n和数组一样，解构也可以用于嵌套解构的对象。\n\n```js\n\nvar node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }\n};\n\nvar { loc: { start: { line }} } = node;\nline // 1\nloc  // error: loc is undefined\nstart // error: start is undefined\n\n```\n\n如上，只有`line`是变量，`loc`和`start`都是模式，不会被赋值。\n\n嵌套赋值的例子：\n\n```js\n\nlet obj = {};\nlet arr = [];\n\n({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });\n\nobj // {prop:123}\narr // [true]\n\n```\n\n对象的解构也可以指定默认的值。\n\n```js\n\nvar {x = 3} = {};\nx // 3\n\nvar {x, y = 5} = {x: 1};\nx // 1\ny // 5\n\nvar { message: msg = \"Something went wrong\" } = {};\nmsg // \"Something went wrong\"\n\n```\n\n默认值生效的条件，也是对象的属性值严格等于`undefined`。如果不是严格等于`undefined`默认值就不会生效。\n\n```js\n\nvar {x = 3} = {x: undefined};\nx // 3\n\nvar {x = 3} = {x: null};\nx // null\n\n```\n\n如果解构失败的话。变量的值也会等于`undefined`。\n\n```js\n\nvar {foo} = {bar: 'baz'}\nfoo // undefined\n\n```\n\n如果，解构的模式是一个对象的话，而模式名却在等号的右边不存在的话，那么将会报错。因为在解构的时候，首先会寻找与模式同名的属性，如果没有这个属性名就会报错。\n\n```js\n\n// 报错\nvar {foo: {bar}} = {baz: 'baz'}\n\n```\n\n### 4. 字符串的解构赋值\n\n字符串解构赋值是，会转换为一个类似数组的对象。\n\n```js\n\nconst [a, b, c, d, e] = 'hello';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n\n```\n\n### 5. 数值和布尔值的解构赋值\n\n解构赋值时，如果等号右边是数值和布尔值，会先转为对象。\n\n```js\n\nlet {toString: s} = 123;\ns === Number.prototype.toString // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n\n```\n\n解构赋值的规则是，只要等号右边的值不是对象，就先将其转化为对象，但是由于`undefined`和`null`不能转为对象，所以对他们进行解构赋值都会报错。\n\n\n### 6. 函数参数的解构赋值\n\n```js\n\nfunction add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]) // 3\n\n```\n\n如上代码，函数`add`的参数实际上不是一个数组，而是通过结构得刀的变量`x`和`y`。\n\n函数参数的解构也可以使用默认值。\n\n```js\n\nfunction move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n\n```\n\n以上还有很多细节方面没有描述，只是在常用方面做出了总结，详细的[请看](http://es6.ruanyifeng.com/#docs/destructuring)\n\n\n","source":"_posts/2016-01-25-ES6study-2.md","raw":"---\nlayout: post\ntitle: ES6学习笔记(变量的解构赋值)\ndate: 2016-01-25\ntags: [ES6]\ncategories: ES6\n---\n\n解构赋值这块，主要讲了数组，对象，字符串，数值和布尔值，函数参数这五类的解构赋值。\n\n### 1. 结构赋值的用途\n\n首先，我们先不看具体的用法，来看看结构赋值会运用到哪些地方，先有一个大概的印象。\n\n#### 交换变量的值\n\n```js\n\n[x, y] = [y, x];\n\n```\n\n如上代码，这样写交换变量，简洁易懂，语义清晰。\n\n******\n\n#### 从函数返回多个值\n\n原来函数只能返回一个值，如果需要返回多个值需要把他们放到一个数组或者是对象里返回。有了解构赋值之后，一切就方便多了。\n\n```js\n\n// 返回一个数组\n\nfunction example() {\n  return [1, 2, 3];\n}\nvar [a, b, c] = example();\n\n// 返回一个对象\n\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2\n  };\n}\nvar { foo, bar } = example();\n\n```\n\n******\n\n#### 函数参数的定义\n\n```js\n\n// 参数是一组有次序的值\nfunction f([x, y, z]) { ... }\nf([1, 2, 3])\n\n// 参数是一组无次序的值\nfunction f({x, y, z}) { ... }\nf({z: 3, y: 2, x: 1})\n\n```\n\n*******\n\n#### 提取JSON数据\n\n解构赋值对提取JSON对象中的数据，尤其有用。\n\n```js\n\nvar jsonData = {\n  id: 42,\n  status: \"OK\",\n  data: [867, 5309]\n}\n\nlet { id, status, data: number } = jsonData;\n\nconsole.log(id, status, number)\n// 42, OK, [867, 5309]\n\n```\n\n*****\n\n#### 函数参数的默认值\n\n```js\n\njQuery.ajax = function (url, {\n  async = true,\n  beforeSend = function () {},\n  cache = true,\n  complete = function () {},\n  crossDomain = false,\n  global = true,\n  // ... more config\n}) {\n  // ... do stuff\n};\n\n```\n\n可以指定参数的默认值，避免了在函数体当中写`var foo = config.foo || 'default foo';`这样的语句。\n\n*****\n\n#### 遍历Map结构\n\n任何部署了Iterator接口的对象，都可以用`for...of`循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就很方便了。\n\n```js\n\nvar map = new Map();\nmap.set('first', 'hello');\nmap.set('second', 'world');\n\nfor (let [key, value] of map) {\n  console.log(key + \" is \" + value);\n}\n// first is hello\n// second is world\n\n```\n\n如上，声明了两个变量`key`和`value`去接收了键值对。如果想只接收键名或者键值，可以运用如下写法。\n\n```js\n\n// 获取键名\nfor (let [key] of map) {\n  // ...\n}\n\n// 获取键值\nfor (let [,value] of map) {\n  // ...\n}\n\n```\n\n****\n\n#### 输入模块的制定方法\n\n加载模块时，往往需要制定输入哪些方法，解构赋值使得输入语句非常清晰。（我没懂。。。。）\n\n```js\n\nconst { SourceMapConsumer, SourceNode } = require(\"source-map\");\n\n```\n\n****\n\n### 2. 数组的解构赋值\n\n#### 基本用法\n\n按照一定的模式（格式），从数组和对象中取值来赋值给变量，这个过程被称为解构赋值。\n\n以前，为变量赋值，只能是以下的形式：\n\n```js\n\nvar a = 1;\nvar b = 2;\nvar c = 3;\n\n```\n\n而ES6允许以这种形式来赋值：\n\n```js\n\nvar [a, b, c] = [1, 2, 3];\n\n```\n\n如上代码，等号两边可以按照对应位置，去对变量赋值。\n\n这种写法属于“模式匹配”，只要等号两边的模式相同，右边的值就会赋给左边的变量中去。下面是一些解构的例子。\n\n```js\n\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = ['a'];\nx // \"a\"\ny // undefined\nz // []\n\n```\n\n如果解构不成功，变量的值就为`undefined`。\n\n```js\n\nvar [foo] = [];\nvar [bar, foo] = [1];\n\n```\n\n还有一种情况是不完全解构，等号左边的模式只可以匹配到一部分等号右边的数组，这种情况依然可以解构成功。\n\n如果等号的右边不是一个可以遍历的解构（[具体看这里](http://es6.ruanyifeng.com/#docs/iterator)），那么就会报错。\n\n```js\n\n// 报错\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n\n```\n\n上面的式子都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。\n\n解构赋值不仅适用于`var`命令，也适用于`let`和`const`命令。对于Set解构，也可以使用数组的解构赋值。\n\n```js\n\nlet [x, y, z] = new Set([\"a\", \"b\", \"c\"])\nx // \"a\"\n\n```\n\n*****\n\n#### 默认值\n\n解构赋值允许指定默认值。\n\n```js\n\nvar [foo = true] = [];\nfoo // true\n\n[x, y = 'b'] = ['a'] // x='a', y='b'\n[x, y = 'b'] = ['a', undefined] // x='a', y='b'\n\n```\n\n这里要注意的是，如果要使用默认的值，一定要严责等于`undefined`，否则默认值是不会生效的。\n\n```js\n\nvar [x = 1] = [undefined];\nx // 1\n\nvar [x = 1] = [null];\nx // null\n\n```\n\n如上代码，如果等号右边是`null`的话，默认值就不会生效，因为`null`不严格等于`undefiend`。\n\n默认值可以引用解构赋值的其他变量，但该变量必须已经声明。\n\n```js\n\nlet [x = 1, y = x] = [];     // x=1; y=1\nlet [x = 1, y = x] = [2];    // x=2; y=2\nlet [x = 1, y = x] = [1, 2]; // x=1; y=2\nlet [x = y, y = 1] = [];     // ReferenceError\n\n```\n\n如果代码，最后一个表达式报错是因为在`x`用到`y`时，`y`还没有声明。\n\n******\n\n### 3. 对象的解构赋值\n\n解构不仅可以用于数组，还可以用于对象。\n\n```js\n\nvar { foo, bar } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n\n```\n\n对象的解构和数组不同的是，数组的解构是有顺序限制的，变量的取值是由他的位置决定的，而对象的属性没有次序，变量必须与属性同名才能取到正确的值。\n\n```js\n\nvar { bar, foo } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n\nvar { baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // undefined\n\n```\n\n如上代码，等号左边两个变量的次序与等号右边两个属性的次序不一致，但是取值正确，如果变量没有对应的同名属性的话会取不到值。\n\n如果变量名和属性名不一致，我们必须引用一个叫`模式`的东西，我可能理解的比较通俗，先看以下的代码，在做解释。\n\n```js\n\nvar { foo: baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // \"aaa\"\n\nlet obj = { first: 'hello', last: 'world' };\nlet { first: f, last: l } = obj;\nf // 'hello'\nl // 'world'\n\n```\n\n对象的赋值解构的内部机制其实是这样的：\n\n```js\n\nvar { foo: foo, bar: bar } = { foo: \"aaa\", bar: \"bbb\" };\n\n```\n\n`:`之前的部分我们叫做`模式`，`:`之后的部分才是`变量`，在解构赋值内部机制是先根据模式找到同名的属性，再给对应的变量赋值，真正被赋值的是`：`后面的变量。\n\n在平时对象解构赋值的时候我们把`:`之后的变量给省略掉了，这样在内部他会加上一个和模式名字相同的变量名，在省略了变量名的情况下，我们打印模式名是不会出错的。\n\n但如果`变量`名和`模式`名是不一样的时候，比如下面这种情况：\n\n```js\n\nvar { foo: baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // \"aaa\"\nfoo // error: foo is not defined\n\n```\n\n如上这样，真正被赋值的就是变量`baz`，而不是模式`foo`。\n\n和数组一样，解构也可以用于嵌套解构的对象。\n\n```js\n\nvar node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }\n};\n\nvar { loc: { start: { line }} } = node;\nline // 1\nloc  // error: loc is undefined\nstart // error: start is undefined\n\n```\n\n如上，只有`line`是变量，`loc`和`start`都是模式，不会被赋值。\n\n嵌套赋值的例子：\n\n```js\n\nlet obj = {};\nlet arr = [];\n\n({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });\n\nobj // {prop:123}\narr // [true]\n\n```\n\n对象的解构也可以指定默认的值。\n\n```js\n\nvar {x = 3} = {};\nx // 3\n\nvar {x, y = 5} = {x: 1};\nx // 1\ny // 5\n\nvar { message: msg = \"Something went wrong\" } = {};\nmsg // \"Something went wrong\"\n\n```\n\n默认值生效的条件，也是对象的属性值严格等于`undefined`。如果不是严格等于`undefined`默认值就不会生效。\n\n```js\n\nvar {x = 3} = {x: undefined};\nx // 3\n\nvar {x = 3} = {x: null};\nx // null\n\n```\n\n如果解构失败的话。变量的值也会等于`undefined`。\n\n```js\n\nvar {foo} = {bar: 'baz'}\nfoo // undefined\n\n```\n\n如果，解构的模式是一个对象的话，而模式名却在等号的右边不存在的话，那么将会报错。因为在解构的时候，首先会寻找与模式同名的属性，如果没有这个属性名就会报错。\n\n```js\n\n// 报错\nvar {foo: {bar}} = {baz: 'baz'}\n\n```\n\n### 4. 字符串的解构赋值\n\n字符串解构赋值是，会转换为一个类似数组的对象。\n\n```js\n\nconst [a, b, c, d, e] = 'hello';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n\n```\n\n### 5. 数值和布尔值的解构赋值\n\n解构赋值时，如果等号右边是数值和布尔值，会先转为对象。\n\n```js\n\nlet {toString: s} = 123;\ns === Number.prototype.toString // true\n\nlet {toString: s} = true;\ns === Boolean.prototype.toString // true\n\n```\n\n解构赋值的规则是，只要等号右边的值不是对象，就先将其转化为对象，但是由于`undefined`和`null`不能转为对象，所以对他们进行解构赋值都会报错。\n\n\n### 6. 函数参数的解构赋值\n\n```js\n\nfunction add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]) // 3\n\n```\n\n如上代码，函数`add`的参数实际上不是一个数组，而是通过结构得刀的变量`x`和`y`。\n\n函数参数的解构也可以使用默认值。\n\n```js\n\nfunction move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n\n```\n\n以上还有很多细节方面没有描述，只是在常用方面做出了总结，详细的[请看](http://es6.ruanyifeng.com/#docs/destructuring)\n\n\n","slug":"ES6study-2","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1y8000isq5l10y2cg5n","content":"<p>解构赋值这块，主要讲了数组，对象，字符串，数值和布尔值，函数参数这五类的解构赋值。</p>\n<h3 id=\"1-结构赋值的用途\"><a href=\"#1-结构赋值的用途\" class=\"headerlink\" title=\"1. 结构赋值的用途\"></a>1. 结构赋值的用途</h3><p>首先，我们先不看具体的用法，来看看结构赋值会运用到哪些地方，先有一个大概的印象。</p>\n<h4 id=\"交换变量的值\"><a href=\"#交换变量的值\" class=\"headerlink\" title=\"交换变量的值\"></a>交换变量的值</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>\n<p>如上代码，这样写交换变量，简洁易懂，语义清晰。</p>\n<hr>\n<h4 id=\"从函数返回多个值\"><a href=\"#从函数返回多个值\" class=\"headerlink\" title=\"从函数返回多个值\"></a>从函数返回多个值</h4><p>原来函数只能返回一个值，如果需要返回多个值需要把他们放到一个数组或者是对象里返回。有了解构赋值之后，一切就方便多了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回一个数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> [a, b, c] = example();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回一个对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">    bar: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"函数参数的定义\"><a href=\"#函数参数的定义\" class=\"headerlink\" title=\"函数参数的定义\"></a>函数参数的定义</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数是一组有次序的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class=\"line\">f([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数是一组无次序的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class=\"line\">f(&#123;z: <span class=\"number\">3</span>, y: <span class=\"number\">2</span>, x: <span class=\"number\">1</span>&#125;)</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"提取JSON数据\"><a href=\"#提取JSON数据\" class=\"headerlink\" title=\"提取JSON数据\"></a>提取JSON数据</h4><p>解构赋值对提取JSON对象中的数据，尤其有用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> jsonData = &#123;</span><br><span class=\"line\">  id: <span class=\"number\">42</span>,</span><br><span class=\"line\">  status: <span class=\"string\">\"OK\"</span>,</span><br><span class=\"line\">  data: [<span class=\"number\">867</span>, <span class=\"number\">5309</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; id, status, data: number &#125; = jsonData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(id, status, number)</span><br><span class=\"line\"><span class=\"comment\">// 42, OK, [867, 5309]</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">jQuery.ajax = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">url, &#123;</span><br><span class=\"line\">  async = true,</span><br><span class=\"line\">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class=\"line\">  cache = <span class=\"literal\">true</span>,</span><br><span class=\"line\">  complete = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  crossDomain = <span class=\"literal\">false</span>,</span><br><span class=\"line\">  global = <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"comment\">// ... more config</span></span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... do stuff</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以指定参数的默认值，避免了在函数体当中写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>\n<hr>\n<h4 id=\"遍历Map结构\"><a href=\"#遍历Map结构\" class=\"headerlink\" title=\"遍历Map结构\"></a>遍历Map结构</h4><p>任何部署了Iterator接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就很方便了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">'first'</span>, <span class=\"string\">'hello'</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">'second'</span>, <span class=\"string\">'world'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key + <span class=\"string\">\" is \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// first is hello</span></span><br><span class=\"line\"><span class=\"comment\">// second is world</span></span><br></pre></td></tr></table></figure>\n<p>如上，声明了两个变量<code>key</code>和<code>value</code>去接收了键值对。如果想只接收键名或者键值，可以运用如下写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取键名</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取键值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [,value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"输入模块的制定方法\"><a href=\"#输入模块的制定方法\" class=\"headerlink\" title=\"输入模块的制定方法\"></a>输入模块的制定方法</h4><p>加载模块时，往往需要制定输入哪些方法，解构赋值使得输入语句非常清晰。（我没懂。。。。）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">\"source-map\"</span>);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"2-数组的解构赋值\"><a href=\"#2-数组的解构赋值\" class=\"headerlink\" title=\"2. 数组的解构赋值\"></a>2. 数组的解构赋值</h3><h4 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h4><p>按照一定的模式（格式），从数组和对象中取值来赋值给变量，这个过程被称为解构赋值。</p>\n<p>以前，为变量赋值，只能是以下的形式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<p>而ES6允许以这种形式来赋值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [a, b, c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<p>如上代码，等号两边可以按照对应位置，去对变量赋值。</p>\n<p>这种写法属于“模式匹配”，只要等号两边的模式相同，右边的值就会赋给左边的变量中去。下面是一些解构的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo, [[bar], baz]] = [<span class=\"number\">1</span>, [[<span class=\"number\">2</span>], <span class=\"number\">3</span>]];</span><br><span class=\"line\">foo <span class=\"comment\">// 1</span></span><br><span class=\"line\">bar <span class=\"comment\">// 2</span></span><br><span class=\"line\">baz <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [ , , third] = [<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"bar\"</span>, <span class=\"string\">\"baz\"</span>];</span><br><span class=\"line\">third <span class=\"comment\">// \"baz\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, , y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">x <span class=\"comment\">// 1</span></span><br><span class=\"line\">y <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [head, ...tail] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">head <span class=\"comment\">// 1</span></span><br><span class=\"line\">tail <span class=\"comment\">// [2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y, ...z] = [<span class=\"string\">'a'</span>];</span><br><span class=\"line\">x <span class=\"comment\">// \"a\"</span></span><br><span class=\"line\">y <span class=\"comment\">// undefined</span></span><br><span class=\"line\">z <span class=\"comment\">// []</span></span><br></pre></td></tr></table></figure>\n<p>如果解构不成功，变量的值就为<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [foo] = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> [bar, foo] = [<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<p>还有一种情况是不完全解构，等号左边的模式只可以匹配到一部分等号右边的数组，这种情况依然可以解构成功。</p>\n<p>如果等号的右边不是一个可以遍历的解构（<a href=\"http://es6.ruanyifeng.com/#docs/iterator\" target=\"_blank\" rel=\"external\">具体看这里</a>），那么就会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">NaN</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面的式子都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。</p>\n<p>解构赋值不仅适用于<code>var</code>命令，也适用于<code>let</code>和<code>const</code>命令。对于Set解构，也可以使用数组的解构赋值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y, z] = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>])</span><br><span class=\"line\">x <span class=\"comment\">// \"a\"</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h4><p>解构赋值允许指定默认值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [foo = <span class=\"literal\">true</span>] = [];</span><br><span class=\"line\">foo <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">[x, y = <span class=\"string\">'b'</span>] = [<span class=\"string\">'a'</span>] <span class=\"comment\">// x='a', y='b'</span></span><br><span class=\"line\">[x, y = <span class=\"string\">'b'</span>] = [<span class=\"string\">'a'</span>, <span class=\"literal\">undefined</span>] <span class=\"comment\">// x='a', y='b'</span></span><br></pre></td></tr></table></figure>\n<p>这里要注意的是，如果要使用默认的值，一定要严责等于<code>undefined</code>，否则默认值是不会生效的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [x = <span class=\"number\">1</span>] = [<span class=\"literal\">undefined</span>];</span><br><span class=\"line\">x <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [x = <span class=\"number\">1</span>] = [<span class=\"literal\">null</span>];</span><br><span class=\"line\">x <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，如果等号右边是<code>null</code>的话，默认值就不会生效，因为<code>null</code>不严格等于<code>undefiend</code>。</p>\n<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>, y = x] = [];     <span class=\"comment\">// x=1; y=1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>, y = x] = [<span class=\"number\">2</span>];    <span class=\"comment\">// x=2; y=2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>, y = x] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]; <span class=\"comment\">// x=1; y=2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x = y, y = <span class=\"number\">1</span>] = [];     <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n<p>如果代码，最后一个表达式报错是因为在<code>x</code>用到<code>y</code>时，<code>y</code>还没有声明。</p>\n<hr>\n<h3 id=\"3-对象的解构赋值\"><a href=\"#3-对象的解构赋值\" class=\"headerlink\" title=\"3. 对象的解构赋值\"></a>3. 对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo, bar &#125; = &#123; foo: <span class=\"string\">\"aaa\"</span>, bar: <span class=\"string\">\"bbb\"</span> &#125;;</span><br><span class=\"line\">foo <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\">bar <span class=\"comment\">// \"bbb\"</span></span><br></pre></td></tr></table></figure>\n<p>对象的解构和数组不同的是，数组的解构是有顺序限制的，变量的取值是由他的位置决定的，而对象的属性没有次序，变量必须与属性同名才能取到正确的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; bar, foo &#125; = &#123; foo: <span class=\"string\">\"aaa\"</span>, bar: <span class=\"string\">\"bbb\"</span> &#125;;</span><br><span class=\"line\">foo <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\">bar <span class=\"comment\">// \"bbb\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; baz &#125; = &#123; foo: <span class=\"string\">\"aaa\"</span>, bar: <span class=\"string\">\"bbb\"</span> &#125;;</span><br><span class=\"line\">baz <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，等号左边两个变量的次序与等号右边两个属性的次序不一致，但是取值正确，如果变量没有对应的同名属性的话会取不到值。</p>\n<p>如果变量名和属性名不一致，我们必须引用一个叫<code>模式</code>的东西，我可能理解的比较通俗，先看以下的代码，在做解释。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo: baz &#125; = &#123; foo: <span class=\"string\">\"aaa\"</span>, bar: <span class=\"string\">\"bbb\"</span> &#125;;</span><br><span class=\"line\">baz <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; first: <span class=\"string\">'hello'</span>, last: <span class=\"string\">'world'</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; first: f, last: l &#125; = obj;</span><br><span class=\"line\">f <span class=\"comment\">// 'hello'</span></span><br><span class=\"line\">l <span class=\"comment\">// 'world'</span></span><br></pre></td></tr></table></figure>\n<p>对象的赋值解构的内部机制其实是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo: foo, bar: bar &#125; = &#123; foo: <span class=\"string\">\"aaa\"</span>, bar: <span class=\"string\">\"bbb\"</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p><code>:</code>之前的部分我们叫做<code>模式</code>，<code>:</code>之后的部分才是<code>变量</code>，在解构赋值内部机制是先根据模式找到同名的属性，再给对应的变量赋值，真正被赋值的是<code>：</code>后面的变量。</p>\n<p>在平时对象解构赋值的时候我们把<code>:</code>之后的变量给省略掉了，这样在内部他会加上一个和模式名字相同的变量名，在省略了变量名的情况下，我们打印模式名是不会出错的。</p>\n<p>但如果<code>变量</code>名和<code>模式</code>名是不一样的时候，比如下面这种情况：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo: baz &#125; = &#123; foo: <span class=\"string\">\"aaa\"</span>, bar: <span class=\"string\">\"bbb\"</span> &#125;;</span><br><span class=\"line\">baz <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\">foo <span class=\"comment\">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>\n<p>如上这样，真正被赋值的就是变量<code>baz</code>，而不是模式<code>foo</code>。</p>\n<p>和数组一样，解构也可以用于嵌套解构的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> node = &#123;</span><br><span class=\"line\">  loc: &#123;</span><br><span class=\"line\">    start: &#123;</span><br><span class=\"line\">      line: <span class=\"number\">1</span>,</span><br><span class=\"line\">      column: <span class=\"number\">5</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;</span><br><span class=\"line\">line <span class=\"comment\">// 1</span></span><br><span class=\"line\">loc  <span class=\"comment\">// error: loc is undefined</span></span><br><span class=\"line\">start <span class=\"comment\">// error: start is undefined</span></span><br></pre></td></tr></table></figure>\n<p>如上，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不会被赋值。</p>\n<p>嵌套赋值的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\"></span><br><span class=\"line\">(&#123; foo: obj.prop, bar: arr[<span class=\"number\">0</span>] &#125; = &#123; foo: <span class=\"number\">123</span>, bar: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj <span class=\"comment\">// &#123;prop:123&#125;</span></span><br><span class=\"line\">arr <span class=\"comment\">// [true]</span></span><br></pre></td></tr></table></figure>\n<p>对象的解构也可以指定默认的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;&#125;;</span><br><span class=\"line\">x <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;x, y = <span class=\"number\">5</span>&#125; = &#123;x: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">x <span class=\"comment\">// 1</span></span><br><span class=\"line\">y <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; message: msg = <span class=\"string\">\"Something went wrong\"</span> &#125; = &#123;&#125;;</span><br><span class=\"line\">msg <span class=\"comment\">// \"Something went wrong\"</span></span><br></pre></td></tr></table></figure>\n<p>默认值生效的条件，也是对象的属性值严格等于<code>undefined</code>。如果不是严格等于<code>undefined</code>默认值就不会生效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;x: <span class=\"literal\">undefined</span>&#125;;</span><br><span class=\"line\">x <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;x: <span class=\"literal\">null</span>&#125;;</span><br><span class=\"line\">x <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>如果解构失败的话。变量的值也会等于<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;foo&#125; = &#123;bar: <span class=\"string\">'baz'</span>&#125;</span><br><span class=\"line\">foo <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>如果，解构的模式是一个对象的话，而模式名却在等号的右边不存在的话，那么将会报错。因为在解构的时候，首先会寻找与模式同名的属性，如果没有这个属性名就会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;foo: &#123;bar&#125;&#125; = &#123;baz: <span class=\"string\">'baz'</span>&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-字符串的解构赋值\"><a href=\"#4-字符串的解构赋值\" class=\"headerlink\" title=\"4. 字符串的解构赋值\"></a>4. 字符串的解构赋值</h3><p>字符串解构赋值是，会转换为一个类似数组的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d, e] = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">a <span class=\"comment\">// \"h\"</span></span><br><span class=\"line\">b <span class=\"comment\">// \"e\"</span></span><br><span class=\"line\">c <span class=\"comment\">// \"l\"</span></span><br><span class=\"line\">d <span class=\"comment\">// \"l\"</span></span><br><span class=\"line\">e <span class=\"comment\">// \"o\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-数值和布尔值的解构赋值\"><a href=\"#5-数值和布尔值的解构赋值\" class=\"headerlink\" title=\"5. 数值和布尔值的解构赋值\"></a>5. 数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，会先转为对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;toString: s&#125; = <span class=\"number\">123</span>;</span><br><span class=\"line\">s === <span class=\"built_in\">Number</span>.prototype.toString <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;toString: s&#125; = <span class=\"literal\">true</span>;</span><br><span class=\"line\">s === <span class=\"built_in\">Boolean</span>.prototype.toString <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>解构赋值的规则是，只要等号右边的值不是对象，就先将其转化为对象，但是由于<code>undefined</code>和<code>null</code>不能转为对象，所以对他们进行解构赋值都会报错。</p>\n<h3 id=\"6-函数参数的解构赋值\"><a href=\"#6-函数参数的解构赋值\" class=\"headerlink\" title=\"6. 函数参数的解构赋值\"></a>6. 函数参数的解构赋值</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">[x, y]</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add([<span class=\"number\">1</span>, <span class=\"number\">2</span>]) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，函数<code>add</code>的参数实际上不是一个数组，而是通过结构得刀的变量<code>x</code>和<code>y</code>。</p>\n<p>函数参数的解构也可以使用默认值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span>(<span class=\"params\">&#123;x = 0, y = 0&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">move(&#123;x: <span class=\"number\">3</span>, y: <span class=\"number\">8</span>&#125;); <span class=\"comment\">// [3, 8]</span></span><br><span class=\"line\">move(&#123;x: <span class=\"number\">3</span>&#125;); <span class=\"comment\">// [3, 0]</span></span><br><span class=\"line\">move(&#123;&#125;); <span class=\"comment\">// [0, 0]</span></span><br><span class=\"line\">move(); <span class=\"comment\">// [0, 0]</span></span><br></pre></td></tr></table></figure>\n<p>以上还有很多细节方面没有描述，只是在常用方面做出了总结，详细的<a href=\"http://es6.ruanyifeng.com/#docs/destructuring\" target=\"_blank\" rel=\"external\">请看</a></p>\n","excerpt":"","more":"<p>解构赋值这块，主要讲了数组，对象，字符串，数值和布尔值，函数参数这五类的解构赋值。</p>\n<h3 id=\"1-结构赋值的用途\"><a href=\"#1-结构赋值的用途\" class=\"headerlink\" title=\"1. 结构赋值的用途\"></a>1. 结构赋值的用途</h3><p>首先，我们先不看具体的用法，来看看结构赋值会运用到哪些地方，先有一个大概的印象。</p>\n<h4 id=\"交换变量的值\"><a href=\"#交换变量的值\" class=\"headerlink\" title=\"交换变量的值\"></a>交换变量的值</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>\n<p>如上代码，这样写交换变量，简洁易懂，语义清晰。</p>\n<hr>\n<h4 id=\"从函数返回多个值\"><a href=\"#从函数返回多个值\" class=\"headerlink\" title=\"从函数返回多个值\"></a>从函数返回多个值</h4><p>原来函数只能返回一个值，如果需要返回多个值需要把他们放到一个数组或者是对象里返回。有了解构赋值之后，一切就方便多了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回一个数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> [a, b, c] = example();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回一个对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    foo: <span class=\"number\">1</span>,</span><br><span class=\"line\">    bar: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"函数参数的定义\"><a href=\"#函数参数的定义\" class=\"headerlink\" title=\"函数参数的定义\"></a>函数参数的定义</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数是一组有次序的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class=\"line\">f([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数是一组无次序的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class=\"line\">f(&#123;z: <span class=\"number\">3</span>, y: <span class=\"number\">2</span>, x: <span class=\"number\">1</span>&#125;)</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"提取JSON数据\"><a href=\"#提取JSON数据\" class=\"headerlink\" title=\"提取JSON数据\"></a>提取JSON数据</h4><p>解构赋值对提取JSON对象中的数据，尤其有用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> jsonData = &#123;</span><br><span class=\"line\">  id: <span class=\"number\">42</span>,</span><br><span class=\"line\">  status: <span class=\"string\">\"OK\"</span>,</span><br><span class=\"line\">  data: [<span class=\"number\">867</span>, <span class=\"number\">5309</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; id, status, data: number &#125; = jsonData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(id, status, number)</span><br><span class=\"line\"><span class=\"comment\">// 42, OK, [867, 5309]</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">jQuery.ajax = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">url, &#123;</span><br><span class=\"line\">  async = true,</span><br><span class=\"line\">  beforeSend = function (</span>) </span>&#123;&#125;,</span><br><span class=\"line\">  cache = <span class=\"literal\">true</span>,</span><br><span class=\"line\">  complete = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  crossDomain = <span class=\"literal\">false</span>,</span><br><span class=\"line\">  global = <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"comment\">// ... more config</span></span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... do stuff</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以指定参数的默认值，避免了在函数体当中写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>\n<hr>\n<h4 id=\"遍历Map结构\"><a href=\"#遍历Map结构\" class=\"headerlink\" title=\"遍历Map结构\"></a>遍历Map结构</h4><p>任何部署了Iterator接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就很方便了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">map.set(<span class=\"string\">'first'</span>, <span class=\"string\">'hello'</span>);</span><br><span class=\"line\">map.set(<span class=\"string\">'second'</span>, <span class=\"string\">'world'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key + <span class=\"string\">\" is \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// first is hello</span></span><br><span class=\"line\"><span class=\"comment\">// second is world</span></span><br></pre></td></tr></table></figure>\n<p>如上，声明了两个变量<code>key</code>和<code>value</code>去接收了键值对。如果想只接收键名或者键值，可以运用如下写法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取键名</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取键值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [,value] <span class=\"keyword\">of</span> map) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"输入模块的制定方法\"><a href=\"#输入模块的制定方法\" class=\"headerlink\" title=\"输入模块的制定方法\"></a>输入模块的制定方法</h4><p>加载模块时，往往需要制定输入哪些方法，解构赋值使得输入语句非常清晰。（我没懂。。。。）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">\"source-map\"</span>);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"2-数组的解构赋值\"><a href=\"#2-数组的解构赋值\" class=\"headerlink\" title=\"2. 数组的解构赋值\"></a>2. 数组的解构赋值</h3><h4 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h4><p>按照一定的模式（格式），从数组和对象中取值来赋值给变量，这个过程被称为解构赋值。</p>\n<p>以前，为变量赋值，只能是以下的形式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<p>而ES6允许以这种形式来赋值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [a, b, c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<p>如上代码，等号两边可以按照对应位置，去对变量赋值。</p>\n<p>这种写法属于“模式匹配”，只要等号两边的模式相同，右边的值就会赋给左边的变量中去。下面是一些解构的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo, [[bar], baz]] = [<span class=\"number\">1</span>, [[<span class=\"number\">2</span>], <span class=\"number\">3</span>]];</span><br><span class=\"line\">foo <span class=\"comment\">// 1</span></span><br><span class=\"line\">bar <span class=\"comment\">// 2</span></span><br><span class=\"line\">baz <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [ , , third] = [<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"bar\"</span>, <span class=\"string\">\"baz\"</span>];</span><br><span class=\"line\">third <span class=\"comment\">// \"baz\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, , y] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">x <span class=\"comment\">// 1</span></span><br><span class=\"line\">y <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [head, ...tail] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">head <span class=\"comment\">// 1</span></span><br><span class=\"line\">tail <span class=\"comment\">// [2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y, ...z] = [<span class=\"string\">'a'</span>];</span><br><span class=\"line\">x <span class=\"comment\">// \"a\"</span></span><br><span class=\"line\">y <span class=\"comment\">// undefined</span></span><br><span class=\"line\">z <span class=\"comment\">// []</span></span><br></pre></td></tr></table></figure>\n<p>如果解构不成功，变量的值就为<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [foo] = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> [bar, foo] = [<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<p>还有一种情况是不完全解构，等号左边的模式只可以匹配到一部分等号右边的数组，这种情况依然可以解构成功。</p>\n<p>如果等号的右边不是一个可以遍历的解构（<a href=\"http://es6.ruanyifeng.com/#docs/iterator\">具体看这里</a>），那么就会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">NaN</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo] = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面的式子都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。</p>\n<p>解构赋值不仅适用于<code>var</code>命令，也适用于<code>let</code>和<code>const</code>命令。对于Set解构，也可以使用数组的解构赋值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y, z] = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>])</span><br><span class=\"line\">x <span class=\"comment\">// \"a\"</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h4><p>解构赋值允许指定默认值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [foo = <span class=\"literal\">true</span>] = [];</span><br><span class=\"line\">foo <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">[x, y = <span class=\"string\">'b'</span>] = [<span class=\"string\">'a'</span>] <span class=\"comment\">// x='a', y='b'</span></span><br><span class=\"line\">[x, y = <span class=\"string\">'b'</span>] = [<span class=\"string\">'a'</span>, <span class=\"literal\">undefined</span>] <span class=\"comment\">// x='a', y='b'</span></span><br></pre></td></tr></table></figure>\n<p>这里要注意的是，如果要使用默认的值，一定要严责等于<code>undefined</code>，否则默认值是不会生效的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [x = <span class=\"number\">1</span>] = [<span class=\"literal\">undefined</span>];</span><br><span class=\"line\">x <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [x = <span class=\"number\">1</span>] = [<span class=\"literal\">null</span>];</span><br><span class=\"line\">x <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，如果等号右边是<code>null</code>的话，默认值就不会生效，因为<code>null</code>不严格等于<code>undefiend</code>。</p>\n<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>, y = x] = [];     <span class=\"comment\">// x=1; y=1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>, y = x] = [<span class=\"number\">2</span>];    <span class=\"comment\">// x=2; y=2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x = <span class=\"number\">1</span>, y = x] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]; <span class=\"comment\">// x=1; y=2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x = y, y = <span class=\"number\">1</span>] = [];     <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n<p>如果代码，最后一个表达式报错是因为在<code>x</code>用到<code>y</code>时，<code>y</code>还没有声明。</p>\n<hr>\n<h3 id=\"3-对象的解构赋值\"><a href=\"#3-对象的解构赋值\" class=\"headerlink\" title=\"3. 对象的解构赋值\"></a>3. 对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo, bar &#125; = &#123; foo: <span class=\"string\">\"aaa\"</span>, bar: <span class=\"string\">\"bbb\"</span> &#125;;</span><br><span class=\"line\">foo <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\">bar <span class=\"comment\">// \"bbb\"</span></span><br></pre></td></tr></table></figure>\n<p>对象的解构和数组不同的是，数组的解构是有顺序限制的，变量的取值是由他的位置决定的，而对象的属性没有次序，变量必须与属性同名才能取到正确的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; bar, foo &#125; = &#123; foo: <span class=\"string\">\"aaa\"</span>, bar: <span class=\"string\">\"bbb\"</span> &#125;;</span><br><span class=\"line\">foo <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\">bar <span class=\"comment\">// \"bbb\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; baz &#125; = &#123; foo: <span class=\"string\">\"aaa\"</span>, bar: <span class=\"string\">\"bbb\"</span> &#125;;</span><br><span class=\"line\">baz <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，等号左边两个变量的次序与等号右边两个属性的次序不一致，但是取值正确，如果变量没有对应的同名属性的话会取不到值。</p>\n<p>如果变量名和属性名不一致，我们必须引用一个叫<code>模式</code>的东西，我可能理解的比较通俗，先看以下的代码，在做解释。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo: baz &#125; = &#123; foo: <span class=\"string\">\"aaa\"</span>, bar: <span class=\"string\">\"bbb\"</span> &#125;;</span><br><span class=\"line\">baz <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; first: <span class=\"string\">'hello'</span>, last: <span class=\"string\">'world'</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; first: f, last: l &#125; = obj;</span><br><span class=\"line\">f <span class=\"comment\">// 'hello'</span></span><br><span class=\"line\">l <span class=\"comment\">// 'world'</span></span><br></pre></td></tr></table></figure>\n<p>对象的赋值解构的内部机制其实是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo: foo, bar: bar &#125; = &#123; foo: <span class=\"string\">\"aaa\"</span>, bar: <span class=\"string\">\"bbb\"</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p><code>:</code>之前的部分我们叫做<code>模式</code>，<code>:</code>之后的部分才是<code>变量</code>，在解构赋值内部机制是先根据模式找到同名的属性，再给对应的变量赋值，真正被赋值的是<code>：</code>后面的变量。</p>\n<p>在平时对象解构赋值的时候我们把<code>:</code>之后的变量给省略掉了，这样在内部他会加上一个和模式名字相同的变量名，在省略了变量名的情况下，我们打印模式名是不会出错的。</p>\n<p>但如果<code>变量</code>名和<code>模式</code>名是不一样的时候，比如下面这种情况：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; foo: baz &#125; = &#123; foo: <span class=\"string\">\"aaa\"</span>, bar: <span class=\"string\">\"bbb\"</span> &#125;;</span><br><span class=\"line\">baz <span class=\"comment\">// \"aaa\"</span></span><br><span class=\"line\">foo <span class=\"comment\">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>\n<p>如上这样，真正被赋值的就是变量<code>baz</code>，而不是模式<code>foo</code>。</p>\n<p>和数组一样，解构也可以用于嵌套解构的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> node = &#123;</span><br><span class=\"line\">  loc: &#123;</span><br><span class=\"line\">    start: &#123;</span><br><span class=\"line\">      line: <span class=\"number\">1</span>,</span><br><span class=\"line\">      column: <span class=\"number\">5</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;</span><br><span class=\"line\">line <span class=\"comment\">// 1</span></span><br><span class=\"line\">loc  <span class=\"comment\">// error: loc is undefined</span></span><br><span class=\"line\">start <span class=\"comment\">// error: start is undefined</span></span><br></pre></td></tr></table></figure>\n<p>如上，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不会被赋值。</p>\n<p>嵌套赋值的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [];</span><br><span class=\"line\"></span><br><span class=\"line\">(&#123; foo: obj.prop, bar: arr[<span class=\"number\">0</span>] &#125; = &#123; foo: <span class=\"number\">123</span>, bar: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj <span class=\"comment\">// &#123;prop:123&#125;</span></span><br><span class=\"line\">arr <span class=\"comment\">// [true]</span></span><br></pre></td></tr></table></figure>\n<p>对象的解构也可以指定默认的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;&#125;;</span><br><span class=\"line\">x <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;x, y = <span class=\"number\">5</span>&#125; = &#123;x: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">x <span class=\"comment\">// 1</span></span><br><span class=\"line\">y <span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; message: msg = <span class=\"string\">\"Something went wrong\"</span> &#125; = &#123;&#125;;</span><br><span class=\"line\">msg <span class=\"comment\">// \"Something went wrong\"</span></span><br></pre></td></tr></table></figure>\n<p>默认值生效的条件，也是对象的属性值严格等于<code>undefined</code>。如果不是严格等于<code>undefined</code>默认值就不会生效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;x: <span class=\"literal\">undefined</span>&#125;;</span><br><span class=\"line\">x <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;x = <span class=\"number\">3</span>&#125; = &#123;x: <span class=\"literal\">null</span>&#125;;</span><br><span class=\"line\">x <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>如果解构失败的话。变量的值也会等于<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;foo&#125; = &#123;bar: <span class=\"string\">'baz'</span>&#125;</span><br><span class=\"line\">foo <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>如果，解构的模式是一个对象的话，而模式名却在等号的右边不存在的话，那么将会报错。因为在解构的时候，首先会寻找与模式同名的属性，如果没有这个属性名就会报错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;foo: &#123;bar&#125;&#125; = &#123;baz: <span class=\"string\">'baz'</span>&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-字符串的解构赋值\"><a href=\"#4-字符串的解构赋值\" class=\"headerlink\" title=\"4. 字符串的解构赋值\"></a>4. 字符串的解构赋值</h3><p>字符串解构赋值是，会转换为一个类似数组的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [a, b, c, d, e] = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">a <span class=\"comment\">// \"h\"</span></span><br><span class=\"line\">b <span class=\"comment\">// \"e\"</span></span><br><span class=\"line\">c <span class=\"comment\">// \"l\"</span></span><br><span class=\"line\">d <span class=\"comment\">// \"l\"</span></span><br><span class=\"line\">e <span class=\"comment\">// \"o\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-数值和布尔值的解构赋值\"><a href=\"#5-数值和布尔值的解构赋值\" class=\"headerlink\" title=\"5. 数值和布尔值的解构赋值\"></a>5. 数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，会先转为对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;toString: s&#125; = <span class=\"number\">123</span>;</span><br><span class=\"line\">s === <span class=\"built_in\">Number</span>.prototype.toString <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;toString: s&#125; = <span class=\"literal\">true</span>;</span><br><span class=\"line\">s === <span class=\"built_in\">Boolean</span>.prototype.toString <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>解构赋值的规则是，只要等号右边的值不是对象，就先将其转化为对象，但是由于<code>undefined</code>和<code>null</code>不能转为对象，所以对他们进行解构赋值都会报错。</p>\n<h3 id=\"6-函数参数的解构赋值\"><a href=\"#6-函数参数的解构赋值\" class=\"headerlink\" title=\"6. 函数参数的解构赋值\"></a>6. 函数参数的解构赋值</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">[x, y]</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add([<span class=\"number\">1</span>, <span class=\"number\">2</span>]) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，函数<code>add</code>的参数实际上不是一个数组，而是通过结构得刀的变量<code>x</code>和<code>y</code>。</p>\n<p>函数参数的解构也可以使用默认值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">move</span>(<span class=\"params\">&#123;x = 0, y = 0&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">move(&#123;x: <span class=\"number\">3</span>, y: <span class=\"number\">8</span>&#125;); <span class=\"comment\">// [3, 8]</span></span><br><span class=\"line\">move(&#123;x: <span class=\"number\">3</span>&#125;); <span class=\"comment\">// [3, 0]</span></span><br><span class=\"line\">move(&#123;&#125;); <span class=\"comment\">// [0, 0]</span></span><br><span class=\"line\">move(); <span class=\"comment\">// [0, 0]</span></span><br></pre></td></tr></table></figure>\n<p>以上还有很多细节方面没有描述，只是在常用方面做出了总结，详细的<a href=\"http://es6.ruanyifeng.com/#docs/destructuring\">请看</a></p>\n"},{"layout":"post","title":"通过Charles解决手机调试本地页面时的跨域问题","date":"2016-01-25T16:00:00.000Z","_content":"\n今天在调试本地页面的时候遇到了一个问题，在本地调试页面，如果访问服务器的接口就会遇到跨域的问题。当在pc端调试本地页面的时候，使用浏览器插件allow-control-allow-origin就可以解决跨域的问题。但是如果是用手机端来调试页面的话，手机端没有解决跨域的插件，那应该怎么解决这个问题呢？经过同事的指导，我基本解决了手机跨域的问题，总结出来以便未来使用。\n\n解决手机跨域的问题，是通过Charles这个软件，通过把手机的访问请求通过本地pc来代理，来解决跨域的问题。大概思路是这个样子，下面我来把过程简单总结一下。\n\n******\n\n首先，我们应该设置一下手机的代理，一般都是在wifi链接的位置进行代理的设置，主机名填写本地pc端的ip地址，通过`ifconfig`指令来查看ip地址，可以看到我的ip地址为 172.100.108.94 ，端口号Charles默认为8888，设置好之后，打开Charles，弹出一个对话框选择allow，我们就可以通过Charles的代理来连接网络了。\n\n![p1](http://7xqch8.com1.z0.glb.clouddn.com/blog_picp1.png)\n\n******\n\n这样我们通过代理，就等于使用本地的pc端来访问页面了，但是我们在访问服务器接口的时候，因为没有解决跨域的浏览器插件，我们还是不可以访问服务器的接口。\n\n以我实际操作来举例子，我需要访问的是 `api.haojin.in/shop_list `这个接口，我使用手机通过代理后，我的ip变成了本地pc端的ip，但是还是跨域无法访问服务器的接口。\n\n我如果需要访问成功必须保证我的域名和服务器的一致，这样才可以访问。\n\n******\n\n所以，我改了访问接口的js文件，原本js中接口为`api.haojin.in/shop_list ` ， 我改为我本地的ip加上接口名 `http://172.100.108.94:63341/shop_list` 这里需要注意，如果你使用的不是默认端口的话，你需要把端口号也加上。\n\n这样我们通过代理，来访问接口时，就保证了我们是在同一个域当中，但是我们本地不存在这样一个接口，所以访问这个接口的时候时出错的。\n\n所以我们再通过Charles的map remote功能，map remote的功能就是把一个请求重定向到另一个地址上面，这样我们只要把 `http://172.100.108.94:63341/shop_list` 重定向到 `api.haojin.in/shop_list ` 我们就可以成功的访问到服务器的接口了。\n\n所以我们在Charles中找到tools中的map remote选项，如下图所示。\n\n![p2](http://7xqch8.com1.z0.glb.clouddn.com/blog_picp2.png)\n\n点击add（添加）我们就可以增加一条重定向。在弹出的界面中我们就可以设置我们需要的参数了。如下图。\n\n![p2](http://7xqch8.com1.z0.glb.clouddn.com/blog_picp3.png)\n\n上面一栏就是我们原本的请求，填写协议，域名，端口号，路径等参数就可以了。下面一栏就是我们需要重定向到的地址，可以看到端口号没有填，他默认是80端口。\n\n点击ok保存后，我们就可以成功的访问到服务器的接口了。这样我们就解决了手机调试本地页面时的跨域问题。\n\n通过抓包查看，我们可以看到通过手机已经可以成功的访问到服务器的接口。\n\n![p2](http://7xqch8.com1.z0.glb.clouddn.com/blog_picp4.png)\n\n******\n\n但是这种方法也有很多不足的地方，比如：第一，我们这样设置只能访问指定的一个接口，当有多个接口时，我们必须把每个接口依次设置一遍，这本身也很浪费时间。第二，我们需要更改本地js文件当中的接口，当完成本地调试如果需要上线的时候，还需要把本地的js文件改回去，这样在来回更改的过程中可能出现错误。第三，这样更改之后我们通过手机访问时没有问题，但是pc端访问时因为没有通过代理，pc端的页面就不能访问到服务器的接口了，这样也会造成麻烦，pc端和手机端无法一起调试，除非pc端也通过代理来访问服务器接口。\n\n以上就是我这次遇到问题时的解决办法，虽然可能这个解决办法不是最好的，但起码他可以解决这个问题，我也会继续在网上寻找更好的解决办法，希望可以更加简单和优雅的解决这个问题。\n\n","source":"_posts/2016-01-26-Charles解决跨域问题.md","raw":"---\nlayout: post\ntitle: 通过Charles解决手机调试本地页面时的跨域问题\ndate: 2016-01-26\ntags: [Charles,跨域问题]\ncategories: Charles\n---\n\n今天在调试本地页面的时候遇到了一个问题，在本地调试页面，如果访问服务器的接口就会遇到跨域的问题。当在pc端调试本地页面的时候，使用浏览器插件allow-control-allow-origin就可以解决跨域的问题。但是如果是用手机端来调试页面的话，手机端没有解决跨域的插件，那应该怎么解决这个问题呢？经过同事的指导，我基本解决了手机跨域的问题，总结出来以便未来使用。\n\n解决手机跨域的问题，是通过Charles这个软件，通过把手机的访问请求通过本地pc来代理，来解决跨域的问题。大概思路是这个样子，下面我来把过程简单总结一下。\n\n******\n\n首先，我们应该设置一下手机的代理，一般都是在wifi链接的位置进行代理的设置，主机名填写本地pc端的ip地址，通过`ifconfig`指令来查看ip地址，可以看到我的ip地址为 172.100.108.94 ，端口号Charles默认为8888，设置好之后，打开Charles，弹出一个对话框选择allow，我们就可以通过Charles的代理来连接网络了。\n\n![p1](http://7xqch8.com1.z0.glb.clouddn.com/blog_picp1.png)\n\n******\n\n这样我们通过代理，就等于使用本地的pc端来访问页面了，但是我们在访问服务器接口的时候，因为没有解决跨域的浏览器插件，我们还是不可以访问服务器的接口。\n\n以我实际操作来举例子，我需要访问的是 `api.haojin.in/shop_list `这个接口，我使用手机通过代理后，我的ip变成了本地pc端的ip，但是还是跨域无法访问服务器的接口。\n\n我如果需要访问成功必须保证我的域名和服务器的一致，这样才可以访问。\n\n******\n\n所以，我改了访问接口的js文件，原本js中接口为`api.haojin.in/shop_list ` ， 我改为我本地的ip加上接口名 `http://172.100.108.94:63341/shop_list` 这里需要注意，如果你使用的不是默认端口的话，你需要把端口号也加上。\n\n这样我们通过代理，来访问接口时，就保证了我们是在同一个域当中，但是我们本地不存在这样一个接口，所以访问这个接口的时候时出错的。\n\n所以我们再通过Charles的map remote功能，map remote的功能就是把一个请求重定向到另一个地址上面，这样我们只要把 `http://172.100.108.94:63341/shop_list` 重定向到 `api.haojin.in/shop_list ` 我们就可以成功的访问到服务器的接口了。\n\n所以我们在Charles中找到tools中的map remote选项，如下图所示。\n\n![p2](http://7xqch8.com1.z0.glb.clouddn.com/blog_picp2.png)\n\n点击add（添加）我们就可以增加一条重定向。在弹出的界面中我们就可以设置我们需要的参数了。如下图。\n\n![p2](http://7xqch8.com1.z0.glb.clouddn.com/blog_picp3.png)\n\n上面一栏就是我们原本的请求，填写协议，域名，端口号，路径等参数就可以了。下面一栏就是我们需要重定向到的地址，可以看到端口号没有填，他默认是80端口。\n\n点击ok保存后，我们就可以成功的访问到服务器的接口了。这样我们就解决了手机调试本地页面时的跨域问题。\n\n通过抓包查看，我们可以看到通过手机已经可以成功的访问到服务器的接口。\n\n![p2](http://7xqch8.com1.z0.glb.clouddn.com/blog_picp4.png)\n\n******\n\n但是这种方法也有很多不足的地方，比如：第一，我们这样设置只能访问指定的一个接口，当有多个接口时，我们必须把每个接口依次设置一遍，这本身也很浪费时间。第二，我们需要更改本地js文件当中的接口，当完成本地调试如果需要上线的时候，还需要把本地的js文件改回去，这样在来回更改的过程中可能出现错误。第三，这样更改之后我们通过手机访问时没有问题，但是pc端访问时因为没有通过代理，pc端的页面就不能访问到服务器的接口了，这样也会造成麻烦，pc端和手机端无法一起调试，除非pc端也通过代理来访问服务器接口。\n\n以上就是我这次遇到问题时的解决办法，虽然可能这个解决办法不是最好的，但起码他可以解决这个问题，我也会继续在网上寻找更好的解决办法，希望可以更加简单和优雅的解决这个问题。\n\n","slug":"Charles解决跨域问题","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1yb000lsq5ljzvemayo","content":"<p>今天在调试本地页面的时候遇到了一个问题，在本地调试页面，如果访问服务器的接口就会遇到跨域的问题。当在pc端调试本地页面的时候，使用浏览器插件allow-control-allow-origin就可以解决跨域的问题。但是如果是用手机端来调试页面的话，手机端没有解决跨域的插件，那应该怎么解决这个问题呢？经过同事的指导，我基本解决了手机跨域的问题，总结出来以便未来使用。</p>\n<p>解决手机跨域的问题，是通过Charles这个软件，通过把手机的访问请求通过本地pc来代理，来解决跨域的问题。大概思路是这个样子，下面我来把过程简单总结一下。</p>\n<hr>\n<p>首先，我们应该设置一下手机的代理，一般都是在wifi链接的位置进行代理的设置，主机名填写本地pc端的ip地址，通过<code>ifconfig</code>指令来查看ip地址，可以看到我的ip地址为 172.100.108.94 ，端口号Charles默认为8888，设置好之后，打开Charles，弹出一个对话框选择allow，我们就可以通过Charles的代理来连接网络了。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_picp1.png\" alt=\"p1\"></p>\n<hr>\n<p>这样我们通过代理，就等于使用本地的pc端来访问页面了，但是我们在访问服务器接口的时候，因为没有解决跨域的浏览器插件，我们还是不可以访问服务器的接口。</p>\n<p>以我实际操作来举例子，我需要访问的是 <code>api.haojin.in/shop_list</code>这个接口，我使用手机通过代理后，我的ip变成了本地pc端的ip，但是还是跨域无法访问服务器的接口。</p>\n<p>我如果需要访问成功必须保证我的域名和服务器的一致，这样才可以访问。</p>\n<hr>\n<p>所以，我改了访问接口的js文件，原本js中接口为<code>api.haojin.in/shop_list</code> ， 我改为我本地的ip加上接口名 <code>http://172.100.108.94:63341/shop_list</code> 这里需要注意，如果你使用的不是默认端口的话，你需要把端口号也加上。</p>\n<p>这样我们通过代理，来访问接口时，就保证了我们是在同一个域当中，但是我们本地不存在这样一个接口，所以访问这个接口的时候时出错的。</p>\n<p>所以我们再通过Charles的map remote功能，map remote的功能就是把一个请求重定向到另一个地址上面，这样我们只要把 <code>http://172.100.108.94:63341/shop_list</code> 重定向到 <code>api.haojin.in/shop_list</code> 我们就可以成功的访问到服务器的接口了。</p>\n<p>所以我们在Charles中找到tools中的map remote选项，如下图所示。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_picp2.png\" alt=\"p2\"></p>\n<p>点击add（添加）我们就可以增加一条重定向。在弹出的界面中我们就可以设置我们需要的参数了。如下图。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_picp3.png\" alt=\"p2\"></p>\n<p>上面一栏就是我们原本的请求，填写协议，域名，端口号，路径等参数就可以了。下面一栏就是我们需要重定向到的地址，可以看到端口号没有填，他默认是80端口。</p>\n<p>点击ok保存后，我们就可以成功的访问到服务器的接口了。这样我们就解决了手机调试本地页面时的跨域问题。</p>\n<p>通过抓包查看，我们可以看到通过手机已经可以成功的访问到服务器的接口。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_picp4.png\" alt=\"p2\"></p>\n<hr>\n<p>但是这种方法也有很多不足的地方，比如：第一，我们这样设置只能访问指定的一个接口，当有多个接口时，我们必须把每个接口依次设置一遍，这本身也很浪费时间。第二，我们需要更改本地js文件当中的接口，当完成本地调试如果需要上线的时候，还需要把本地的js文件改回去，这样在来回更改的过程中可能出现错误。第三，这样更改之后我们通过手机访问时没有问题，但是pc端访问时因为没有通过代理，pc端的页面就不能访问到服务器的接口了，这样也会造成麻烦，pc端和手机端无法一起调试，除非pc端也通过代理来访问服务器接口。</p>\n<p>以上就是我这次遇到问题时的解决办法，虽然可能这个解决办法不是最好的，但起码他可以解决这个问题，我也会继续在网上寻找更好的解决办法，希望可以更加简单和优雅的解决这个问题。</p>\n","excerpt":"","more":"<p>今天在调试本地页面的时候遇到了一个问题，在本地调试页面，如果访问服务器的接口就会遇到跨域的问题。当在pc端调试本地页面的时候，使用浏览器插件allow-control-allow-origin就可以解决跨域的问题。但是如果是用手机端来调试页面的话，手机端没有解决跨域的插件，那应该怎么解决这个问题呢？经过同事的指导，我基本解决了手机跨域的问题，总结出来以便未来使用。</p>\n<p>解决手机跨域的问题，是通过Charles这个软件，通过把手机的访问请求通过本地pc来代理，来解决跨域的问题。大概思路是这个样子，下面我来把过程简单总结一下。</p>\n<hr>\n<p>首先，我们应该设置一下手机的代理，一般都是在wifi链接的位置进行代理的设置，主机名填写本地pc端的ip地址，通过<code>ifconfig</code>指令来查看ip地址，可以看到我的ip地址为 172.100.108.94 ，端口号Charles默认为8888，设置好之后，打开Charles，弹出一个对话框选择allow，我们就可以通过Charles的代理来连接网络了。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_picp1.png\" alt=\"p1\"></p>\n<hr>\n<p>这样我们通过代理，就等于使用本地的pc端来访问页面了，但是我们在访问服务器接口的时候，因为没有解决跨域的浏览器插件，我们还是不可以访问服务器的接口。</p>\n<p>以我实际操作来举例子，我需要访问的是 <code>api.haojin.in/shop_list</code>这个接口，我使用手机通过代理后，我的ip变成了本地pc端的ip，但是还是跨域无法访问服务器的接口。</p>\n<p>我如果需要访问成功必须保证我的域名和服务器的一致，这样才可以访问。</p>\n<hr>\n<p>所以，我改了访问接口的js文件，原本js中接口为<code>api.haojin.in/shop_list</code> ， 我改为我本地的ip加上接口名 <code>http://172.100.108.94:63341/shop_list</code> 这里需要注意，如果你使用的不是默认端口的话，你需要把端口号也加上。</p>\n<p>这样我们通过代理，来访问接口时，就保证了我们是在同一个域当中，但是我们本地不存在这样一个接口，所以访问这个接口的时候时出错的。</p>\n<p>所以我们再通过Charles的map remote功能，map remote的功能就是把一个请求重定向到另一个地址上面，这样我们只要把 <code>http://172.100.108.94:63341/shop_list</code> 重定向到 <code>api.haojin.in/shop_list</code> 我们就可以成功的访问到服务器的接口了。</p>\n<p>所以我们在Charles中找到tools中的map remote选项，如下图所示。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_picp2.png\" alt=\"p2\"></p>\n<p>点击add（添加）我们就可以增加一条重定向。在弹出的界面中我们就可以设置我们需要的参数了。如下图。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_picp3.png\" alt=\"p2\"></p>\n<p>上面一栏就是我们原本的请求，填写协议，域名，端口号，路径等参数就可以了。下面一栏就是我们需要重定向到的地址，可以看到端口号没有填，他默认是80端口。</p>\n<p>点击ok保存后，我们就可以成功的访问到服务器的接口了。这样我们就解决了手机调试本地页面时的跨域问题。</p>\n<p>通过抓包查看，我们可以看到通过手机已经可以成功的访问到服务器的接口。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_picp4.png\" alt=\"p2\"></p>\n<hr>\n<p>但是这种方法也有很多不足的地方，比如：第一，我们这样设置只能访问指定的一个接口，当有多个接口时，我们必须把每个接口依次设置一遍，这本身也很浪费时间。第二，我们需要更改本地js文件当中的接口，当完成本地调试如果需要上线的时候，还需要把本地的js文件改回去，这样在来回更改的过程中可能出现错误。第三，这样更改之后我们通过手机访问时没有问题，但是pc端访问时因为没有通过代理，pc端的页面就不能访问到服务器的接口了，这样也会造成麻烦，pc端和手机端无法一起调试，除非pc端也通过代理来访问服务器接口。</p>\n<p>以上就是我这次遇到问题时的解决办法，虽然可能这个解决办法不是最好的，但起码他可以解决这个问题，我也会继续在网上寻找更好的解决办法，希望可以更加简单和优雅的解决这个问题。</p>\n"},{"layout":"post","title":"初学webpack遇到的坑","date":"2016-01-28T16:00:00.000Z","_content":"\nwebpack是继grunt和gulp之后的一个自动化集成的工具，虽说我grunt都还没有熟练操作，但是有了对grunt了解，我想尽快的掌握比较新的技术。\n\n我主要是按照知乎专栏中的[这篇文章](http://zhuanlan.zhihu.com/FrontendMagazine/20367175)一步一步的傻瓜操作的，基本说的很详细，照着步骤来做就可以搭建一个简单地webpack环境。\n\n我现在主要是按照文章的顺序，对我其中遇到的坑，来一个总结，下次如果还会再搭一个环境的时候，不至于没有头绪。\n\n下面我会按照文章中标题的顺序，来总结我遇到的坑，没有问题的部分我就不详细叙述，按照文章中的步骤来就可以。\n\n*****\n\n### 配置webpack\n\n在这个部分，我按照文章中的步骤做好，最后在项目根目录下运行`webpack`的时候，命令行报出了错误。\n\n```ruby\n\nmodule.js:340\nthrow err;\ncanot find module 'webpack/lib/node/NodeTemplatePlugin'\n\n```\n\n说不能找到这个模块，但是当我找到这个路径`/usr/local/lib/node_modules/webpack/lib/node`，`cd`进入后，`ls`查看我目录下是有这个文件的。所以问题应该不是缺少这个文件，\n\n然后我上网搜索，知道了应该是路径设置的不正确，并找到了解决的办法。[在这里](https://segmentfault.com/a/1190000002478924)\n\n是因为我们没有设置环境变量，按上面这篇文章我设置了环境变量之后\n\n`export NODE_PATH=\"/usr/local/node_modules:/usr/local/lib/node_modules\" `\n\n再次运行`webpack`后就能顺利的构建出一个项目了。\n\n第一个坑算是踏过去了，用了大概半天时间。。。。一种一种方法去试。。。。\n\n*******\n\n### 配置webpack-dev-server\n\n在这部分我又遇到一个坑,在按照步骤一步一步做好后，在运行最后的命令`npm start`的时候有报出了错误。\n\n```ruby\n\nERROR in multi main\nModule not found: Error: Cannot resolve module 'webpack/hot/dev-server' in /Users/yatessss/webpack\n @ multi main\n\n```\n\n大概的意思我查了一下，就是说模块无法解析，目前为止这个坑还没有填平。但是这不影响我们继续往下进行，这一部分是可以让服务器监听文件的变化的，在我们不刷新页面的时候，内容也会随着文件的变化做出相应的修改。\n\n我现在猜测这个错误的出现可能有两个原因。第一，就是在解决上一个环境变量的错误的时候，设置了路径，导致路径更改后找不到这个模块。第二，这个模块没有正确安装（但是我已经安装了很多遍）。\n\n我最后解决了这个问题。解决方法是受到了这个问题的启发[点击这里](http://stackoverflow.com/questions/29290301/cant-get-webpack-hot-module-replacement-to-work)，这里不得不说stackoverflow这个网站真的是很好的。\n\n这里我只改动了知乎这篇文章的设置的两个地方（其实把他们删掉应该也是可以的），在stackoverflow这个问题里有这样一句话：`--hot option is looking for some files locally`，这里是说`--hot`这个参数是设置在当前目录寻找一些文件的，而我们设置过环境变量，我在猜想是不是设置过变量后，所以我不能在当前找到这个模块了，所以我试着把`config`文件中`devServer`配置项中的`hot`改为了`false`，如下：\n\n```ruby\n\ndevServer: {\n        historyApiFallback: true,\n        hot: false,\n        inline: true,\n        progress: true\n    }\n\n```\n\n把`package.json`文件中的`scripts`配置项改为`\"start\": \"webpack-dev-server --inline\"`，如下：\n\n```ruby\n\n\"scripts\": {\n    \"start\": \"webpack-dev-server --inline\"\n  }\n\n```\n\n这样，我们就禁止了他只在项目目录中寻找文件，在当前目录中没有找到的话，他会寻找根目录，经过试验，我的想法得到了证实，这样改动之后，`npm start`命令可以正常运行了。\n\n这个问题也算是有了解决方法。\n\n\n*******\n\n### 添加CSS样式\n\n在添加css样式这部分，没有问题。但是在配置css预编译程序sass的时候，遇到了两个错误。第一个错误是说我没有安装`node-sass`，这时候我们安装node-sass就好了；第二个错误我没有记录下来，大概是说`我的node-sass的版本和目前node不匹配`，而且错误当中也给出了解决办法，只要运行`npm rebuild node-sass`等一会之后，这个错误就可以解决了。\n\n*******\n\n### 添加第三方库\n\n再添加第三方库的时候，按照步骤没有什么大的问题，只是有时候缺少一些依赖的库，比如遇到下面这种情况。\n\n```ruby\n\n├── UNMET PEER DEPENDENCY file-loader@*\n├── jquery@2.2.0\n├── moment@2.11.1\n└── UNMET PEER DEPENDENCY webpack@^1.12.6\n\n```\n\n这样的话就是缺少`file-loader` 这个依赖的库，所以只要安装这个库就好了。\n\n\n以上，就是我学习webpack第一部分碰到的一些问题，总结来加深印象。\n","source":"_posts/2016-01-29-初学webpack遇到的坑.md","raw":"---\nlayout: post\ntitle: 初学webpack遇到的坑\ndate: 2016-01-29\ntags: [webpack]\ncategories: webpack\n---\n\nwebpack是继grunt和gulp之后的一个自动化集成的工具，虽说我grunt都还没有熟练操作，但是有了对grunt了解，我想尽快的掌握比较新的技术。\n\n我主要是按照知乎专栏中的[这篇文章](http://zhuanlan.zhihu.com/FrontendMagazine/20367175)一步一步的傻瓜操作的，基本说的很详细，照着步骤来做就可以搭建一个简单地webpack环境。\n\n我现在主要是按照文章的顺序，对我其中遇到的坑，来一个总结，下次如果还会再搭一个环境的时候，不至于没有头绪。\n\n下面我会按照文章中标题的顺序，来总结我遇到的坑，没有问题的部分我就不详细叙述，按照文章中的步骤来就可以。\n\n*****\n\n### 配置webpack\n\n在这个部分，我按照文章中的步骤做好，最后在项目根目录下运行`webpack`的时候，命令行报出了错误。\n\n```ruby\n\nmodule.js:340\nthrow err;\ncanot find module 'webpack/lib/node/NodeTemplatePlugin'\n\n```\n\n说不能找到这个模块，但是当我找到这个路径`/usr/local/lib/node_modules/webpack/lib/node`，`cd`进入后，`ls`查看我目录下是有这个文件的。所以问题应该不是缺少这个文件，\n\n然后我上网搜索，知道了应该是路径设置的不正确，并找到了解决的办法。[在这里](https://segmentfault.com/a/1190000002478924)\n\n是因为我们没有设置环境变量，按上面这篇文章我设置了环境变量之后\n\n`export NODE_PATH=\"/usr/local/node_modules:/usr/local/lib/node_modules\" `\n\n再次运行`webpack`后就能顺利的构建出一个项目了。\n\n第一个坑算是踏过去了，用了大概半天时间。。。。一种一种方法去试。。。。\n\n*******\n\n### 配置webpack-dev-server\n\n在这部分我又遇到一个坑,在按照步骤一步一步做好后，在运行最后的命令`npm start`的时候有报出了错误。\n\n```ruby\n\nERROR in multi main\nModule not found: Error: Cannot resolve module 'webpack/hot/dev-server' in /Users/yatessss/webpack\n @ multi main\n\n```\n\n大概的意思我查了一下，就是说模块无法解析，目前为止这个坑还没有填平。但是这不影响我们继续往下进行，这一部分是可以让服务器监听文件的变化的，在我们不刷新页面的时候，内容也会随着文件的变化做出相应的修改。\n\n我现在猜测这个错误的出现可能有两个原因。第一，就是在解决上一个环境变量的错误的时候，设置了路径，导致路径更改后找不到这个模块。第二，这个模块没有正确安装（但是我已经安装了很多遍）。\n\n我最后解决了这个问题。解决方法是受到了这个问题的启发[点击这里](http://stackoverflow.com/questions/29290301/cant-get-webpack-hot-module-replacement-to-work)，这里不得不说stackoverflow这个网站真的是很好的。\n\n这里我只改动了知乎这篇文章的设置的两个地方（其实把他们删掉应该也是可以的），在stackoverflow这个问题里有这样一句话：`--hot option is looking for some files locally`，这里是说`--hot`这个参数是设置在当前目录寻找一些文件的，而我们设置过环境变量，我在猜想是不是设置过变量后，所以我不能在当前找到这个模块了，所以我试着把`config`文件中`devServer`配置项中的`hot`改为了`false`，如下：\n\n```ruby\n\ndevServer: {\n        historyApiFallback: true,\n        hot: false,\n        inline: true,\n        progress: true\n    }\n\n```\n\n把`package.json`文件中的`scripts`配置项改为`\"start\": \"webpack-dev-server --inline\"`，如下：\n\n```ruby\n\n\"scripts\": {\n    \"start\": \"webpack-dev-server --inline\"\n  }\n\n```\n\n这样，我们就禁止了他只在项目目录中寻找文件，在当前目录中没有找到的话，他会寻找根目录，经过试验，我的想法得到了证实，这样改动之后，`npm start`命令可以正常运行了。\n\n这个问题也算是有了解决方法。\n\n\n*******\n\n### 添加CSS样式\n\n在添加css样式这部分，没有问题。但是在配置css预编译程序sass的时候，遇到了两个错误。第一个错误是说我没有安装`node-sass`，这时候我们安装node-sass就好了；第二个错误我没有记录下来，大概是说`我的node-sass的版本和目前node不匹配`，而且错误当中也给出了解决办法，只要运行`npm rebuild node-sass`等一会之后，这个错误就可以解决了。\n\n*******\n\n### 添加第三方库\n\n再添加第三方库的时候，按照步骤没有什么大的问题，只是有时候缺少一些依赖的库，比如遇到下面这种情况。\n\n```ruby\n\n├── UNMET PEER DEPENDENCY file-loader@*\n├── jquery@2.2.0\n├── moment@2.11.1\n└── UNMET PEER DEPENDENCY webpack@^1.12.6\n\n```\n\n这样的话就是缺少`file-loader` 这个依赖的库，所以只要安装这个库就好了。\n\n\n以上，就是我学习webpack第一部分碰到的一些问题，总结来加深印象。\n","slug":"初学webpack遇到的坑","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1yd000osq5l9ayyeg9x","content":"<p>webpack是继grunt和gulp之后的一个自动化集成的工具，虽说我grunt都还没有熟练操作，但是有了对grunt了解，我想尽快的掌握比较新的技术。</p>\n<p>我主要是按照知乎专栏中的<a href=\"http://zhuanlan.zhihu.com/FrontendMagazine/20367175\" target=\"_blank\" rel=\"external\">这篇文章</a>一步一步的傻瓜操作的，基本说的很详细，照着步骤来做就可以搭建一个简单地webpack环境。</p>\n<p>我现在主要是按照文章的顺序，对我其中遇到的坑，来一个总结，下次如果还会再搭一个环境的时候，不至于没有头绪。</p>\n<p>下面我会按照文章中标题的顺序，来总结我遇到的坑，没有问题的部分我就不详细叙述，按照文章中的步骤来就可以。</p>\n<hr>\n<h3 id=\"配置webpack\"><a href=\"#配置webpack\" class=\"headerlink\" title=\"配置webpack\"></a>配置webpack</h3><p>在这个部分，我按照文章中的步骤做好，最后在项目根目录下运行<code>webpack</code>的时候，命令行报出了错误。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">module</span>.<span class=\"title\">js</span>:340</span></span><br><span class=\"line\">throw err;</span><br><span class=\"line\">canot find <span class=\"class\"><span class=\"keyword\">module</span> '<span class=\"title\">webpack</span>/<span class=\"title\">lib</span>/<span class=\"title\">node</span>/<span class=\"title\">NodeTemplatePlugin</span>'</span></span><br></pre></td></tr></table></figure>\n<p>说不能找到这个模块，但是当我找到这个路径<code>/usr/local/lib/node_modules/webpack/lib/node</code>，<code>cd</code>进入后，<code>ls</code>查看我目录下是有这个文件的。所以问题应该不是缺少这个文件，</p>\n<p>然后我上网搜索，知道了应该是路径设置的不正确，并找到了解决的办法。<a href=\"https://segmentfault.com/a/1190000002478924\" target=\"_blank\" rel=\"external\">在这里</a></p>\n<p>是因为我们没有设置环境变量，按上面这篇文章我设置了环境变量之后</p>\n<p><code>export NODE_PATH=&quot;/usr/local/node_modules:/usr/local/lib/node_modules&quot;</code></p>\n<p>再次运行<code>webpack</code>后就能顺利的构建出一个项目了。</p>\n<p>第一个坑算是踏过去了，用了大概半天时间。。。。一种一种方法去试。。。。</p>\n<hr>\n<h3 id=\"配置webpack-dev-server\"><a href=\"#配置webpack-dev-server\" class=\"headerlink\" title=\"配置webpack-dev-server\"></a>配置webpack-dev-server</h3><p>在这部分我又遇到一个坑,在按照步骤一步一步做好后，在运行最后的命令<code>npm start</code>的时候有报出了错误。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ERROR <span class=\"keyword\">in</span> multi main</span><br><span class=\"line\">Module <span class=\"keyword\">not</span> <span class=\"symbol\">found:</span> <span class=\"symbol\">Error:</span> Cannot resolve <span class=\"class\"><span class=\"keyword\">module</span> '<span class=\"title\">webpack</span>/<span class=\"title\">hot</span>/<span class=\"title\">dev</span>-<span class=\"title\">server</span>' <span class=\"title\">in</span> /<span class=\"title\">Users</span>/<span class=\"title\">yatessss</span>/<span class=\"title\">webpack</span></span></span><br><span class=\"line\"> @ multi main</span><br></pre></td></tr></table></figure>\n<p>大概的意思我查了一下，就是说模块无法解析，目前为止这个坑还没有填平。但是这不影响我们继续往下进行，这一部分是可以让服务器监听文件的变化的，在我们不刷新页面的时候，内容也会随着文件的变化做出相应的修改。</p>\n<p>我现在猜测这个错误的出现可能有两个原因。第一，就是在解决上一个环境变量的错误的时候，设置了路径，导致路径更改后找不到这个模块。第二，这个模块没有正确安装（但是我已经安装了很多遍）。</p>\n<p>我最后解决了这个问题。解决方法是受到了这个问题的启发<a href=\"http://stackoverflow.com/questions/29290301/cant-get-webpack-hot-module-replacement-to-work\" target=\"_blank\" rel=\"external\">点击这里</a>，这里不得不说stackoverflow这个网站真的是很好的。</p>\n<p>这里我只改动了知乎这篇文章的设置的两个地方（其实把他们删掉应该也是可以的），在stackoverflow这个问题里有这样一句话：<code>--hot option is looking for some files locally</code>，这里是说<code>--hot</code>这个参数是设置在当前目录寻找一些文件的，而我们设置过环境变量，我在猜想是不是设置过变量后，所以我不能在当前找到这个模块了，所以我试着把<code>config</code>文件中<code>devServer</code>配置项中的<code>hot</code>改为了<code>false</code>，如下：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">devServer:</span> &#123;</span><br><span class=\"line\">        <span class=\"symbol\">historyApiFallback:</span> <span class=\"keyword\">true</span>,</span><br><span class=\"line\">        <span class=\"symbol\">hot:</span> <span class=\"keyword\">false</span>,</span><br><span class=\"line\">        <span class=\"symbol\">inline:</span> <span class=\"keyword\">true</span>,</span><br><span class=\"line\">        <span class=\"symbol\">progress:</span> <span class=\"keyword\">true</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>把<code>package.json</code>文件中的<code>scripts</code>配置项改为<code>&quot;start&quot;: &quot;webpack-dev-server --inline&quot;</code>，如下：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"scripts\"</span><span class=\"symbol\">:</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">\"start\"</span><span class=\"symbol\">:</span> <span class=\"string\">\"webpack-dev-server --inline\"</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这样，我们就禁止了他只在项目目录中寻找文件，在当前目录中没有找到的话，他会寻找根目录，经过试验，我的想法得到了证实，这样改动之后，<code>npm start</code>命令可以正常运行了。</p>\n<p>这个问题也算是有了解决方法。</p>\n<hr>\n<h3 id=\"添加CSS样式\"><a href=\"#添加CSS样式\" class=\"headerlink\" title=\"添加CSS样式\"></a>添加CSS样式</h3><p>在添加css样式这部分，没有问题。但是在配置css预编译程序sass的时候，遇到了两个错误。第一个错误是说我没有安装<code>node-sass</code>，这时候我们安装node-sass就好了；第二个错误我没有记录下来，大概是说<code>我的node-sass的版本和目前node不匹配</code>，而且错误当中也给出了解决办法，只要运行<code>npm rebuild node-sass</code>等一会之后，这个错误就可以解决了。</p>\n<hr>\n<h3 id=\"添加第三方库\"><a href=\"#添加第三方库\" class=\"headerlink\" title=\"添加第三方库\"></a>添加第三方库</h3><p>再添加第三方库的时候，按照步骤没有什么大的问题，只是有时候缺少一些依赖的库，比如遇到下面这种情况。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">├── UNMET PEER DEPENDENCY file-loader@*</span><br><span class=\"line\">├── jquery@2.<span class=\"number\">2.0</span></span><br><span class=\"line\">├── moment@2.<span class=\"number\">11.1</span></span><br><span class=\"line\">└── UNMET PEER DEPENDENCY webpack@^<span class=\"number\">1.12</span>.<span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>这样的话就是缺少<code>file-loader</code> 这个依赖的库，所以只要安装这个库就好了。</p>\n<p>以上，就是我学习webpack第一部分碰到的一些问题，总结来加深印象。</p>\n","excerpt":"","more":"<p>webpack是继grunt和gulp之后的一个自动化集成的工具，虽说我grunt都还没有熟练操作，但是有了对grunt了解，我想尽快的掌握比较新的技术。</p>\n<p>我主要是按照知乎专栏中的<a href=\"http://zhuanlan.zhihu.com/FrontendMagazine/20367175\">这篇文章</a>一步一步的傻瓜操作的，基本说的很详细，照着步骤来做就可以搭建一个简单地webpack环境。</p>\n<p>我现在主要是按照文章的顺序，对我其中遇到的坑，来一个总结，下次如果还会再搭一个环境的时候，不至于没有头绪。</p>\n<p>下面我会按照文章中标题的顺序，来总结我遇到的坑，没有问题的部分我就不详细叙述，按照文章中的步骤来就可以。</p>\n<hr>\n<h3 id=\"配置webpack\"><a href=\"#配置webpack\" class=\"headerlink\" title=\"配置webpack\"></a>配置webpack</h3><p>在这个部分，我按照文章中的步骤做好，最后在项目根目录下运行<code>webpack</code>的时候，命令行报出了错误。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">module</span>.<span class=\"title\">js</span>:340</span></span><br><span class=\"line\">throw err;</span><br><span class=\"line\">canot find <span class=\"class\"><span class=\"keyword\">module</span> '<span class=\"title\">webpack</span>/<span class=\"title\">lib</span>/<span class=\"title\">node</span>/<span class=\"title\">NodeTemplatePlugin</span>'</span></span><br></pre></td></tr></table></figure>\n<p>说不能找到这个模块，但是当我找到这个路径<code>/usr/local/lib/node_modules/webpack/lib/node</code>，<code>cd</code>进入后，<code>ls</code>查看我目录下是有这个文件的。所以问题应该不是缺少这个文件，</p>\n<p>然后我上网搜索，知道了应该是路径设置的不正确，并找到了解决的办法。<a href=\"https://segmentfault.com/a/1190000002478924\">在这里</a></p>\n<p>是因为我们没有设置环境变量，按上面这篇文章我设置了环境变量之后</p>\n<p><code>export NODE_PATH=&quot;/usr/local/node_modules:/usr/local/lib/node_modules&quot;</code></p>\n<p>再次运行<code>webpack</code>后就能顺利的构建出一个项目了。</p>\n<p>第一个坑算是踏过去了，用了大概半天时间。。。。一种一种方法去试。。。。</p>\n<hr>\n<h3 id=\"配置webpack-dev-server\"><a href=\"#配置webpack-dev-server\" class=\"headerlink\" title=\"配置webpack-dev-server\"></a>配置webpack-dev-server</h3><p>在这部分我又遇到一个坑,在按照步骤一步一步做好后，在运行最后的命令<code>npm start</code>的时候有报出了错误。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ERROR <span class=\"keyword\">in</span> multi main</span><br><span class=\"line\">Module <span class=\"keyword\">not</span> <span class=\"symbol\">found:</span> <span class=\"symbol\">Error:</span> Cannot resolve <span class=\"class\"><span class=\"keyword\">module</span> '<span class=\"title\">webpack</span>/<span class=\"title\">hot</span>/<span class=\"title\">dev</span>-<span class=\"title\">server</span>' <span class=\"title\">in</span> /<span class=\"title\">Users</span>/<span class=\"title\">yatessss</span>/<span class=\"title\">webpack</span></span></span><br><span class=\"line\"> @ multi main</span><br></pre></td></tr></table></figure>\n<p>大概的意思我查了一下，就是说模块无法解析，目前为止这个坑还没有填平。但是这不影响我们继续往下进行，这一部分是可以让服务器监听文件的变化的，在我们不刷新页面的时候，内容也会随着文件的变化做出相应的修改。</p>\n<p>我现在猜测这个错误的出现可能有两个原因。第一，就是在解决上一个环境变量的错误的时候，设置了路径，导致路径更改后找不到这个模块。第二，这个模块没有正确安装（但是我已经安装了很多遍）。</p>\n<p>我最后解决了这个问题。解决方法是受到了这个问题的启发<a href=\"http://stackoverflow.com/questions/29290301/cant-get-webpack-hot-module-replacement-to-work\">点击这里</a>，这里不得不说stackoverflow这个网站真的是很好的。</p>\n<p>这里我只改动了知乎这篇文章的设置的两个地方（其实把他们删掉应该也是可以的），在stackoverflow这个问题里有这样一句话：<code>--hot option is looking for some files locally</code>，这里是说<code>--hot</code>这个参数是设置在当前目录寻找一些文件的，而我们设置过环境变量，我在猜想是不是设置过变量后，所以我不能在当前找到这个模块了，所以我试着把<code>config</code>文件中<code>devServer</code>配置项中的<code>hot</code>改为了<code>false</code>，如下：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">devServer:</span> &#123;</span><br><span class=\"line\">        <span class=\"symbol\">historyApiFallback:</span> <span class=\"keyword\">true</span>,</span><br><span class=\"line\">        <span class=\"symbol\">hot:</span> <span class=\"keyword\">false</span>,</span><br><span class=\"line\">        <span class=\"symbol\">inline:</span> <span class=\"keyword\">true</span>,</span><br><span class=\"line\">        <span class=\"symbol\">progress:</span> <span class=\"keyword\">true</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>把<code>package.json</code>文件中的<code>scripts</code>配置项改为<code>&quot;start&quot;: &quot;webpack-dev-server --inline&quot;</code>，如下：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"scripts\"</span><span class=\"symbol\">:</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">\"start\"</span><span class=\"symbol\">:</span> <span class=\"string\">\"webpack-dev-server --inline\"</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这样，我们就禁止了他只在项目目录中寻找文件，在当前目录中没有找到的话，他会寻找根目录，经过试验，我的想法得到了证实，这样改动之后，<code>npm start</code>命令可以正常运行了。</p>\n<p>这个问题也算是有了解决方法。</p>\n<hr>\n<h3 id=\"添加CSS样式\"><a href=\"#添加CSS样式\" class=\"headerlink\" title=\"添加CSS样式\"></a>添加CSS样式</h3><p>在添加css样式这部分，没有问题。但是在配置css预编译程序sass的时候，遇到了两个错误。第一个错误是说我没有安装<code>node-sass</code>，这时候我们安装node-sass就好了；第二个错误我没有记录下来，大概是说<code>我的node-sass的版本和目前node不匹配</code>，而且错误当中也给出了解决办法，只要运行<code>npm rebuild node-sass</code>等一会之后，这个错误就可以解决了。</p>\n<hr>\n<h3 id=\"添加第三方库\"><a href=\"#添加第三方库\" class=\"headerlink\" title=\"添加第三方库\"></a>添加第三方库</h3><p>再添加第三方库的时候，按照步骤没有什么大的问题，只是有时候缺少一些依赖的库，比如遇到下面这种情况。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">├── UNMET PEER DEPENDENCY file-loader@*</span><br><span class=\"line\">├── jquery@2.<span class=\"number\">2.0</span></span><br><span class=\"line\">├── moment@2.<span class=\"number\">11.1</span></span><br><span class=\"line\">└── UNMET PEER DEPENDENCY webpack@^<span class=\"number\">1.12</span>.<span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n<p>这样的话就是缺少<code>file-loader</code> 这个依赖的库，所以只要安装这个库就好了。</p>\n<p>以上，就是我学习webpack第一部分碰到的一些问题，总结来加深印象。</p>\n"},{"layout":"post","title":"ES6学习笔记(数组的扩展)","date":"2016-01-31T16:00:00.000Z","_content":"\n每次总结其实都是把阮大大的东西先看了一遍，然后又总结一遍，加深印象而已，其实看原文更详细[这里](http://es6.ruanyifeng.com/#docs/array)。\n\n### 1. Array.from()\n\n`Array.from()`方法可以用于将两类对象转为真正的数组：类似数组的对象和可比案例的对象。\n\n```js\n\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n\n```\n\n只要是部署了Iterator接口的数据结构，`Array.from()`都能把他转为数组。\n\n注：Iterator是一种接口，为各种不痛的数据结构提供统一的访问机制，即任何数据结构只要有Iterator的话都可以完成遍历操作。这个在后面会详细的学到。[这里](http://es6.ruanyifeng.com/#docs/iterator)\n\n```js\n\nArray.from('hello')\n// ['h', 'e', 'l', 'l', 'o']\n\nlet namesSet = new Set(['a', 'b'])\nArray.from(namesSet) // ['a', 'b']\n\n```\n\n如上，字符串和Set结构都具有Iterator接口，都可以转为真正的数组。\n\n一个数组也可以用`Array.from`方法，只不过返回的是一个一样的**新**数组。\n\n任何有`length`属性的对象，都可以通过`Array.from`方法转为数组。\n\n```js\n\nArray.from({ length: 3 });\n// [ undefined, undefined, undefinded ]\n\n```\n\n如上，就算这个对象只有一个属性，而没有键值对，还是会返回一个成员都为`undefined`的数组。\n\n对于还没有部署这个方法的浏览器，可以用`Array.prototype.slice`方法代替。\n\n```js\n\nconst toArray = (() =>\n  Array.from ? Array.from : obj => [].slice.call(obj)\n)();\n\n```\n\n`Array.from`还可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值返回为一个数组。\n\n```js\n\nArray.from(arrayLike, x => x * x);\n// 等同于\nArray.from(arrayLike).map(x => x * x);\n\nArray.from([1, 2, 3], (x) => x * x)\n// [1, 4, 9]\n\n```\n\n下面的例子是取出一组DOM节点的文本内容。\n\n```js\n\n//h5自带的一种选择器\nlet spans = document.querySelectorAll('span.name');\n\n// map()\nlet names1 = Array.prototype.map.call(spans, s => s.textContent);\n\n// Array.from()\nlet names2 = Array.from(spans, s => s.textContent)\n\n```\n\n下面的例子是将数组中布尔值为`false`的成员转为`0`。\n\n```js\n\nArray.from([1, , 2, , 3], (n) => n || 0)\n// [1, 0, 2, 0, 3]\n\n```\n\n下面的例子是返回各种数据的类型。\n\n```js\n\nfunction typesOf () {\n  return Array.from(arguments, value => typeof value)\n}\ntypesOf(null, [], NaN)\n// ['object', 'object', 'number']\n\n```\n\n`Array.from()`的另一个应用是，可以将字符串转为数组。然后返回字符串的长度。因为他能正确处理各种Unicode字符。\n\n```js\n\nfunction countSymbols(string) {\n  return Array.from(string).length;\n}\n\n```\n\n*****\n\n### 2. Array.of()\n\n`Array.of()`方法用于将一组值，转换为数组。\n\n```js\n\nArray.of(3, 11, 8) // [3,11,8]\nArray.of(3) // [3]\nArray.of(3).length // 1\n\n```\n\n这个方法主要是为了弥补数组构造函数`Array()`的不足。因为参数个数的不同，`Array()`返回的数组有差异。\n\n```js\n\nArray() // []\nArray(3) // [, , ,]\nArray(3, 11, 8) // [3, 11, 8]\n\n```\n\n如上可以看出，当参数是一个的时候，其实是指定数组的长度；当参数不少于2个的时候，`Array()`才会返回一个新的数组。\n\n而`Array.of()`不会存在参数不同的行为差异，所以可以替代`Array()`。\n\n```js\n\nArray.of() // []\nArray.of(undefined) // [undefined]\nArray.of(1) // [1]\nArray.of(1, 2) // [1, 2]\n\n```\n\n`Array.of`方法可以用下面的代码模拟实现。\n\n```js\n\nfunction ArrayOf(){\n  return [].slice.call(arguments);\n}\n\n```\n\n*****\n\n### 3. 数组实例的copyWithin()\n\n数组实例的`copyWithin()`方法，会在原数组上进行操作，所以使用这个方法，会修改当前数组。\n\n```js\n\nArray.prototype.copyWithin(target, start = 0, end = this.length)\n\n```\n\n他接受三个参数：\n\n1. target（必须）：从该位置开始替换数据。\n2. start（可选）：从该位置开始读取数据，默认为0。如果是负数，表示倒数。\n3. end（可选）：到该位置停止读取数据，默认等于数组长度。如果为负数，表示倒数。\n\n```js\n\n[1, 2, 3, 4, 5].copyWithin(0, 3)\n// [4, 5, 3, 4, 5]\n\n```\n\n如上代码，这个表示把3号位置到数组结束的成员（4和5），复制到从0号开始的位置，替换掉原来的1和2。\n\n更多例子：\n\n```js\n\n// 将3号位复制到0号位\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4)\n// [4, 2, 3, 4, 5]\n\n// -2相当于3号位，-1相当于4号位\n[1, 2, 3, 4, 5].copyWithin(0, -2, -1)\n// [4, 2, 3, 4, 5]\n\n// 将3号位复制到0号位\n[].copyWithin.call({length: 5, 3: 1}, 0, 3)\n// {0: 1, 3: 1, length: 5}\n\n// 将2号位到数组结束，复制到0号位\nvar i32a = new Int32Array([1, 2, 3, 4, 5]);\ni32a.copyWithin(0, 2);\n// Int32Array [3, 4, 5, 4, 5]\n\n// 对于没有部署TypedArray的copyWithin方法的平台\n// 需要采用下面的写法\n[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);\n\n```\n\n*****\n\n### 4. 数组实例的find()和findIndex()\n\n数组实例的`find()`方法，用于找出**第一个**符合条件的数组成员。他的参数是一个回调函数，所有数组的成员依次执行这个回调函数，直到找出一个返回值为`ture`的成员，然后返回该成员，如果没有符合条件的就返回`undefined`。\n\n```js\n\n[1, 4, -5, 10].find((n) => n < 0)\n// -5\n\n```\n\n如上是找到了第一个小于0的成员。\n\n```js\n\n[1, 5, 10, 15].find(function(value, index, arr) {\n  return value > 9;\n}) // 10\n\n```\n\n如上代码，是找到了第一个大于9的成员。\n\n数组实例的`findIndex`方法的用法和`find`方法非常类似，他会犯的是第一个符合条件的成员在数组中的位置。只是如果成员都不符合条件，他返回的是`-1`。\n\n```js\n\n[1, 5, 10, 15].findIndex(function(value, index, arr) {\n  return value > 9;\n}) // 2\n\n```\n\n这两个方法也都可以发现`NaN`，弥补了`IndexOf`方法的不足。\n\n```js\n\n[NaN].indexOf(NaN)\n// -1\n\n[NaN].findIndex(y => Object.is(NaN, y))\n// 0\n\n```\n\n******\n\n### 5. 数组实例的fill()\n\n`fill`方法可以用给定的值填充一个数组。\n\n```js\n\n['a', 'b', 'c'].fill(7)\n// [7, 7, 7]\n\nnew Array(3).fill(7)\n// [7, 7, 7]\n\n```\n\n如上代码，`fill`方法可以用于空数组的初始化。如果数组中已有元素，会被全部替换掉。\n\n`fill`方法接受两个可选参数，用于指定起始位置和结束位置。\n\n```js\n\n['a', 'b', 'c'].fill(7, 1, 2)\n// ['a', 7, 'c']\n\n```\n\n******\n\n### 6. 数组实例的entries()，keys()和values()\n\nES6提供三个新的方法——`entries()`，`keys()`和`values()`，用于遍历数组。他们都会返回一个遍历器对象。可以用`for...of`进行循环遍历，唯一的区别是`keys()`是对键名遍历、`values()`是对键值进行遍历、`entries()`是对键值对进行遍历。\n\n```js\n\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n\n```\n\n*****\n\n### 7. 数组实例的includes()\n\n`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似。此方法属于ES7，但是Babel转码器已经支持。\n\n```js\n\n[1, 2, 3].includes(2);     // true\n[1, 2, 3].includes(4);     // false\n[1, 2, NaN].includes(NaN); // true\n\n```\n\n该方法的第二个参数搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果倒数的大于数组的长度，则会重置为0开始。\n\n```js\n\n[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n\n```\n\n在没有这个方法之前，我们通常使用数组的`indexOf`方法，检查是否包含某个值。\n\n```js\n\nif (arr.indexOf(el) !== -1) {\n  // ...\n}\n\n```\n\n但是`indexOf`方法有两个缺点，一是不够语义化，表达起来不够直观，二是，可能会对NaN产生误判。\n\n```js\n\n[NaN].indexOf(NaN)\n// -1\n\n```\n\n但是使用`includes`方法的是不一样的判断算法，不会产生误判。\n\n```js\n\n[NaN].includes(NaN)\n// true\n\n```\n\n*****\n\n### 8. 数组的空位\n\n数组的空位，是指数组的某一个位置没有任何值，比如`Array`构造函数返回的数组都是空位。\n\n```js\n\nArray(3) // [, , ,]\n\n```\n\n这里要注意，空位不是`undefined`，空位是没有任何值。请看下面代码。\n\n```js\n\n0 in [undefined, undefined, undefined] // true\n0 in [, , ,] // false\n\n```\n\n如上代码，数组一，尽管是`undefined`但是依然是有值的，而数组二的0号位置没有值。\n\nES5对空位的处理，是很不一致的，大多数情况会忽略空位。\n\n1. `forEach()`, `filter()`, `every()`和`some()`都会跳过空位。\n2. `map()`会跳过空位，但会保留这个值。\n3. `join()`和`toString()`会将空位视为undefined，而undefined和null会被处理成空字符串。\n\n```js\n\n// forEach方法\n[,'a'].forEach((x,i) => log(i)); // 1\n\n// filter方法\n['a',,'b'].filter(x => true) // ['a','b']\n\n// every方法\n[,'a'].every(x => x==='a') // true\n\n// some方法\n[,'a'].some(x => x !== 'a') // false\n\n// map方法\n[,'a'].map(x => 1) // [,1]\n\n// join方法\n[,'a',undefined,null].join('#') // \"#a##\"\n\n// toString方法\n[,'a',undefined,null].toString() // \",a,,\"\n\n```\n\n\u0010而ES6则明确将空位转为`undefined`。\n\n`Array.from`方法会将数组的空位，转为`undefined`，也就是说这个方法不会忽略空位。\n\n```js\n\nArray.from(['a',,'b'])\n// [ \"a\", undefined, \"b\" ]\n\n```\n\n扩展运算符(`...`)也会将空位转为`undefined`。\n\n```js\n\n[...['a',,'b']]\n// [ \"a\", undefined, \"b\" ]\n\n```\n\n`copyWithin()`会连空位一起拷贝。\n\n```js\n\n[,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"]\n\n```\n\n`fill()`会将空位视为正常的数组位置。\n\n```js\n\nnew Array(3).fill('a') // [\"a\",\"a\",\"a\"]\n\n```\n\n`for...of`循环也会遍历空位。\n\n```js\n\nlet arr = [, ,];\nfor (let i of arr) {\n  console.log(1);\n}\n// 1\n// 1\n\n```\n\n如上代码，数组`arr`有两个空位，`for...of`并没有忽略他们。如果改成`map`方法遍历，空位是会跳过的。\n\n******\n\n### 9. 数组推导\n\n数组推导提供了简洁写法，可以通过现有数组生成新数组。ES7会有折现功能，现在Bable转码器已经支持这个功能。\n\n```js\n\nvar a1 = [1, 2, 3, 4];\nvar a2 = [for (i of a1) i * 2];\n\na2 // [2, 4, 6, 8]\n\n```\n\n如上代码，通过`for...of`可能在`a1`的基础上生成`a2`。\n\n在数组推导中，`for...of`结构总是鞋在最前面，返回的表达式写在最后面。\n\n```js\n\nvar years = [ 1954, 1974, 1990, 2006, 2010, 2014 ];\n\n[for (year of years) if (year > 2000) year];\n// [ 2006, 2010, 2014 ]\n\n[for (year of years) if (year > 2000) if(year < 2010) year];\n// [ 2006]\n\n[for (year of years) if (year > 2000 && year < 2010) year];\n// [ 2006]\n\n```\n\n如上代码，`if`语句要卸载`for...of`与返回的表达式之间，而且可以多个`if`语句连用。\n\n再多举一个例子。\n\n```js\n\nvar customers = [\n  {\n    name: 'Jack',\n    age: 25,\n    city: 'New York'\n  },\n  {\n    name: 'Peter',\n    age: 30,\n    city: 'Seattle'\n  }\n];\n\nvar results = [\n  for (c of customers)\n    if (c.city == \"Seattle\")\n      { name: c.name, age: c.age }\n];\nresults // { name: \"Peter\", age: 30 }\n\n```\n\n数组推导可以替代`map`和`filter`方法。\n\n```js\n\n[for (i of [1, 2, 3]) i * i];\n// 等价于\n[1, 2, 3].map(function (i) { return i * i });\n\n[for (i of [1,4,2,3,-8]) if (i < 3) i];\n// 等价于\n[1,4,2,3,-8].filter(function(i) { return i < 3 });\n\n```\n\n如上代码，模拟`map`功能只要单纯的`for...of`循环就可以了，如果模拟`filter`除了循环，还要加上`if`语句。\n\n在一个数组推到中，还可以使用多个`for...of`构成多重循环。\n\n```js\n\nvar a1 = ['x1', 'y1'];\nvar a2 = ['x2', 'y2'];\nvar a3 = ['x3', 'y3'];\n\n[for (s of a1) for (w of a2) for (r of a3) console.log(s + w + r)];\n// x1x2x3\n// x1x2y3\n// x1y2x3\n// x1y2y3\n// y1x2x3\n// y1x2y3\n// y1y2x3\n// y1y2y3\n\n```\n\n字符串可以视为数组，所以字符串也可以直接用于数组推导。\n\n```js\n\n[for (c of 'abcde') if (/[aeiou]/.test(c)) c].join('') // 'ae'\n\n[for (c of 'abcde') c+'0'].join('') // 'a0b0c0d0e0'\n\n```\n\n*****\n\n","source":"_posts/2016-02-01-ES6study-3.md","raw":"---\nlayout: post\ntitle: ES6学习笔记(数组的扩展)\ndate: 2016-02-01\ntags: [ES6]\ncategories: ES6\n---\n\n每次总结其实都是把阮大大的东西先看了一遍，然后又总结一遍，加深印象而已，其实看原文更详细[这里](http://es6.ruanyifeng.com/#docs/array)。\n\n### 1. Array.from()\n\n`Array.from()`方法可以用于将两类对象转为真正的数组：类似数组的对象和可比案例的对象。\n\n```js\n\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n\n```\n\n只要是部署了Iterator接口的数据结构，`Array.from()`都能把他转为数组。\n\n注：Iterator是一种接口，为各种不痛的数据结构提供统一的访问机制，即任何数据结构只要有Iterator的话都可以完成遍历操作。这个在后面会详细的学到。[这里](http://es6.ruanyifeng.com/#docs/iterator)\n\n```js\n\nArray.from('hello')\n// ['h', 'e', 'l', 'l', 'o']\n\nlet namesSet = new Set(['a', 'b'])\nArray.from(namesSet) // ['a', 'b']\n\n```\n\n如上，字符串和Set结构都具有Iterator接口，都可以转为真正的数组。\n\n一个数组也可以用`Array.from`方法，只不过返回的是一个一样的**新**数组。\n\n任何有`length`属性的对象，都可以通过`Array.from`方法转为数组。\n\n```js\n\nArray.from({ length: 3 });\n// [ undefined, undefined, undefinded ]\n\n```\n\n如上，就算这个对象只有一个属性，而没有键值对，还是会返回一个成员都为`undefined`的数组。\n\n对于还没有部署这个方法的浏览器，可以用`Array.prototype.slice`方法代替。\n\n```js\n\nconst toArray = (() =>\n  Array.from ? Array.from : obj => [].slice.call(obj)\n)();\n\n```\n\n`Array.from`还可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值返回为一个数组。\n\n```js\n\nArray.from(arrayLike, x => x * x);\n// 等同于\nArray.from(arrayLike).map(x => x * x);\n\nArray.from([1, 2, 3], (x) => x * x)\n// [1, 4, 9]\n\n```\n\n下面的例子是取出一组DOM节点的文本内容。\n\n```js\n\n//h5自带的一种选择器\nlet spans = document.querySelectorAll('span.name');\n\n// map()\nlet names1 = Array.prototype.map.call(spans, s => s.textContent);\n\n// Array.from()\nlet names2 = Array.from(spans, s => s.textContent)\n\n```\n\n下面的例子是将数组中布尔值为`false`的成员转为`0`。\n\n```js\n\nArray.from([1, , 2, , 3], (n) => n || 0)\n// [1, 0, 2, 0, 3]\n\n```\n\n下面的例子是返回各种数据的类型。\n\n```js\n\nfunction typesOf () {\n  return Array.from(arguments, value => typeof value)\n}\ntypesOf(null, [], NaN)\n// ['object', 'object', 'number']\n\n```\n\n`Array.from()`的另一个应用是，可以将字符串转为数组。然后返回字符串的长度。因为他能正确处理各种Unicode字符。\n\n```js\n\nfunction countSymbols(string) {\n  return Array.from(string).length;\n}\n\n```\n\n*****\n\n### 2. Array.of()\n\n`Array.of()`方法用于将一组值，转换为数组。\n\n```js\n\nArray.of(3, 11, 8) // [3,11,8]\nArray.of(3) // [3]\nArray.of(3).length // 1\n\n```\n\n这个方法主要是为了弥补数组构造函数`Array()`的不足。因为参数个数的不同，`Array()`返回的数组有差异。\n\n```js\n\nArray() // []\nArray(3) // [, , ,]\nArray(3, 11, 8) // [3, 11, 8]\n\n```\n\n如上可以看出，当参数是一个的时候，其实是指定数组的长度；当参数不少于2个的时候，`Array()`才会返回一个新的数组。\n\n而`Array.of()`不会存在参数不同的行为差异，所以可以替代`Array()`。\n\n```js\n\nArray.of() // []\nArray.of(undefined) // [undefined]\nArray.of(1) // [1]\nArray.of(1, 2) // [1, 2]\n\n```\n\n`Array.of`方法可以用下面的代码模拟实现。\n\n```js\n\nfunction ArrayOf(){\n  return [].slice.call(arguments);\n}\n\n```\n\n*****\n\n### 3. 数组实例的copyWithin()\n\n数组实例的`copyWithin()`方法，会在原数组上进行操作，所以使用这个方法，会修改当前数组。\n\n```js\n\nArray.prototype.copyWithin(target, start = 0, end = this.length)\n\n```\n\n他接受三个参数：\n\n1. target（必须）：从该位置开始替换数据。\n2. start（可选）：从该位置开始读取数据，默认为0。如果是负数，表示倒数。\n3. end（可选）：到该位置停止读取数据，默认等于数组长度。如果为负数，表示倒数。\n\n```js\n\n[1, 2, 3, 4, 5].copyWithin(0, 3)\n// [4, 5, 3, 4, 5]\n\n```\n\n如上代码，这个表示把3号位置到数组结束的成员（4和5），复制到从0号开始的位置，替换掉原来的1和2。\n\n更多例子：\n\n```js\n\n// 将3号位复制到0号位\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4)\n// [4, 2, 3, 4, 5]\n\n// -2相当于3号位，-1相当于4号位\n[1, 2, 3, 4, 5].copyWithin(0, -2, -1)\n// [4, 2, 3, 4, 5]\n\n// 将3号位复制到0号位\n[].copyWithin.call({length: 5, 3: 1}, 0, 3)\n// {0: 1, 3: 1, length: 5}\n\n// 将2号位到数组结束，复制到0号位\nvar i32a = new Int32Array([1, 2, 3, 4, 5]);\ni32a.copyWithin(0, 2);\n// Int32Array [3, 4, 5, 4, 5]\n\n// 对于没有部署TypedArray的copyWithin方法的平台\n// 需要采用下面的写法\n[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);\n\n```\n\n*****\n\n### 4. 数组实例的find()和findIndex()\n\n数组实例的`find()`方法，用于找出**第一个**符合条件的数组成员。他的参数是一个回调函数，所有数组的成员依次执行这个回调函数，直到找出一个返回值为`ture`的成员，然后返回该成员，如果没有符合条件的就返回`undefined`。\n\n```js\n\n[1, 4, -5, 10].find((n) => n < 0)\n// -5\n\n```\n\n如上是找到了第一个小于0的成员。\n\n```js\n\n[1, 5, 10, 15].find(function(value, index, arr) {\n  return value > 9;\n}) // 10\n\n```\n\n如上代码，是找到了第一个大于9的成员。\n\n数组实例的`findIndex`方法的用法和`find`方法非常类似，他会犯的是第一个符合条件的成员在数组中的位置。只是如果成员都不符合条件，他返回的是`-1`。\n\n```js\n\n[1, 5, 10, 15].findIndex(function(value, index, arr) {\n  return value > 9;\n}) // 2\n\n```\n\n这两个方法也都可以发现`NaN`，弥补了`IndexOf`方法的不足。\n\n```js\n\n[NaN].indexOf(NaN)\n// -1\n\n[NaN].findIndex(y => Object.is(NaN, y))\n// 0\n\n```\n\n******\n\n### 5. 数组实例的fill()\n\n`fill`方法可以用给定的值填充一个数组。\n\n```js\n\n['a', 'b', 'c'].fill(7)\n// [7, 7, 7]\n\nnew Array(3).fill(7)\n// [7, 7, 7]\n\n```\n\n如上代码，`fill`方法可以用于空数组的初始化。如果数组中已有元素，会被全部替换掉。\n\n`fill`方法接受两个可选参数，用于指定起始位置和结束位置。\n\n```js\n\n['a', 'b', 'c'].fill(7, 1, 2)\n// ['a', 7, 'c']\n\n```\n\n******\n\n### 6. 数组实例的entries()，keys()和values()\n\nES6提供三个新的方法——`entries()`，`keys()`和`values()`，用于遍历数组。他们都会返回一个遍历器对象。可以用`for...of`进行循环遍历，唯一的区别是`keys()`是对键名遍历、`values()`是对键值进行遍历、`entries()`是对键值对进行遍历。\n\n```js\n\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n\n```\n\n*****\n\n### 7. 数组实例的includes()\n\n`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似。此方法属于ES7，但是Babel转码器已经支持。\n\n```js\n\n[1, 2, 3].includes(2);     // true\n[1, 2, 3].includes(4);     // false\n[1, 2, NaN].includes(NaN); // true\n\n```\n\n该方法的第二个参数搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果倒数的大于数组的长度，则会重置为0开始。\n\n```js\n\n[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n\n```\n\n在没有这个方法之前，我们通常使用数组的`indexOf`方法，检查是否包含某个值。\n\n```js\n\nif (arr.indexOf(el) !== -1) {\n  // ...\n}\n\n```\n\n但是`indexOf`方法有两个缺点，一是不够语义化，表达起来不够直观，二是，可能会对NaN产生误判。\n\n```js\n\n[NaN].indexOf(NaN)\n// -1\n\n```\n\n但是使用`includes`方法的是不一样的判断算法，不会产生误判。\n\n```js\n\n[NaN].includes(NaN)\n// true\n\n```\n\n*****\n\n### 8. 数组的空位\n\n数组的空位，是指数组的某一个位置没有任何值，比如`Array`构造函数返回的数组都是空位。\n\n```js\n\nArray(3) // [, , ,]\n\n```\n\n这里要注意，空位不是`undefined`，空位是没有任何值。请看下面代码。\n\n```js\n\n0 in [undefined, undefined, undefined] // true\n0 in [, , ,] // false\n\n```\n\n如上代码，数组一，尽管是`undefined`但是依然是有值的，而数组二的0号位置没有值。\n\nES5对空位的处理，是很不一致的，大多数情况会忽略空位。\n\n1. `forEach()`, `filter()`, `every()`和`some()`都会跳过空位。\n2. `map()`会跳过空位，但会保留这个值。\n3. `join()`和`toString()`会将空位视为undefined，而undefined和null会被处理成空字符串。\n\n```js\n\n// forEach方法\n[,'a'].forEach((x,i) => log(i)); // 1\n\n// filter方法\n['a',,'b'].filter(x => true) // ['a','b']\n\n// every方法\n[,'a'].every(x => x==='a') // true\n\n// some方法\n[,'a'].some(x => x !== 'a') // false\n\n// map方法\n[,'a'].map(x => 1) // [,1]\n\n// join方法\n[,'a',undefined,null].join('#') // \"#a##\"\n\n// toString方法\n[,'a',undefined,null].toString() // \",a,,\"\n\n```\n\n\u0010而ES6则明确将空位转为`undefined`。\n\n`Array.from`方法会将数组的空位，转为`undefined`，也就是说这个方法不会忽略空位。\n\n```js\n\nArray.from(['a',,'b'])\n// [ \"a\", undefined, \"b\" ]\n\n```\n\n扩展运算符(`...`)也会将空位转为`undefined`。\n\n```js\n\n[...['a',,'b']]\n// [ \"a\", undefined, \"b\" ]\n\n```\n\n`copyWithin()`会连空位一起拷贝。\n\n```js\n\n[,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"]\n\n```\n\n`fill()`会将空位视为正常的数组位置。\n\n```js\n\nnew Array(3).fill('a') // [\"a\",\"a\",\"a\"]\n\n```\n\n`for...of`循环也会遍历空位。\n\n```js\n\nlet arr = [, ,];\nfor (let i of arr) {\n  console.log(1);\n}\n// 1\n// 1\n\n```\n\n如上代码，数组`arr`有两个空位，`for...of`并没有忽略他们。如果改成`map`方法遍历，空位是会跳过的。\n\n******\n\n### 9. 数组推导\n\n数组推导提供了简洁写法，可以通过现有数组生成新数组。ES7会有折现功能，现在Bable转码器已经支持这个功能。\n\n```js\n\nvar a1 = [1, 2, 3, 4];\nvar a2 = [for (i of a1) i * 2];\n\na2 // [2, 4, 6, 8]\n\n```\n\n如上代码，通过`for...of`可能在`a1`的基础上生成`a2`。\n\n在数组推导中，`for...of`结构总是鞋在最前面，返回的表达式写在最后面。\n\n```js\n\nvar years = [ 1954, 1974, 1990, 2006, 2010, 2014 ];\n\n[for (year of years) if (year > 2000) year];\n// [ 2006, 2010, 2014 ]\n\n[for (year of years) if (year > 2000) if(year < 2010) year];\n// [ 2006]\n\n[for (year of years) if (year > 2000 && year < 2010) year];\n// [ 2006]\n\n```\n\n如上代码，`if`语句要卸载`for...of`与返回的表达式之间，而且可以多个`if`语句连用。\n\n再多举一个例子。\n\n```js\n\nvar customers = [\n  {\n    name: 'Jack',\n    age: 25,\n    city: 'New York'\n  },\n  {\n    name: 'Peter',\n    age: 30,\n    city: 'Seattle'\n  }\n];\n\nvar results = [\n  for (c of customers)\n    if (c.city == \"Seattle\")\n      { name: c.name, age: c.age }\n];\nresults // { name: \"Peter\", age: 30 }\n\n```\n\n数组推导可以替代`map`和`filter`方法。\n\n```js\n\n[for (i of [1, 2, 3]) i * i];\n// 等价于\n[1, 2, 3].map(function (i) { return i * i });\n\n[for (i of [1,4,2,3,-8]) if (i < 3) i];\n// 等价于\n[1,4,2,3,-8].filter(function(i) { return i < 3 });\n\n```\n\n如上代码，模拟`map`功能只要单纯的`for...of`循环就可以了，如果模拟`filter`除了循环，还要加上`if`语句。\n\n在一个数组推到中，还可以使用多个`for...of`构成多重循环。\n\n```js\n\nvar a1 = ['x1', 'y1'];\nvar a2 = ['x2', 'y2'];\nvar a3 = ['x3', 'y3'];\n\n[for (s of a1) for (w of a2) for (r of a3) console.log(s + w + r)];\n// x1x2x3\n// x1x2y3\n// x1y2x3\n// x1y2y3\n// y1x2x3\n// y1x2y3\n// y1y2x3\n// y1y2y3\n\n```\n\n字符串可以视为数组，所以字符串也可以直接用于数组推导。\n\n```js\n\n[for (c of 'abcde') if (/[aeiou]/.test(c)) c].join('') // 'ae'\n\n[for (c of 'abcde') c+'0'].join('') // 'a0b0c0d0e0'\n\n```\n\n*****\n\n","slug":"ES6study-3","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1yg000ssq5lbzkgaexm","content":"<p>每次总结其实都是把阮大大的东西先看了一遍，然后又总结一遍，加深印象而已，其实看原文更详细<a href=\"http://es6.ruanyifeng.com/#docs/array\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<h3 id=\"1-Array-from\"><a href=\"#1-Array-from\" class=\"headerlink\" title=\"1. Array.from()\"></a>1. Array.from()</h3><p><code>Array.from()</code>方法可以用于将两类对象转为真正的数组：类似数组的对象和可比案例的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</span><br><span class=\"line\">    <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">    <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">    <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">    length: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES5的写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [].slice.call(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6的写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"built_in\">Array</span>.from(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>\n<p>只要是部署了Iterator接口的数据结构，<code>Array.from()</code>都能把他转为数组。</p>\n<p>注：Iterator是一种接口，为各种不痛的数据结构提供统一的访问机制，即任何数据结构只要有Iterator的话都可以完成遍历操作。这个在后面会详细的学到。<a href=\"http://es6.ruanyifeng.com/#docs/iterator\" target=\"_blank\" rel=\"external\">这里</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\"><span class=\"comment\">// ['h', 'e', 'l', 'l', 'o']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> namesSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>])</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(namesSet) <span class=\"comment\">// ['a', 'b']</span></span><br></pre></td></tr></table></figure>\n<p>如上，字符串和Set结构都具有Iterator接口，都可以转为真正的数组。</p>\n<p>一个数组也可以用<code>Array.from</code>方法，只不过返回的是一个一样的<strong>新</strong>数组。</p>\n<p>任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(&#123; length: <span class=\"number\">3</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">// [ undefined, undefined, undefinded ]</span></span><br></pre></td></tr></table></figure>\n<p>如上，就算这个对象只有一个属性，而没有键值对，还是会返回一个成员都为<code>undefined</code>的数组。</p>\n<p>对于还没有部署这个方法的浏览器，可以用<code>Array.prototype.slice</code>方法代替。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> toArray = (() =&gt;</span><br><span class=\"line\">  <span class=\"built_in\">Array</span>.from ? <span class=\"built_in\">Array</span>.from : obj =&gt; [].slice.call(obj)</span><br><span class=\"line\">)();</span><br></pre></td></tr></table></figure>\n<p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值返回为一个数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike, x =&gt; x * x);</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike).map(x =&gt; x * x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], (x) =&gt; x * x)</span><br><span class=\"line\"><span class=\"comment\">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>\n<p>下面的例子是取出一组DOM节点的文本内容。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//h5自带的一种选择器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> spans = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'span.name'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map()</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> names1 = <span class=\"built_in\">Array</span>.prototype.map.call(spans, s =&gt; s.textContent);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array.from()</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> names2 = <span class=\"built_in\">Array</span>.from(spans, s =&gt; s.textContent)</span><br></pre></td></tr></table></figure>\n<p>下面的例子是将数组中布尔值为<code>false</code>的成员转为<code>0</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, , <span class=\"number\">2</span>, , <span class=\"number\">3</span>], (n) =&gt; n || <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// [1, 0, 2, 0, 3]</span></span><br></pre></td></tr></table></figure>\n<p>下面的例子是返回各种数据的类型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">typesOf</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>, value =&gt; <span class=\"keyword\">typeof</span> value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">typesOf(<span class=\"literal\">null</span>, [], <span class=\"literal\">NaN</span>)</span><br><span class=\"line\"><span class=\"comment\">// ['object', 'object', 'number']</span></span><br></pre></td></tr></table></figure>\n<p><code>Array.from()</code>的另一个应用是，可以将字符串转为数组。然后返回字符串的长度。因为他能正确处理各种Unicode字符。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countSymbols</span>(<span class=\"params\">string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(string).length;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"2-Array-of\"><a href=\"#2-Array-of\" class=\"headerlink\" title=\"2. Array.of()\"></a>2. Array.of()</h3><p><code>Array.of()</code>方法用于将一组值，转换为数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>) <span class=\"comment\">// [3,11,8]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>) <span class=\"comment\">// [3]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>).length <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>这个方法主要是为了弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，<code>Array()</code>返回的数组有差异。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>() <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>) <span class=\"comment\">// [, , ,]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>) <span class=\"comment\">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>\n<p>如上可以看出，当参数是一个的时候，其实是指定数组的长度；当参数不少于2个的时候，<code>Array()</code>才会返回一个新的数组。</p>\n<p>而<code>Array.of()</code>不会存在参数不同的行为差异，所以可以替代<code>Array()</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of() <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"literal\">undefined</span>) <span class=\"comment\">// [undefined]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>) <span class=\"comment\">// [1]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// [1, 2]</span></span><br></pre></td></tr></table></figure>\n<p><code>Array.of</code>方法可以用下面的代码模拟实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ArrayOf</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [].slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"3-数组实例的copyWithin\"><a href=\"#3-数组实例的copyWithin\" class=\"headerlink\" title=\"3. 数组实例的copyWithin()\"></a>3. 数组实例的copyWithin()</h3><p>数组实例的<code>copyWithin()</code>方法，会在原数组上进行操作，所以使用这个方法，会修改当前数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.copyWithin(target, start = <span class=\"number\">0</span>, end = <span class=\"keyword\">this</span>.length)</span><br></pre></td></tr></table></figure>\n<p>他接受三个参数：</p>\n<ol>\n<li>target（必须）：从该位置开始替换数据。</li>\n<li>start（可选）：从该位置开始读取数据，默认为0。如果是负数，表示倒数。</li>\n<li>end（可选）：到该位置停止读取数据，默认等于数组长度。如果为负数，表示倒数。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，这个表示把3号位置到数组结束的成员（4和5），复制到从0号开始的位置，替换掉原来的1和2。</p>\n<p>更多例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将3号位复制到0号位</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// [4, 2, 3, 4, 5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -2相当于3号位，-1相当于4号位</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">-2</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"comment\">// [4, 2, 3, 4, 5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将3号位复制到0号位</span></span><br><span class=\"line\">[].copyWithin.call(&#123;length: <span class=\"number\">5</span>, <span class=\"number\">3</span>: <span class=\"number\">1</span>&#125;, <span class=\"number\">0</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">// &#123;0: 1, 3: 1, length: 5&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将2号位到数组结束，复制到0号位</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i32a = <span class=\"keyword\">new</span> <span class=\"built_in\">Int32Array</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\">i32a.copyWithin(<span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// Int32Array [3, 4, 5, 4, 5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对于没有部署TypedArray的copyWithin方法的平台</span></span><br><span class=\"line\"><span class=\"comment\">// 需要采用下面的写法</span></span><br><span class=\"line\">[].copyWithin.call(<span class=\"keyword\">new</span> <span class=\"built_in\">Int32Array</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]), <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"4-数组实例的find-和findIndex\"><a href=\"#4-数组实例的find-和findIndex\" class=\"headerlink\" title=\"4. 数组实例的find()和findIndex()\"></a>4. 数组实例的find()和findIndex()</h3><p>数组实例的<code>find()</code>方法，用于找出<strong>第一个</strong>符合条件的数组成员。他的参数是一个回调函数，所有数组的成员依次执行这个回调函数，直到找出一个返回值为<code>ture</code>的成员，然后返回该成员，如果没有符合条件的就返回<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">-5</span>, <span class=\"number\">10</span>].find((n) =&gt; n &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// -5</span></span><br></pre></td></tr></table></figure>\n<p>如上是找到了第一个小于0的成员。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>].find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value &gt; <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;) <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，是找到了第一个大于9的成员。</p>\n<p>数组实例的<code>findIndex</code>方法的用法和<code>find</code>方法非常类似，他会犯的是第一个符合条件的成员在数组中的位置。只是如果成员都不符合条件，他返回的是<code>-1</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>].findIndex(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value &gt; <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>这两个方法也都可以发现<code>NaN</code>，弥补了<code>IndexOf</code>方法的不足。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"literal\">NaN</span>].indexOf(<span class=\"literal\">NaN</span>)</span><br><span class=\"line\"><span class=\"comment\">// -1</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"literal\">NaN</span>].findIndex(y =&gt; <span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, y))</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"5-数组实例的fill\"><a href=\"#5-数组实例的fill\" class=\"headerlink\" title=\"5. 数组实例的fill()\"></a>5. 数组实例的fill()</h3><p><code>fill</code>方法可以用给定的值填充一个数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].fill(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">// [7, 7, 7]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，<code>fill</code>方法可以用于空数组的初始化。如果数组中已有元素，会被全部替换掉。</p>\n<p><code>fill</code>方法接受两个可选参数，用于指定起始位置和结束位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].fill(<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"6-数组实例的entries-，keys-和values\"><a href=\"#6-数组实例的entries-，keys-和values\" class=\"headerlink\" title=\"6. 数组实例的entries()，keys()和values()\"></a>6. 数组实例的entries()，keys()和values()</h3><p>ES6提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>，用于遍历数组。他们都会返回一个遍历器对象。可以用<code>for...of</code>进行循环遍历，唯一的区别是<code>keys()</code>是对键名遍历、<code>values()</code>是对键值进行遍历、<code>entries()</code>是对键值对进行遍历。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].keys()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> elem <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].values()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 'a'</span></span><br><span class=\"line\"><span class=\"comment\">// 'b'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [index, elem] <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index, elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 0 \"a\"</span></span><br><span class=\"line\"><span class=\"comment\">// 1 \"b\"</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"7-数组实例的includes\"><a href=\"#7-数组实例的includes\" class=\"headerlink\" title=\"7. 数组实例的includes()\"></a>7. 数组实例的includes()</h3><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。此方法属于ES7，但是Babel转码器已经支持。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">2</span>);     <span class=\"comment\">// true</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">4</span>);     <span class=\"comment\">// false</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"literal\">NaN</span>].includes(<span class=\"literal\">NaN</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>该方法的第二个参数搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果倒数的大于数组的长度，则会重置为0开始。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">3</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// false</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">3</span>, <span class=\"number\">-1</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>在没有这个方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (arr.indexOf(el) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是<code>indexOf</code>方法有两个缺点，一是不够语义化，表达起来不够直观，二是，可能会对NaN产生误判。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"literal\">NaN</span>].indexOf(<span class=\"literal\">NaN</span>)</span><br><span class=\"line\"><span class=\"comment\">// -1</span></span><br></pre></td></tr></table></figure>\n<p>但是使用<code>includes</code>方法的是不一样的判断算法，不会产生误判。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"literal\">NaN</span>].includes(<span class=\"literal\">NaN</span>)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"8-数组的空位\"><a href=\"#8-数组的空位\" class=\"headerlink\" title=\"8. 数组的空位\"></a>8. 数组的空位</h3><p>数组的空位，是指数组的某一个位置没有任何值，比如<code>Array</code>构造函数返回的数组都是空位。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>) <span class=\"comment\">// [, , ,]</span></span><br></pre></td></tr></table></figure>\n<p>这里要注意，空位不是<code>undefined</code>，空位是没有任何值。请看下面代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"keyword\">in</span> [<span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>] <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"keyword\">in</span> [, , ,] <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，数组一，尽管是<code>undefined</code>但是依然是有值的，而数组二的0号位置没有值。</p>\n<p>ES5对空位的处理，是很不一致的，大多数情况会忽略空位。</p>\n<ol>\n<li><code>forEach()</code>, <code>filter()</code>, <code>every()</code>和<code>some()</code>都会跳过空位。</li>\n<li><code>map()</code>会跳过空位，但会保留这个值。</li>\n<li><code>join()</code>和<code>toString()</code>会将空位视为undefined，而undefined和null会被处理成空字符串。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// forEach方法</span></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>].forEach((x,i) =&gt; log(i)); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// filter方法</span></span><br><span class=\"line\">[<span class=\"string\">'a'</span>,,<span class=\"string\">'b'</span>].filter(x =&gt; <span class=\"literal\">true</span>) <span class=\"comment\">// ['a','b']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// every方法</span></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>].every(x =&gt; x===<span class=\"string\">'a'</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// some方法</span></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>].some(x =&gt; x !== <span class=\"string\">'a'</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map方法</span></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>].map(x =&gt; <span class=\"number\">1</span>) <span class=\"comment\">// [,1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// join方法</span></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>,<span class=\"literal\">undefined</span>,<span class=\"literal\">null</span>].join(<span class=\"string\">'#'</span>) <span class=\"comment\">// \"#a##\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// toString方法</span></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>,<span class=\"literal\">undefined</span>,<span class=\"literal\">null</span>].toString() <span class=\"comment\">// \",a,,\"</span></span><br></pre></td></tr></table></figure>\n<p>\u0010而ES6则明确将空位转为<code>undefined</code>。</p>\n<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说这个方法不会忽略空位。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"string\">'a'</span>,,<span class=\"string\">'b'</span>])</span><br><span class=\"line\"><span class=\"comment\">// [ \"a\", undefined, \"b\" ]</span></span><br></pre></td></tr></table></figure>\n<p>扩展运算符(<code>...</code>)也会将空位转为<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[...[<span class=\"string\">'a'</span>,,<span class=\"string\">'b'</span>]]</span><br><span class=\"line\"><span class=\"comment\">// [ \"a\", undefined, \"b\" ]</span></span><br></pre></td></tr></table></figure>\n<p><code>copyWithin()</code>会连空位一起拷贝。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,,].copyWithin(<span class=\"number\">2</span>,<span class=\"number\">0</span>) <span class=\"comment\">// [,\"a\",,\"a\"]</span></span><br></pre></td></tr></table></figure>\n<p><code>fill()</code>会将空位视为正常的数组位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"string\">'a'</span>) <span class=\"comment\">// [\"a\",\"a\",\"a\"]</span></span><br></pre></td></tr></table></figure>\n<p><code>for...of</code>循环也会遍历空位。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [, ,];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略他们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>\n<hr>\n<h3 id=\"9-数组推导\"><a href=\"#9-数组推导\" class=\"headerlink\" title=\"9. 数组推导\"></a>9. 数组推导</h3><p>数组推导提供了简洁写法，可以通过现有数组生成新数组。ES7会有折现功能，现在Bable转码器已经支持这个功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> a2 = [<span class=\"keyword\">for</span> (i <span class=\"keyword\">of</span> a1) i * <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">a2 <span class=\"comment\">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，通过<code>for...of</code>可能在<code>a1</code>的基础上生成<code>a2</code>。</p>\n<p>在数组推导中，<code>for...of</code>结构总是鞋在最前面，返回的表达式写在最后面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> years = [ <span class=\"number\">1954</span>, <span class=\"number\">1974</span>, <span class=\"number\">1990</span>, <span class=\"number\">2006</span>, <span class=\"number\">2010</span>, <span class=\"number\">2014</span> ];</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (year <span class=\"keyword\">of</span> years) <span class=\"keyword\">if</span> (year &gt; <span class=\"number\">2000</span>) year];</span><br><span class=\"line\"><span class=\"comment\">// [ 2006, 2010, 2014 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (year <span class=\"keyword\">of</span> years) <span class=\"keyword\">if</span> (year &gt; <span class=\"number\">2000</span>) <span class=\"keyword\">if</span>(year &lt; <span class=\"number\">2010</span>) year];</span><br><span class=\"line\"><span class=\"comment\">// [ 2006]</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (year <span class=\"keyword\">of</span> years) <span class=\"keyword\">if</span> (year &gt; <span class=\"number\">2000</span> &amp;&amp; year &lt; <span class=\"number\">2010</span>) year];</span><br><span class=\"line\"><span class=\"comment\">// [ 2006]</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，<code>if</code>语句要卸载<code>for...of</code>与返回的表达式之间，而且可以多个<code>if</code>语句连用。</p>\n<p>再多举一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> customers = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Jack'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">25</span>,</span><br><span class=\"line\">    city: <span class=\"string\">'New York'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Peter'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">30</span>,</span><br><span class=\"line\">    city: <span class=\"string\">'Seattle'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> results = [</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (c <span class=\"keyword\">of</span> customers)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c.city == <span class=\"string\">\"Seattle\"</span>)</span><br><span class=\"line\">      &#123; name: c.name, age: c.age &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\">results <span class=\"comment\">// &#123; name: \"Peter\", age: 30 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>数组推导可以替代<code>map</code>和<code>filter</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (i <span class=\"keyword\">of</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) i * i];</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i</span>) </span>&#123; <span class=\"keyword\">return</span> i * i &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (i <span class=\"keyword\">of</span> [<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">-8</span>]) <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">3</span>) i];</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">-8</span>].filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123; <span class=\"keyword\">return</span> i &lt; <span class=\"number\">3</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>如上代码，模拟<code>map</code>功能只要单纯的<code>for...of</code>循环就可以了，如果模拟<code>filter</code>除了循环，还要加上<code>if</code>语句。</p>\n<p>在一个数组推到中，还可以使用多个<code>for...of</code>构成多重循环。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a1 = [<span class=\"string\">'x1'</span>, <span class=\"string\">'y1'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> a2 = [<span class=\"string\">'x2'</span>, <span class=\"string\">'y2'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> a3 = [<span class=\"string\">'x3'</span>, <span class=\"string\">'y3'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (s <span class=\"keyword\">of</span> a1) <span class=\"keyword\">for</span> (w <span class=\"keyword\">of</span> a2) <span class=\"keyword\">for</span> (r <span class=\"keyword\">of</span> a3) <span class=\"built_in\">console</span>.log(s + w + r)];</span><br><span class=\"line\"><span class=\"comment\">// x1x2x3</span></span><br><span class=\"line\"><span class=\"comment\">// x1x2y3</span></span><br><span class=\"line\"><span class=\"comment\">// x1y2x3</span></span><br><span class=\"line\"><span class=\"comment\">// x1y2y3</span></span><br><span class=\"line\"><span class=\"comment\">// y1x2x3</span></span><br><span class=\"line\"><span class=\"comment\">// y1x2y3</span></span><br><span class=\"line\"><span class=\"comment\">// y1y2x3</span></span><br><span class=\"line\"><span class=\"comment\">// y1y2y3</span></span><br></pre></td></tr></table></figure>\n<p>字符串可以视为数组，所以字符串也可以直接用于数组推导。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (c <span class=\"keyword\">of</span> <span class=\"string\">'abcde'</span>) <span class=\"keyword\">if</span> (<span class=\"regexp\">/[aeiou]/</span>.test(c)) c].join(<span class=\"string\">''</span>) <span class=\"comment\">// 'ae'</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (c <span class=\"keyword\">of</span> <span class=\"string\">'abcde'</span>) c+<span class=\"string\">'0'</span>].join(<span class=\"string\">''</span>) <span class=\"comment\">// 'a0b0c0d0e0'</span></span><br></pre></td></tr></table></figure>\n<hr>\n","excerpt":"","more":"<p>每次总结其实都是把阮大大的东西先看了一遍，然后又总结一遍，加深印象而已，其实看原文更详细<a href=\"http://es6.ruanyifeng.com/#docs/array\">这里</a>。</p>\n<h3 id=\"1-Array-from\"><a href=\"#1-Array-from\" class=\"headerlink\" title=\"1. Array.from()\"></a>1. Array.from()</h3><p><code>Array.from()</code>方法可以用于将两类对象转为真正的数组：类似数组的对象和可比案例的对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</span><br><span class=\"line\">    <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">    <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">    <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">    length: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES5的写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [].slice.call(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6的写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"built_in\">Array</span>.from(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>\n<p>只要是部署了Iterator接口的数据结构，<code>Array.from()</code>都能把他转为数组。</p>\n<p>注：Iterator是一种接口，为各种不痛的数据结构提供统一的访问机制，即任何数据结构只要有Iterator的话都可以完成遍历操作。这个在后面会详细的学到。<a href=\"http://es6.ruanyifeng.com/#docs/iterator\">这里</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\"><span class=\"comment\">// ['h', 'e', 'l', 'l', 'o']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> namesSet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>])</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(namesSet) <span class=\"comment\">// ['a', 'b']</span></span><br></pre></td></tr></table></figure>\n<p>如上，字符串和Set结构都具有Iterator接口，都可以转为真正的数组。</p>\n<p>一个数组也可以用<code>Array.from</code>方法，只不过返回的是一个一样的<strong>新</strong>数组。</p>\n<p>任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(&#123; length: <span class=\"number\">3</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">// [ undefined, undefined, undefinded ]</span></span><br></pre></td></tr></table></figure>\n<p>如上，就算这个对象只有一个属性，而没有键值对，还是会返回一个成员都为<code>undefined</code>的数组。</p>\n<p>对于还没有部署这个方法的浏览器，可以用<code>Array.prototype.slice</code>方法代替。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> toArray = (() =&gt;</span><br><span class=\"line\">  <span class=\"built_in\">Array</span>.from ? <span class=\"built_in\">Array</span>.from : obj =&gt; [].slice.call(obj)</span><br><span class=\"line\">)();</span><br></pre></td></tr></table></figure>\n<p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值返回为一个数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike, x =&gt; x * x);</span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(arrayLike).map(x =&gt; x * x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], (x) =&gt; x * x)</span><br><span class=\"line\"><span class=\"comment\">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>\n<p>下面的例子是取出一组DOM节点的文本内容。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//h5自带的一种选择器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> spans = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'span.name'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map()</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> names1 = <span class=\"built_in\">Array</span>.prototype.map.call(spans, s =&gt; s.textContent);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array.from()</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> names2 = <span class=\"built_in\">Array</span>.from(spans, s =&gt; s.textContent)</span><br></pre></td></tr></table></figure>\n<p>下面的例子是将数组中布尔值为<code>false</code>的成员转为<code>0</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"number\">1</span>, , <span class=\"number\">2</span>, , <span class=\"number\">3</span>], (n) =&gt; n || <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// [1, 0, 2, 0, 3]</span></span><br></pre></td></tr></table></figure>\n<p>下面的例子是返回各种数据的类型。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">typesOf</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>, value =&gt; <span class=\"keyword\">typeof</span> value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">typesOf(<span class=\"literal\">null</span>, [], <span class=\"literal\">NaN</span>)</span><br><span class=\"line\"><span class=\"comment\">// ['object', 'object', 'number']</span></span><br></pre></td></tr></table></figure>\n<p><code>Array.from()</code>的另一个应用是，可以将字符串转为数组。然后返回字符串的长度。因为他能正确处理各种Unicode字符。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countSymbols</span>(<span class=\"params\">string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.from(string).length;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"2-Array-of\"><a href=\"#2-Array-of\" class=\"headerlink\" title=\"2. Array.of()\"></a>2. Array.of()</h3><p><code>Array.of()</code>方法用于将一组值，转换为数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>) <span class=\"comment\">// [3,11,8]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>) <span class=\"comment\">// [3]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">3</span>).length <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>这个方法主要是为了弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，<code>Array()</code>返回的数组有差异。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>() <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>) <span class=\"comment\">// [, , ,]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>, <span class=\"number\">11</span>, <span class=\"number\">8</span>) <span class=\"comment\">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>\n<p>如上可以看出，当参数是一个的时候，其实是指定数组的长度；当参数不少于2个的时候，<code>Array()</code>才会返回一个新的数组。</p>\n<p>而<code>Array.of()</code>不会存在参数不同的行为差异，所以可以替代<code>Array()</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of() <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"literal\">undefined</span>) <span class=\"comment\">// [undefined]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>) <span class=\"comment\">// [1]</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// [1, 2]</span></span><br></pre></td></tr></table></figure>\n<p><code>Array.of</code>方法可以用下面的代码模拟实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ArrayOf</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [].slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"3-数组实例的copyWithin\"><a href=\"#3-数组实例的copyWithin\" class=\"headerlink\" title=\"3. 数组实例的copyWithin()\"></a>3. 数组实例的copyWithin()</h3><p>数组实例的<code>copyWithin()</code>方法，会在原数组上进行操作，所以使用这个方法，会修改当前数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.copyWithin(target, start = <span class=\"number\">0</span>, end = <span class=\"keyword\">this</span>.length)</span><br></pre></td></tr></table></figure>\n<p>他接受三个参数：</p>\n<ol>\n<li>target（必须）：从该位置开始替换数据。</li>\n<li>start（可选）：从该位置开始读取数据，默认为0。如果是负数，表示倒数。</li>\n<li>end（可选）：到该位置停止读取数据，默认等于数组长度。如果为负数，表示倒数。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，这个表示把3号位置到数组结束的成员（4和5），复制到从0号开始的位置，替换掉原来的1和2。</p>\n<p>更多例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将3号位复制到0号位</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// [4, 2, 3, 4, 5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -2相当于3号位，-1相当于4号位</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].copyWithin(<span class=\"number\">0</span>, <span class=\"number\">-2</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"comment\">// [4, 2, 3, 4, 5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将3号位复制到0号位</span></span><br><span class=\"line\">[].copyWithin.call(&#123;length: <span class=\"number\">5</span>, <span class=\"number\">3</span>: <span class=\"number\">1</span>&#125;, <span class=\"number\">0</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\">// &#123;0: 1, 3: 1, length: 5&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将2号位到数组结束，复制到0号位</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i32a = <span class=\"keyword\">new</span> <span class=\"built_in\">Int32Array</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\">i32a.copyWithin(<span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// Int32Array [3, 4, 5, 4, 5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对于没有部署TypedArray的copyWithin方法的平台</span></span><br><span class=\"line\"><span class=\"comment\">// 需要采用下面的写法</span></span><br><span class=\"line\">[].copyWithin.call(<span class=\"keyword\">new</span> <span class=\"built_in\">Int32Array</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]), <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"4-数组实例的find-和findIndex\"><a href=\"#4-数组实例的find-和findIndex\" class=\"headerlink\" title=\"4. 数组实例的find()和findIndex()\"></a>4. 数组实例的find()和findIndex()</h3><p>数组实例的<code>find()</code>方法，用于找出<strong>第一个</strong>符合条件的数组成员。他的参数是一个回调函数，所有数组的成员依次执行这个回调函数，直到找出一个返回值为<code>ture</code>的成员，然后返回该成员，如果没有符合条件的就返回<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">-5</span>, <span class=\"number\">10</span>].find((n) =&gt; n &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">// -5</span></span><br></pre></td></tr></table></figure>\n<p>如上是找到了第一个小于0的成员。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>].find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value &gt; <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;) <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，是找到了第一个大于9的成员。</p>\n<p>数组实例的<code>findIndex</code>方法的用法和<code>find</code>方法非常类似，他会犯的是第一个符合条件的成员在数组中的位置。只是如果成员都不符合条件，他返回的是<code>-1</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">15</span>].findIndex(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, index, arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value &gt; <span class=\"number\">9</span>;</span><br><span class=\"line\">&#125;) <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>这两个方法也都可以发现<code>NaN</code>，弥补了<code>IndexOf</code>方法的不足。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"literal\">NaN</span>].indexOf(<span class=\"literal\">NaN</span>)</span><br><span class=\"line\"><span class=\"comment\">// -1</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"literal\">NaN</span>].findIndex(y =&gt; <span class=\"built_in\">Object</span>.is(<span class=\"literal\">NaN</span>, y))</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"5-数组实例的fill\"><a href=\"#5-数组实例的fill\" class=\"headerlink\" title=\"5. 数组实例的fill()\"></a>5. 数组实例的fill()</h3><p><code>fill</code>方法可以用给定的值填充一个数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].fill(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">// [7, 7, 7]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，<code>fill</code>方法可以用于空数组的初始化。如果数组中已有元素，会被全部替换掉。</p>\n<p><code>fill</code>方法接受两个可选参数，用于指定起始位置和结束位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>].fill(<span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"6-数组实例的entries-，keys-和values\"><a href=\"#6-数组实例的entries-，keys-和values\" class=\"headerlink\" title=\"6. 数组实例的entries()，keys()和values()\"></a>6. 数组实例的entries()，keys()和values()</h3><p>ES6提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>，用于遍历数组。他们都会返回一个遍历器对象。可以用<code>for...of</code>进行循环遍历，唯一的区别是<code>keys()</code>是对键名遍历、<code>values()</code>是对键值进行遍历、<code>entries()</code>是对键值对进行遍历。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].keys()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> elem <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].values()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 'a'</span></span><br><span class=\"line\"><span class=\"comment\">// 'b'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [index, elem] <span class=\"keyword\">of</span> [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>].entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index, elem);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 0 \"a\"</span></span><br><span class=\"line\"><span class=\"comment\">// 1 \"b\"</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"7-数组实例的includes\"><a href=\"#7-数组实例的includes\" class=\"headerlink\" title=\"7. 数组实例的includes()\"></a>7. 数组实例的includes()</h3><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。此方法属于ES7，但是Babel转码器已经支持。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">2</span>);     <span class=\"comment\">// true</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">4</span>);     <span class=\"comment\">// false</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"literal\">NaN</span>].includes(<span class=\"literal\">NaN</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>该方法的第二个参数搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果倒数的大于数组的长度，则会重置为0开始。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">3</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// false</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].includes(<span class=\"number\">3</span>, <span class=\"number\">-1</span>); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>在没有这个方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (arr.indexOf(el) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是<code>indexOf</code>方法有两个缺点，一是不够语义化，表达起来不够直观，二是，可能会对NaN产生误判。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"literal\">NaN</span>].indexOf(<span class=\"literal\">NaN</span>)</span><br><span class=\"line\"><span class=\"comment\">// -1</span></span><br></pre></td></tr></table></figure>\n<p>但是使用<code>includes</code>方法的是不一样的判断算法，不会产生误判。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"literal\">NaN</span>].includes(<span class=\"literal\">NaN</span>)</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"8-数组的空位\"><a href=\"#8-数组的空位\" class=\"headerlink\" title=\"8. 数组的空位\"></a>8. 数组的空位</h3><p>数组的空位，是指数组的某一个位置没有任何值，比如<code>Array</code>构造函数返回的数组都是空位。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>(<span class=\"number\">3</span>) <span class=\"comment\">// [, , ,]</span></span><br></pre></td></tr></table></figure>\n<p>这里要注意，空位不是<code>undefined</code>，空位是没有任何值。请看下面代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"keyword\">in</span> [<span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>] <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"keyword\">in</span> [, , ,] <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，数组一，尽管是<code>undefined</code>但是依然是有值的，而数组二的0号位置没有值。</p>\n<p>ES5对空位的处理，是很不一致的，大多数情况会忽略空位。</p>\n<ol>\n<li><code>forEach()</code>, <code>filter()</code>, <code>every()</code>和<code>some()</code>都会跳过空位。</li>\n<li><code>map()</code>会跳过空位，但会保留这个值。</li>\n<li><code>join()</code>和<code>toString()</code>会将空位视为undefined，而undefined和null会被处理成空字符串。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// forEach方法</span></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>].forEach((x,i) =&gt; log(i)); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// filter方法</span></span><br><span class=\"line\">[<span class=\"string\">'a'</span>,,<span class=\"string\">'b'</span>].filter(x =&gt; <span class=\"literal\">true</span>) <span class=\"comment\">// ['a','b']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// every方法</span></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>].every(x =&gt; x===<span class=\"string\">'a'</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// some方法</span></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>].some(x =&gt; x !== <span class=\"string\">'a'</span>) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map方法</span></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>].map(x =&gt; <span class=\"number\">1</span>) <span class=\"comment\">// [,1]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// join方法</span></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>,<span class=\"literal\">undefined</span>,<span class=\"literal\">null</span>].join(<span class=\"string\">'#'</span>) <span class=\"comment\">// \"#a##\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// toString方法</span></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>,<span class=\"literal\">undefined</span>,<span class=\"literal\">null</span>].toString() <span class=\"comment\">// \",a,,\"</span></span><br></pre></td></tr></table></figure>\n<p>\u0010而ES6则明确将空位转为<code>undefined</code>。</p>\n<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说这个方法不会忽略空位。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from([<span class=\"string\">'a'</span>,,<span class=\"string\">'b'</span>])</span><br><span class=\"line\"><span class=\"comment\">// [ \"a\", undefined, \"b\" ]</span></span><br></pre></td></tr></table></figure>\n<p>扩展运算符(<code>...</code>)也会将空位转为<code>undefined</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[...[<span class=\"string\">'a'</span>,,<span class=\"string\">'b'</span>]]</span><br><span class=\"line\"><span class=\"comment\">// [ \"a\", undefined, \"b\" ]</span></span><br></pre></td></tr></table></figure>\n<p><code>copyWithin()</code>会连空位一起拷贝。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[,<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,,].copyWithin(<span class=\"number\">2</span>,<span class=\"number\">0</span>) <span class=\"comment\">// [,\"a\",,\"a\"]</span></span><br></pre></td></tr></table></figure>\n<p><code>fill()</code>会将空位视为正常的数组位置。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">3</span>).fill(<span class=\"string\">'a'</span>) <span class=\"comment\">// [\"a\",\"a\",\"a\"]</span></span><br></pre></td></tr></table></figure>\n<p><code>for...of</code>循环也会遍历空位。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [, ,];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略他们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>\n<hr>\n<h3 id=\"9-数组推导\"><a href=\"#9-数组推导\" class=\"headerlink\" title=\"9. 数组推导\"></a>9. 数组推导</h3><p>数组推导提供了简洁写法，可以通过现有数组生成新数组。ES7会有折现功能，现在Bable转码器已经支持这个功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> a2 = [<span class=\"keyword\">for</span> (i <span class=\"keyword\">of</span> a1) i * <span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">a2 <span class=\"comment\">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，通过<code>for...of</code>可能在<code>a1</code>的基础上生成<code>a2</code>。</p>\n<p>在数组推导中，<code>for...of</code>结构总是鞋在最前面，返回的表达式写在最后面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> years = [ <span class=\"number\">1954</span>, <span class=\"number\">1974</span>, <span class=\"number\">1990</span>, <span class=\"number\">2006</span>, <span class=\"number\">2010</span>, <span class=\"number\">2014</span> ];</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (year <span class=\"keyword\">of</span> years) <span class=\"keyword\">if</span> (year &gt; <span class=\"number\">2000</span>) year];</span><br><span class=\"line\"><span class=\"comment\">// [ 2006, 2010, 2014 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (year <span class=\"keyword\">of</span> years) <span class=\"keyword\">if</span> (year &gt; <span class=\"number\">2000</span>) <span class=\"keyword\">if</span>(year &lt; <span class=\"number\">2010</span>) year];</span><br><span class=\"line\"><span class=\"comment\">// [ 2006]</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (year <span class=\"keyword\">of</span> years) <span class=\"keyword\">if</span> (year &gt; <span class=\"number\">2000</span> &amp;&amp; year &lt; <span class=\"number\">2010</span>) year];</span><br><span class=\"line\"><span class=\"comment\">// [ 2006]</span></span><br></pre></td></tr></table></figure>\n<p>如上代码，<code>if</code>语句要卸载<code>for...of</code>与返回的表达式之间，而且可以多个<code>if</code>语句连用。</p>\n<p>再多举一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> customers = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Jack'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">25</span>,</span><br><span class=\"line\">    city: <span class=\"string\">'New York'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Peter'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">30</span>,</span><br><span class=\"line\">    city: <span class=\"string\">'Seattle'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> results = [</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (c <span class=\"keyword\">of</span> customers)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c.city == <span class=\"string\">\"Seattle\"</span>)</span><br><span class=\"line\">      &#123; name: c.name, age: c.age &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\">results <span class=\"comment\">// &#123; name: \"Peter\", age: 30 &#125;</span></span><br></pre></td></tr></table></figure>\n<p>数组推导可以替代<code>map</code>和<code>filter</code>方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (i <span class=\"keyword\">of</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) i * i];</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i</span>) </span>&#123; <span class=\"keyword\">return</span> i * i &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (i <span class=\"keyword\">of</span> [<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">-8</span>]) <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">3</span>) i];</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">-8</span>].filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123; <span class=\"keyword\">return</span> i &lt; <span class=\"number\">3</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>如上代码，模拟<code>map</code>功能只要单纯的<code>for...of</code>循环就可以了，如果模拟<code>filter</code>除了循环，还要加上<code>if</code>语句。</p>\n<p>在一个数组推到中，还可以使用多个<code>for...of</code>构成多重循环。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a1 = [<span class=\"string\">'x1'</span>, <span class=\"string\">'y1'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> a2 = [<span class=\"string\">'x2'</span>, <span class=\"string\">'y2'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> a3 = [<span class=\"string\">'x3'</span>, <span class=\"string\">'y3'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (s <span class=\"keyword\">of</span> a1) <span class=\"keyword\">for</span> (w <span class=\"keyword\">of</span> a2) <span class=\"keyword\">for</span> (r <span class=\"keyword\">of</span> a3) <span class=\"built_in\">console</span>.log(s + w + r)];</span><br><span class=\"line\"><span class=\"comment\">// x1x2x3</span></span><br><span class=\"line\"><span class=\"comment\">// x1x2y3</span></span><br><span class=\"line\"><span class=\"comment\">// x1y2x3</span></span><br><span class=\"line\"><span class=\"comment\">// x1y2y3</span></span><br><span class=\"line\"><span class=\"comment\">// y1x2x3</span></span><br><span class=\"line\"><span class=\"comment\">// y1x2y3</span></span><br><span class=\"line\"><span class=\"comment\">// y1y2x3</span></span><br><span class=\"line\"><span class=\"comment\">// y1y2y3</span></span><br></pre></td></tr></table></figure>\n<p>字符串可以视为数组，所以字符串也可以直接用于数组推导。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (c <span class=\"keyword\">of</span> <span class=\"string\">'abcde'</span>) <span class=\"keyword\">if</span> (<span class=\"regexp\">/[aeiou]/</span>.test(c)) c].join(<span class=\"string\">''</span>) <span class=\"comment\">// 'ae'</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">for</span> (c <span class=\"keyword\">of</span> <span class=\"string\">'abcde'</span>) c+<span class=\"string\">'0'</span>].join(<span class=\"string\">''</span>) <span class=\"comment\">// 'a0b0c0d0e0'</span></span><br></pre></td></tr></table></figure>\n<hr>\n"},{"layout":"post","title":"2015年小总结","date":"2016-02-14T16:00:00.000Z","_content":"\n15年就在鞭炮声中过去了，想到这一年以来，结束了学生时代，开始了职业生涯。过去的不乏有遗憾，有怀念，有不舍，有悔恨。都在我毕业时的总结了写了一写。\n\n工作以后，真的第一次感觉到了生活的不易，也开始思考自己的未来到底要如何。\n\n在之前，真是对自己未来想要的没有一点概念，觉得有一个对口岗位，通过自己的学习和努力，就可以在未来过活。但是真的到了一个岗位上你才开始思考，开始盘算，开始权衡利弊。在兴趣和工资上选择，在环境和发展上选择。\n\n当我毕业后，进入了工作的岗位，我开始觉得这个可能不是我想要的，家长会劝我在这个岗位上发展也不错，塌下心来好好干，学到本事，以后自己出来干也不错。但是我在想一辈子就那么短，我为什么要在自己本不喜欢上的事情上面虚度光阴。\n\n那你喜欢什么？我也在问自己，我到底想干什么，到底喜欢什么。其实我不知道，在哪个岗位都是从螺丝钉开始做起，哪个行业的开始都是枯燥的，重复的。只有把基本的做好才会给你发挥的空间，这个道理可能所有人都懂，我也懂，我知道所有的工作都逃不出这个道理。可是虽然我不知道我喜欢什么，但是我会知道我不喜欢什么，说起弱电，我的答案是不喜欢，我不喜欢和供应商去联系，不喜欢和甲方去沟通，不喜欢那种锁在条条框框里的感觉，更不喜欢看到未来五年后的自己是我前辈那个样子。所以我选择换一个行业试试。\n\n这里，我就要提到我的好兄弟周哥，是我最要好的玩伴了，从高中一起打dota，大学一起打dota，到了工作住到一起了继续哈哈哈，感觉我的青春就这么虚度了，因为怪自己管不住自己，曾经有个人想管我但是也没能管住，回忆不曾忘记。\n\n周哥，他自己自学了web开发，毕业后找到了在我看来还不错的工作，也在继续努力着，每天下班回来都能听到他说，卧槽我今天又学到了一个超屌的技术，以后肯定这个就是风向标\n。耳濡目染，我也在想我要不要学学这个试试？互联网是一个站在风口的行业，他相比第二产业的发展前景要更为广阔，而且这几年房地产行业低迷，附带的行业也不是很景气，不如也试试这个，正好也有人指导。就这样我就在上班空闲，下班以后和周六周日的时间开始自学。刚开始，我按照教程写了一个hello world页面，再往后我会了写一个内容更多的页面，又会了写页面的样式，又会了写简单的逻辑，又会了做一些网页的基本功能，比如弹出框啊，轮播图啊等等，进步是显而易见的，周哥也在毫无保留的教我，我很感谢他，以至于我最后换工作后工资比他都高，这是后话。\n\n当我学的感觉差不多了，在自学进步速度已经没有以前快了的时候，我打算换一个行业吧，在工作中才能更专心的学习，进步更快。所以我打算辞职换工作了，制作了一个个人页面，发了简历一个多星期了，面试电话一个没有，也许是因为年底招聘的公司变少，也许是因为我投简历是有筛选过得而不是海投，也许是因为我不是科班出身的缘故，在也许是因为我的能力确实没有达到要求。那一个多星期，我的情绪很低落和沮丧，也没有继续学习的动力了。\n\n转机出现在有一天，一个hr告诉我不好意思我的简历没有符合他们公司的要求，我很受打击，就问了一下贵公司需要的基本能力有哪些，我觉得就算这次不行，了解了解职位的具体要求也不错。我也很感谢hr盼盼姐，她详细的告诉了我一下，通过了解后我觉得我其实是合适的，我就再三要求了盼盼姐再看看我的简历，还有我的作品。可能是因为hr的工作确实很忙，她之前确实没有仔细的看我的作品，她看完我的作品后，和领导沟通后，同意我到公司聊一聊。之后也就很顺利的入职到了新公司。\n\n经过这件事情后，我很感谢当时盼盼姐可以耐心的和我沟通。也很感谢当初的自己有这个勇气去再为自己争取一下，其实我不是一个很自信的人，在被人拒绝后是会先在自己的身上找缺点而忽略了自己的优势，感谢我当初有这个勇气。我也学到了其实有些事情不应该太急，多给自己一个机会和选择，因为当我答应入职到新公司后，之后又有了自己面试通知，但是我因为很感谢第一家接纳我的公司，而放弃了本来属于我的一些机会。\n\n而我也很感谢我原来公司的师傅，他是我毕业后入职到原来公司接触最多的人，但是我在打算换工作后都没有告诉他，因为我挺不好意思的，师傅一直在耐心的指导我，而我却这样，我很愧疚觉得欠了他很多，所以刻意的避开了他直到我写辞职申请的时候。我从办辞职到办好，只用了一个下午，而知道这件事情的师傅他并没有不高兴，而是怕我有什么心里包袱而去开导我，说工作的人员流动是正常的，互联网行业比这个行业有发展挺好的，既然你有兴趣学这个应该去继续学习啊，之类的话，其实在我这里我真的是非常愧疚和尴尬心里不是滋味，因为将心比心我做的事情太小人了，东北话讲不太敞亮。经过这件事，师傅这位前辈对我也做了榜样，让我在以后资历深了如果碰到类似的情况，我也会以同样的方式去疏导他。\n\n新年后，我已经入职了新公司两个月了，从刚开始的兴趣满满，到现在的兴趣一般，凡事变成了谋生的工具，就披上一层势利的外衣。但是我也是在利益和兴趣的双驱动下继续努力的，我觉得我还是挺喜欢web前端的开发的，我也在希望以后有我一个自己作品给亿万人用，能改善人们哪怕一丝丝的生活，这样我就可以骄傲的说，看这个东西是老子做的。在工作上有多大的进步谈不上，但我也知道了很多自己的不足，在工作中我要努力的地方还有很多，这些就不一一展开了，我希望我可以在写2016年总结的时候，骄傲的说出，我没有选错，这就是我想要的工作。\n\n其实想说的还有很多，就在今天，我给一个人发红包，随机拜年红包，5.20系统自己写上了爱你~我一想挺熟的(可能我自作多情)也没啥，就直接发过去了，她回复你暴露了你的内心咯。因为熟我肯定就是顺着往下说开开玩笑呗，我说你可以考虑考虑啊~我爸都在催我了(可能是有点过分)，她就说你好会撩妹哦，非常符合双子座哦。\n\n我非常讨厌把我和星座或其他之类的东西联系起来，这样定性是武断而没有根据的，反正我从来不会评论一个人，任何时候我对一个人都不会发表自己的看法，因为我不了解。其实我是想解释一下我当时说话时的心里活动的，但是自己一想，确实是自己可能说话也没太注意(我也在想，万一开玩笑成了呢哈哈哈哈哈😂😂😭😭)，解释了反而感觉在掩饰什么，算了吧随他呢就这样吧，越解释可能越黑还不如就这么算了。\n\n其实我写了下半年的总结间接是因为这件事，我睡不着觉哈哈哈，我心眼小啊，看中别人对我的看法(不自信的表现)。所以索性来写这么一个总结，以度时间。回头想想，有时候我和一些熟悉的朋友说话确实也不是很注意，和异性朋友有时候会试探性的开玩笑，可能是因为我没有对象，这样试探也是在寻找着什么，但是也只是限于几个自认为还是比较熟而且觉得很不错的朋友上面。而这样可能也对有的人造成了困扰，这么一想，我确实有些自私，我这是以一种我并不需要承担一些什么的行为，来去试探别人。这样确实不是特别好，也许是因为我怕了，怕再付出而没有得到结果。以后自己也会注意言行，希望对别人不在造成困扰，也希望自己能勇敢。\n\n从来，感觉自己都是一个包子，面对自己喜欢的人，没有行动。怕被拒绝，怕丢面子，而错过了好多好多，也造成了现在这种局面，2016的愿望除了工作和学习上的，也会多加一条，另一半。耶稣基督曾说过，凡求得就必得到，找的就必找到，敲的就必给他开。我的另一半也许不远，就在路上，就在2016哈哈哈哈。\n","source":"_posts/2016-02-15-2015小总结.md","raw":"---\nlayout: post\ntitle: 2015年小总结\ndate: 2016-02-15\ntags: [杂事二三]\ncategories: 杂事二三\n---\n\n15年就在鞭炮声中过去了，想到这一年以来，结束了学生时代，开始了职业生涯。过去的不乏有遗憾，有怀念，有不舍，有悔恨。都在我毕业时的总结了写了一写。\n\n工作以后，真的第一次感觉到了生活的不易，也开始思考自己的未来到底要如何。\n\n在之前，真是对自己未来想要的没有一点概念，觉得有一个对口岗位，通过自己的学习和努力，就可以在未来过活。但是真的到了一个岗位上你才开始思考，开始盘算，开始权衡利弊。在兴趣和工资上选择，在环境和发展上选择。\n\n当我毕业后，进入了工作的岗位，我开始觉得这个可能不是我想要的，家长会劝我在这个岗位上发展也不错，塌下心来好好干，学到本事，以后自己出来干也不错。但是我在想一辈子就那么短，我为什么要在自己本不喜欢上的事情上面虚度光阴。\n\n那你喜欢什么？我也在问自己，我到底想干什么，到底喜欢什么。其实我不知道，在哪个岗位都是从螺丝钉开始做起，哪个行业的开始都是枯燥的，重复的。只有把基本的做好才会给你发挥的空间，这个道理可能所有人都懂，我也懂，我知道所有的工作都逃不出这个道理。可是虽然我不知道我喜欢什么，但是我会知道我不喜欢什么，说起弱电，我的答案是不喜欢，我不喜欢和供应商去联系，不喜欢和甲方去沟通，不喜欢那种锁在条条框框里的感觉，更不喜欢看到未来五年后的自己是我前辈那个样子。所以我选择换一个行业试试。\n\n这里，我就要提到我的好兄弟周哥，是我最要好的玩伴了，从高中一起打dota，大学一起打dota，到了工作住到一起了继续哈哈哈，感觉我的青春就这么虚度了，因为怪自己管不住自己，曾经有个人想管我但是也没能管住，回忆不曾忘记。\n\n周哥，他自己自学了web开发，毕业后找到了在我看来还不错的工作，也在继续努力着，每天下班回来都能听到他说，卧槽我今天又学到了一个超屌的技术，以后肯定这个就是风向标\n。耳濡目染，我也在想我要不要学学这个试试？互联网是一个站在风口的行业，他相比第二产业的发展前景要更为广阔，而且这几年房地产行业低迷，附带的行业也不是很景气，不如也试试这个，正好也有人指导。就这样我就在上班空闲，下班以后和周六周日的时间开始自学。刚开始，我按照教程写了一个hello world页面，再往后我会了写一个内容更多的页面，又会了写页面的样式，又会了写简单的逻辑，又会了做一些网页的基本功能，比如弹出框啊，轮播图啊等等，进步是显而易见的，周哥也在毫无保留的教我，我很感谢他，以至于我最后换工作后工资比他都高，这是后话。\n\n当我学的感觉差不多了，在自学进步速度已经没有以前快了的时候，我打算换一个行业吧，在工作中才能更专心的学习，进步更快。所以我打算辞职换工作了，制作了一个个人页面，发了简历一个多星期了，面试电话一个没有，也许是因为年底招聘的公司变少，也许是因为我投简历是有筛选过得而不是海投，也许是因为我不是科班出身的缘故，在也许是因为我的能力确实没有达到要求。那一个多星期，我的情绪很低落和沮丧，也没有继续学习的动力了。\n\n转机出现在有一天，一个hr告诉我不好意思我的简历没有符合他们公司的要求，我很受打击，就问了一下贵公司需要的基本能力有哪些，我觉得就算这次不行，了解了解职位的具体要求也不错。我也很感谢hr盼盼姐，她详细的告诉了我一下，通过了解后我觉得我其实是合适的，我就再三要求了盼盼姐再看看我的简历，还有我的作品。可能是因为hr的工作确实很忙，她之前确实没有仔细的看我的作品，她看完我的作品后，和领导沟通后，同意我到公司聊一聊。之后也就很顺利的入职到了新公司。\n\n经过这件事情后，我很感谢当时盼盼姐可以耐心的和我沟通。也很感谢当初的自己有这个勇气去再为自己争取一下，其实我不是一个很自信的人，在被人拒绝后是会先在自己的身上找缺点而忽略了自己的优势，感谢我当初有这个勇气。我也学到了其实有些事情不应该太急，多给自己一个机会和选择，因为当我答应入职到新公司后，之后又有了自己面试通知，但是我因为很感谢第一家接纳我的公司，而放弃了本来属于我的一些机会。\n\n而我也很感谢我原来公司的师傅，他是我毕业后入职到原来公司接触最多的人，但是我在打算换工作后都没有告诉他，因为我挺不好意思的，师傅一直在耐心的指导我，而我却这样，我很愧疚觉得欠了他很多，所以刻意的避开了他直到我写辞职申请的时候。我从办辞职到办好，只用了一个下午，而知道这件事情的师傅他并没有不高兴，而是怕我有什么心里包袱而去开导我，说工作的人员流动是正常的，互联网行业比这个行业有发展挺好的，既然你有兴趣学这个应该去继续学习啊，之类的话，其实在我这里我真的是非常愧疚和尴尬心里不是滋味，因为将心比心我做的事情太小人了，东北话讲不太敞亮。经过这件事，师傅这位前辈对我也做了榜样，让我在以后资历深了如果碰到类似的情况，我也会以同样的方式去疏导他。\n\n新年后，我已经入职了新公司两个月了，从刚开始的兴趣满满，到现在的兴趣一般，凡事变成了谋生的工具，就披上一层势利的外衣。但是我也是在利益和兴趣的双驱动下继续努力的，我觉得我还是挺喜欢web前端的开发的，我也在希望以后有我一个自己作品给亿万人用，能改善人们哪怕一丝丝的生活，这样我就可以骄傲的说，看这个东西是老子做的。在工作上有多大的进步谈不上，但我也知道了很多自己的不足，在工作中我要努力的地方还有很多，这些就不一一展开了，我希望我可以在写2016年总结的时候，骄傲的说出，我没有选错，这就是我想要的工作。\n\n其实想说的还有很多，就在今天，我给一个人发红包，随机拜年红包，5.20系统自己写上了爱你~我一想挺熟的(可能我自作多情)也没啥，就直接发过去了，她回复你暴露了你的内心咯。因为熟我肯定就是顺着往下说开开玩笑呗，我说你可以考虑考虑啊~我爸都在催我了(可能是有点过分)，她就说你好会撩妹哦，非常符合双子座哦。\n\n我非常讨厌把我和星座或其他之类的东西联系起来，这样定性是武断而没有根据的，反正我从来不会评论一个人，任何时候我对一个人都不会发表自己的看法，因为我不了解。其实我是想解释一下我当时说话时的心里活动的，但是自己一想，确实是自己可能说话也没太注意(我也在想，万一开玩笑成了呢哈哈哈哈哈😂😂😭😭)，解释了反而感觉在掩饰什么，算了吧随他呢就这样吧，越解释可能越黑还不如就这么算了。\n\n其实我写了下半年的总结间接是因为这件事，我睡不着觉哈哈哈，我心眼小啊，看中别人对我的看法(不自信的表现)。所以索性来写这么一个总结，以度时间。回头想想，有时候我和一些熟悉的朋友说话确实也不是很注意，和异性朋友有时候会试探性的开玩笑，可能是因为我没有对象，这样试探也是在寻找着什么，但是也只是限于几个自认为还是比较熟而且觉得很不错的朋友上面。而这样可能也对有的人造成了困扰，这么一想，我确实有些自私，我这是以一种我并不需要承担一些什么的行为，来去试探别人。这样确实不是特别好，也许是因为我怕了，怕再付出而没有得到结果。以后自己也会注意言行，希望对别人不在造成困扰，也希望自己能勇敢。\n\n从来，感觉自己都是一个包子，面对自己喜欢的人，没有行动。怕被拒绝，怕丢面子，而错过了好多好多，也造成了现在这种局面，2016的愿望除了工作和学习上的，也会多加一条，另一半。耶稣基督曾说过，凡求得就必得到，找的就必找到，敲的就必给他开。我的另一半也许不远，就在路上，就在2016哈哈哈哈。\n","slug":"2015小总结","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1yi000usq5lcckrgpl2","content":"<p>15年就在鞭炮声中过去了，想到这一年以来，结束了学生时代，开始了职业生涯。过去的不乏有遗憾，有怀念，有不舍，有悔恨。都在我毕业时的总结了写了一写。</p>\n<p>工作以后，真的第一次感觉到了生活的不易，也开始思考自己的未来到底要如何。</p>\n<p>在之前，真是对自己未来想要的没有一点概念，觉得有一个对口岗位，通过自己的学习和努力，就可以在未来过活。但是真的到了一个岗位上你才开始思考，开始盘算，开始权衡利弊。在兴趣和工资上选择，在环境和发展上选择。</p>\n<p>当我毕业后，进入了工作的岗位，我开始觉得这个可能不是我想要的，家长会劝我在这个岗位上发展也不错，塌下心来好好干，学到本事，以后自己出来干也不错。但是我在想一辈子就那么短，我为什么要在自己本不喜欢上的事情上面虚度光阴。</p>\n<p>那你喜欢什么？我也在问自己，我到底想干什么，到底喜欢什么。其实我不知道，在哪个岗位都是从螺丝钉开始做起，哪个行业的开始都是枯燥的，重复的。只有把基本的做好才会给你发挥的空间，这个道理可能所有人都懂，我也懂，我知道所有的工作都逃不出这个道理。可是虽然我不知道我喜欢什么，但是我会知道我不喜欢什么，说起弱电，我的答案是不喜欢，我不喜欢和供应商去联系，不喜欢和甲方去沟通，不喜欢那种锁在条条框框里的感觉，更不喜欢看到未来五年后的自己是我前辈那个样子。所以我选择换一个行业试试。</p>\n<p>这里，我就要提到我的好兄弟周哥，是我最要好的玩伴了，从高中一起打dota，大学一起打dota，到了工作住到一起了继续哈哈哈，感觉我的青春就这么虚度了，因为怪自己管不住自己，曾经有个人想管我但是也没能管住，回忆不曾忘记。</p>\n<p>周哥，他自己自学了web开发，毕业后找到了在我看来还不错的工作，也在继续努力着，每天下班回来都能听到他说，卧槽我今天又学到了一个超屌的技术，以后肯定这个就是风向标<br>。耳濡目染，我也在想我要不要学学这个试试？互联网是一个站在风口的行业，他相比第二产业的发展前景要更为广阔，而且这几年房地产行业低迷，附带的行业也不是很景气，不如也试试这个，正好也有人指导。就这样我就在上班空闲，下班以后和周六周日的时间开始自学。刚开始，我按照教程写了一个hello world页面，再往后我会了写一个内容更多的页面，又会了写页面的样式，又会了写简单的逻辑，又会了做一些网页的基本功能，比如弹出框啊，轮播图啊等等，进步是显而易见的，周哥也在毫无保留的教我，我很感谢他，以至于我最后换工作后工资比他都高，这是后话。</p>\n<p>当我学的感觉差不多了，在自学进步速度已经没有以前快了的时候，我打算换一个行业吧，在工作中才能更专心的学习，进步更快。所以我打算辞职换工作了，制作了一个个人页面，发了简历一个多星期了，面试电话一个没有，也许是因为年底招聘的公司变少，也许是因为我投简历是有筛选过得而不是海投，也许是因为我不是科班出身的缘故，在也许是因为我的能力确实没有达到要求。那一个多星期，我的情绪很低落和沮丧，也没有继续学习的动力了。</p>\n<p>转机出现在有一天，一个hr告诉我不好意思我的简历没有符合他们公司的要求，我很受打击，就问了一下贵公司需要的基本能力有哪些，我觉得就算这次不行，了解了解职位的具体要求也不错。我也很感谢hr盼盼姐，她详细的告诉了我一下，通过了解后我觉得我其实是合适的，我就再三要求了盼盼姐再看看我的简历，还有我的作品。可能是因为hr的工作确实很忙，她之前确实没有仔细的看我的作品，她看完我的作品后，和领导沟通后，同意我到公司聊一聊。之后也就很顺利的入职到了新公司。</p>\n<p>经过这件事情后，我很感谢当时盼盼姐可以耐心的和我沟通。也很感谢当初的自己有这个勇气去再为自己争取一下，其实我不是一个很自信的人，在被人拒绝后是会先在自己的身上找缺点而忽略了自己的优势，感谢我当初有这个勇气。我也学到了其实有些事情不应该太急，多给自己一个机会和选择，因为当我答应入职到新公司后，之后又有了自己面试通知，但是我因为很感谢第一家接纳我的公司，而放弃了本来属于我的一些机会。</p>\n<p>而我也很感谢我原来公司的师傅，他是我毕业后入职到原来公司接触最多的人，但是我在打算换工作后都没有告诉他，因为我挺不好意思的，师傅一直在耐心的指导我，而我却这样，我很愧疚觉得欠了他很多，所以刻意的避开了他直到我写辞职申请的时候。我从办辞职到办好，只用了一个下午，而知道这件事情的师傅他并没有不高兴，而是怕我有什么心里包袱而去开导我，说工作的人员流动是正常的，互联网行业比这个行业有发展挺好的，既然你有兴趣学这个应该去继续学习啊，之类的话，其实在我这里我真的是非常愧疚和尴尬心里不是滋味，因为将心比心我做的事情太小人了，东北话讲不太敞亮。经过这件事，师傅这位前辈对我也做了榜样，让我在以后资历深了如果碰到类似的情况，我也会以同样的方式去疏导他。</p>\n<p>新年后，我已经入职了新公司两个月了，从刚开始的兴趣满满，到现在的兴趣一般，凡事变成了谋生的工具，就披上一层势利的外衣。但是我也是在利益和兴趣的双驱动下继续努力的，我觉得我还是挺喜欢web前端的开发的，我也在希望以后有我一个自己作品给亿万人用，能改善人们哪怕一丝丝的生活，这样我就可以骄傲的说，看这个东西是老子做的。在工作上有多大的进步谈不上，但我也知道了很多自己的不足，在工作中我要努力的地方还有很多，这些就不一一展开了，我希望我可以在写2016年总结的时候，骄傲的说出，我没有选错，这就是我想要的工作。</p>\n<p>其实想说的还有很多，就在今天，我给一个人发红包，随机拜年红包，5.20系统自己写上了爱你~我一想挺熟的(可能我自作多情)也没啥，就直接发过去了，她回复你暴露了你的内心咯。因为熟我肯定就是顺着往下说开开玩笑呗，我说你可以考虑考虑啊~我爸都在催我了(可能是有点过分)，她就说你好会撩妹哦，非常符合双子座哦。</p>\n<p>我非常讨厌把我和星座或其他之类的东西联系起来，这样定性是武断而没有根据的，反正我从来不会评论一个人，任何时候我对一个人都不会发表自己的看法，因为我不了解。其实我是想解释一下我当时说话时的心里活动的，但是自己一想，确实是自己可能说话也没太注意(我也在想，万一开玩笑成了呢哈哈哈哈哈😂😂😭😭)，解释了反而感觉在掩饰什么，算了吧随他呢就这样吧，越解释可能越黑还不如就这么算了。</p>\n<p>其实我写了下半年的总结间接是因为这件事，我睡不着觉哈哈哈，我心眼小啊，看中别人对我的看法(不自信的表现)。所以索性来写这么一个总结，以度时间。回头想想，有时候我和一些熟悉的朋友说话确实也不是很注意，和异性朋友有时候会试探性的开玩笑，可能是因为我没有对象，这样试探也是在寻找着什么，但是也只是限于几个自认为还是比较熟而且觉得很不错的朋友上面。而这样可能也对有的人造成了困扰，这么一想，我确实有些自私，我这是以一种我并不需要承担一些什么的行为，来去试探别人。这样确实不是特别好，也许是因为我怕了，怕再付出而没有得到结果。以后自己也会注意言行，希望对别人不在造成困扰，也希望自己能勇敢。</p>\n<p>从来，感觉自己都是一个包子，面对自己喜欢的人，没有行动。怕被拒绝，怕丢面子，而错过了好多好多，也造成了现在这种局面，2016的愿望除了工作和学习上的，也会多加一条，另一半。耶稣基督曾说过，凡求得就必得到，找的就必找到，敲的就必给他开。我的另一半也许不远，就在路上，就在2016哈哈哈哈。</p>\n","excerpt":"","more":"<p>15年就在鞭炮声中过去了，想到这一年以来，结束了学生时代，开始了职业生涯。过去的不乏有遗憾，有怀念，有不舍，有悔恨。都在我毕业时的总结了写了一写。</p>\n<p>工作以后，真的第一次感觉到了生活的不易，也开始思考自己的未来到底要如何。</p>\n<p>在之前，真是对自己未来想要的没有一点概念，觉得有一个对口岗位，通过自己的学习和努力，就可以在未来过活。但是真的到了一个岗位上你才开始思考，开始盘算，开始权衡利弊。在兴趣和工资上选择，在环境和发展上选择。</p>\n<p>当我毕业后，进入了工作的岗位，我开始觉得这个可能不是我想要的，家长会劝我在这个岗位上发展也不错，塌下心来好好干，学到本事，以后自己出来干也不错。但是我在想一辈子就那么短，我为什么要在自己本不喜欢上的事情上面虚度光阴。</p>\n<p>那你喜欢什么？我也在问自己，我到底想干什么，到底喜欢什么。其实我不知道，在哪个岗位都是从螺丝钉开始做起，哪个行业的开始都是枯燥的，重复的。只有把基本的做好才会给你发挥的空间，这个道理可能所有人都懂，我也懂，我知道所有的工作都逃不出这个道理。可是虽然我不知道我喜欢什么，但是我会知道我不喜欢什么，说起弱电，我的答案是不喜欢，我不喜欢和供应商去联系，不喜欢和甲方去沟通，不喜欢那种锁在条条框框里的感觉，更不喜欢看到未来五年后的自己是我前辈那个样子。所以我选择换一个行业试试。</p>\n<p>这里，我就要提到我的好兄弟周哥，是我最要好的玩伴了，从高中一起打dota，大学一起打dota，到了工作住到一起了继续哈哈哈，感觉我的青春就这么虚度了，因为怪自己管不住自己，曾经有个人想管我但是也没能管住，回忆不曾忘记。</p>\n<p>周哥，他自己自学了web开发，毕业后找到了在我看来还不错的工作，也在继续努力着，每天下班回来都能听到他说，卧槽我今天又学到了一个超屌的技术，以后肯定这个就是风向标<br>。耳濡目染，我也在想我要不要学学这个试试？互联网是一个站在风口的行业，他相比第二产业的发展前景要更为广阔，而且这几年房地产行业低迷，附带的行业也不是很景气，不如也试试这个，正好也有人指导。就这样我就在上班空闲，下班以后和周六周日的时间开始自学。刚开始，我按照教程写了一个hello world页面，再往后我会了写一个内容更多的页面，又会了写页面的样式，又会了写简单的逻辑，又会了做一些网页的基本功能，比如弹出框啊，轮播图啊等等，进步是显而易见的，周哥也在毫无保留的教我，我很感谢他，以至于我最后换工作后工资比他都高，这是后话。</p>\n<p>当我学的感觉差不多了，在自学进步速度已经没有以前快了的时候，我打算换一个行业吧，在工作中才能更专心的学习，进步更快。所以我打算辞职换工作了，制作了一个个人页面，发了简历一个多星期了，面试电话一个没有，也许是因为年底招聘的公司变少，也许是因为我投简历是有筛选过得而不是海投，也许是因为我不是科班出身的缘故，在也许是因为我的能力确实没有达到要求。那一个多星期，我的情绪很低落和沮丧，也没有继续学习的动力了。</p>\n<p>转机出现在有一天，一个hr告诉我不好意思我的简历没有符合他们公司的要求，我很受打击，就问了一下贵公司需要的基本能力有哪些，我觉得就算这次不行，了解了解职位的具体要求也不错。我也很感谢hr盼盼姐，她详细的告诉了我一下，通过了解后我觉得我其实是合适的，我就再三要求了盼盼姐再看看我的简历，还有我的作品。可能是因为hr的工作确实很忙，她之前确实没有仔细的看我的作品，她看完我的作品后，和领导沟通后，同意我到公司聊一聊。之后也就很顺利的入职到了新公司。</p>\n<p>经过这件事情后，我很感谢当时盼盼姐可以耐心的和我沟通。也很感谢当初的自己有这个勇气去再为自己争取一下，其实我不是一个很自信的人，在被人拒绝后是会先在自己的身上找缺点而忽略了自己的优势，感谢我当初有这个勇气。我也学到了其实有些事情不应该太急，多给自己一个机会和选择，因为当我答应入职到新公司后，之后又有了自己面试通知，但是我因为很感谢第一家接纳我的公司，而放弃了本来属于我的一些机会。</p>\n<p>而我也很感谢我原来公司的师傅，他是我毕业后入职到原来公司接触最多的人，但是我在打算换工作后都没有告诉他，因为我挺不好意思的，师傅一直在耐心的指导我，而我却这样，我很愧疚觉得欠了他很多，所以刻意的避开了他直到我写辞职申请的时候。我从办辞职到办好，只用了一个下午，而知道这件事情的师傅他并没有不高兴，而是怕我有什么心里包袱而去开导我，说工作的人员流动是正常的，互联网行业比这个行业有发展挺好的，既然你有兴趣学这个应该去继续学习啊，之类的话，其实在我这里我真的是非常愧疚和尴尬心里不是滋味，因为将心比心我做的事情太小人了，东北话讲不太敞亮。经过这件事，师傅这位前辈对我也做了榜样，让我在以后资历深了如果碰到类似的情况，我也会以同样的方式去疏导他。</p>\n<p>新年后，我已经入职了新公司两个月了，从刚开始的兴趣满满，到现在的兴趣一般，凡事变成了谋生的工具，就披上一层势利的外衣。但是我也是在利益和兴趣的双驱动下继续努力的，我觉得我还是挺喜欢web前端的开发的，我也在希望以后有我一个自己作品给亿万人用，能改善人们哪怕一丝丝的生活，这样我就可以骄傲的说，看这个东西是老子做的。在工作上有多大的进步谈不上，但我也知道了很多自己的不足，在工作中我要努力的地方还有很多，这些就不一一展开了，我希望我可以在写2016年总结的时候，骄傲的说出，我没有选错，这就是我想要的工作。</p>\n<p>其实想说的还有很多，就在今天，我给一个人发红包，随机拜年红包，5.20系统自己写上了爱你~我一想挺熟的(可能我自作多情)也没啥，就直接发过去了，她回复你暴露了你的内心咯。因为熟我肯定就是顺着往下说开开玩笑呗，我说你可以考虑考虑啊~我爸都在催我了(可能是有点过分)，她就说你好会撩妹哦，非常符合双子座哦。</p>\n<p>我非常讨厌把我和星座或其他之类的东西联系起来，这样定性是武断而没有根据的，反正我从来不会评论一个人，任何时候我对一个人都不会发表自己的看法，因为我不了解。其实我是想解释一下我当时说话时的心里活动的，但是自己一想，确实是自己可能说话也没太注意(我也在想，万一开玩笑成了呢哈哈哈哈哈😂😂😭😭)，解释了反而感觉在掩饰什么，算了吧随他呢就这样吧，越解释可能越黑还不如就这么算了。</p>\n<p>其实我写了下半年的总结间接是因为这件事，我睡不着觉哈哈哈，我心眼小啊，看中别人对我的看法(不自信的表现)。所以索性来写这么一个总结，以度时间。回头想想，有时候我和一些熟悉的朋友说话确实也不是很注意，和异性朋友有时候会试探性的开玩笑，可能是因为我没有对象，这样试探也是在寻找着什么，但是也只是限于几个自认为还是比较熟而且觉得很不错的朋友上面。而这样可能也对有的人造成了困扰，这么一想，我确实有些自私，我这是以一种我并不需要承担一些什么的行为，来去试探别人。这样确实不是特别好，也许是因为我怕了，怕再付出而没有得到结果。以后自己也会注意言行，希望对别人不在造成困扰，也希望自己能勇敢。</p>\n<p>从来，感觉自己都是一个包子，面对自己喜欢的人，没有行动。怕被拒绝，怕丢面子，而错过了好多好多，也造成了现在这种局面，2016的愿望除了工作和学习上的，也会多加一条，另一半。耶稣基督曾说过，凡求得就必得到，找的就必找到，敲的就必给他开。我的另一半也许不远，就在路上，就在2016哈哈哈哈。</p>\n"},{"layout":"post","title":"温柔的对待每一个人","date":"2016-01-31T16:00:00.000Z","_content":"\n今天在路上看知乎，看到了这么一个问题（[这里](https://www.zhihu.com/question/19866127)），每一个温暖的故事都让我感触良多，想想我们多久没有温柔的去对待一个陌生人，而又去不耐烦的对待我们最亲的人。\n\n在这个总是以金钱去衡量一个人的年代，相比来看我们都变得浮躁，变得现实，变得冷漠，其实我相信我们都有一个帮助别人的心，但是可能我们出于防备，出于畏惧，想要避免麻烦，避免把自己放在一个尴尬的位置上，我们避开这一些我们本想要去帮助别人的行为。\n\n看着他们一个个温暖的故事，心里酸酸的，我也想去分享两个个我看到的故事。\n\n第一件我是看到的事情，在我上下班的路上会路过一座桥，每天下班已经很晚了，走过那里的时候总会有一个流浪的人呆在那里，冬天会很冷，他会点上火来取暖，每次经过那里的时候我都会有疑问，这么冷的冬天他每天晚上都是在这里度过的吗？我也总会想我要不要上去问一问他需不需要帮助，但是多数人都和我一样，心里会想可付诸到行动上的却是没有。但是有一天路过那里的时候，我看到一个暖着粉绿色棉衣的女生，在那里弯下腰和他说话，我故意走慢了一些，原来是那个女生，买了一些包子和粥给那个流浪者。我很佩服那个女生，她可以用于面对自己的内心，而我们却是懦弱的。\n\n第二件是我遇到的一件事情，是在深圳的时候，我去游览中山大学的时候，那天正好雨天，大概下午四五点左右开始下起了大雨，我因为和朋友约定了一个见面的地方，也打着伞匆匆的赶过去，在路边看到了一个男生在树下躲雨，因为雨下得很大他的衣服也有些湿了，我过去和他一起撑伞到一个地方先躲雨，我问他要去哪里离得远不远，简单地交流后，因为他离得住的地方不是很近，他不是很着急回去而且我约了同学比较赶，深圳的阵雨总是下的很急很大，但是时间不是会很长，所以我就先走了，这也是我为数不多的帮助人的事情吧。\n\n因为平时总是很宅，而且不是很爱和陌生人交流，所以遇到的事情可能不多，亦或是我生活的不够细腻，没有把感人的瞬间记在心中。但是我希望我们都能够不做思想上的巨人，行动上的矮子，不要怕尴尬，从自己出发去温柔的对待每一个人，影响身边的每一个人。\n\n\n\n","source":"_posts/2016-02-01-温柔的对待每一个人.md","raw":"---\nlayout: post\ntitle: 温柔的对待每一个人\ndate: 2016-02-01\ntags: [杂事二三]\ncategories: 杂事二三\n---\n\n今天在路上看知乎，看到了这么一个问题（[这里](https://www.zhihu.com/question/19866127)），每一个温暖的故事都让我感触良多，想想我们多久没有温柔的去对待一个陌生人，而又去不耐烦的对待我们最亲的人。\n\n在这个总是以金钱去衡量一个人的年代，相比来看我们都变得浮躁，变得现实，变得冷漠，其实我相信我们都有一个帮助别人的心，但是可能我们出于防备，出于畏惧，想要避免麻烦，避免把自己放在一个尴尬的位置上，我们避开这一些我们本想要去帮助别人的行为。\n\n看着他们一个个温暖的故事，心里酸酸的，我也想去分享两个个我看到的故事。\n\n第一件我是看到的事情，在我上下班的路上会路过一座桥，每天下班已经很晚了，走过那里的时候总会有一个流浪的人呆在那里，冬天会很冷，他会点上火来取暖，每次经过那里的时候我都会有疑问，这么冷的冬天他每天晚上都是在这里度过的吗？我也总会想我要不要上去问一问他需不需要帮助，但是多数人都和我一样，心里会想可付诸到行动上的却是没有。但是有一天路过那里的时候，我看到一个暖着粉绿色棉衣的女生，在那里弯下腰和他说话，我故意走慢了一些，原来是那个女生，买了一些包子和粥给那个流浪者。我很佩服那个女生，她可以用于面对自己的内心，而我们却是懦弱的。\n\n第二件是我遇到的一件事情，是在深圳的时候，我去游览中山大学的时候，那天正好雨天，大概下午四五点左右开始下起了大雨，我因为和朋友约定了一个见面的地方，也打着伞匆匆的赶过去，在路边看到了一个男生在树下躲雨，因为雨下得很大他的衣服也有些湿了，我过去和他一起撑伞到一个地方先躲雨，我问他要去哪里离得远不远，简单地交流后，因为他离得住的地方不是很近，他不是很着急回去而且我约了同学比较赶，深圳的阵雨总是下的很急很大，但是时间不是会很长，所以我就先走了，这也是我为数不多的帮助人的事情吧。\n\n因为平时总是很宅，而且不是很爱和陌生人交流，所以遇到的事情可能不多，亦或是我生活的不够细腻，没有把感人的瞬间记在心中。但是我希望我们都能够不做思想上的巨人，行动上的矮子，不要怕尴尬，从自己出发去温柔的对待每一个人，影响身边的每一个人。\n\n\n\n","slug":"温柔的对待每一个人","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1yl000ysq5lefuxdsu8","content":"<p>今天在路上看知乎，看到了这么一个问题（<a href=\"https://www.zhihu.com/question/19866127\" target=\"_blank\" rel=\"external\">这里</a>），每一个温暖的故事都让我感触良多，想想我们多久没有温柔的去对待一个陌生人，而又去不耐烦的对待我们最亲的人。</p>\n<p>在这个总是以金钱去衡量一个人的年代，相比来看我们都变得浮躁，变得现实，变得冷漠，其实我相信我们都有一个帮助别人的心，但是可能我们出于防备，出于畏惧，想要避免麻烦，避免把自己放在一个尴尬的位置上，我们避开这一些我们本想要去帮助别人的行为。</p>\n<p>看着他们一个个温暖的故事，心里酸酸的，我也想去分享两个个我看到的故事。</p>\n<p>第一件我是看到的事情，在我上下班的路上会路过一座桥，每天下班已经很晚了，走过那里的时候总会有一个流浪的人呆在那里，冬天会很冷，他会点上火来取暖，每次经过那里的时候我都会有疑问，这么冷的冬天他每天晚上都是在这里度过的吗？我也总会想我要不要上去问一问他需不需要帮助，但是多数人都和我一样，心里会想可付诸到行动上的却是没有。但是有一天路过那里的时候，我看到一个暖着粉绿色棉衣的女生，在那里弯下腰和他说话，我故意走慢了一些，原来是那个女生，买了一些包子和粥给那个流浪者。我很佩服那个女生，她可以用于面对自己的内心，而我们却是懦弱的。</p>\n<p>第二件是我遇到的一件事情，是在深圳的时候，我去游览中山大学的时候，那天正好雨天，大概下午四五点左右开始下起了大雨，我因为和朋友约定了一个见面的地方，也打着伞匆匆的赶过去，在路边看到了一个男生在树下躲雨，因为雨下得很大他的衣服也有些湿了，我过去和他一起撑伞到一个地方先躲雨，我问他要去哪里离得远不远，简单地交流后，因为他离得住的地方不是很近，他不是很着急回去而且我约了同学比较赶，深圳的阵雨总是下的很急很大，但是时间不是会很长，所以我就先走了，这也是我为数不多的帮助人的事情吧。</p>\n<p>因为平时总是很宅，而且不是很爱和陌生人交流，所以遇到的事情可能不多，亦或是我生活的不够细腻，没有把感人的瞬间记在心中。但是我希望我们都能够不做思想上的巨人，行动上的矮子，不要怕尴尬，从自己出发去温柔的对待每一个人，影响身边的每一个人。</p>\n","excerpt":"","more":"<p>今天在路上看知乎，看到了这么一个问题（<a href=\"https://www.zhihu.com/question/19866127\">这里</a>），每一个温暖的故事都让我感触良多，想想我们多久没有温柔的去对待一个陌生人，而又去不耐烦的对待我们最亲的人。</p>\n<p>在这个总是以金钱去衡量一个人的年代，相比来看我们都变得浮躁，变得现实，变得冷漠，其实我相信我们都有一个帮助别人的心，但是可能我们出于防备，出于畏惧，想要避免麻烦，避免把自己放在一个尴尬的位置上，我们避开这一些我们本想要去帮助别人的行为。</p>\n<p>看着他们一个个温暖的故事，心里酸酸的，我也想去分享两个个我看到的故事。</p>\n<p>第一件我是看到的事情，在我上下班的路上会路过一座桥，每天下班已经很晚了，走过那里的时候总会有一个流浪的人呆在那里，冬天会很冷，他会点上火来取暖，每次经过那里的时候我都会有疑问，这么冷的冬天他每天晚上都是在这里度过的吗？我也总会想我要不要上去问一问他需不需要帮助，但是多数人都和我一样，心里会想可付诸到行动上的却是没有。但是有一天路过那里的时候，我看到一个暖着粉绿色棉衣的女生，在那里弯下腰和他说话，我故意走慢了一些，原来是那个女生，买了一些包子和粥给那个流浪者。我很佩服那个女生，她可以用于面对自己的内心，而我们却是懦弱的。</p>\n<p>第二件是我遇到的一件事情，是在深圳的时候，我去游览中山大学的时候，那天正好雨天，大概下午四五点左右开始下起了大雨，我因为和朋友约定了一个见面的地方，也打着伞匆匆的赶过去，在路边看到了一个男生在树下躲雨，因为雨下得很大他的衣服也有些湿了，我过去和他一起撑伞到一个地方先躲雨，我问他要去哪里离得远不远，简单地交流后，因为他离得住的地方不是很近，他不是很着急回去而且我约了同学比较赶，深圳的阵雨总是下的很急很大，但是时间不是会很长，所以我就先走了，这也是我为数不多的帮助人的事情吧。</p>\n<p>因为平时总是很宅，而且不是很爱和陌生人交流，所以遇到的事情可能不多，亦或是我生活的不够细腻，没有把感人的瞬间记在心中。但是我希望我们都能够不做思想上的巨人，行动上的矮子，不要怕尴尬，从自己出发去温柔的对待每一个人，影响身边的每一个人。</p>\n"},{"layout":"post","title":"日常工作总结-2016-02-19","date":"2016-02-18T16:00:00.000Z","_content":"\n最近几天，在做一个类似列表的一个界面，在做的时候碰到了很多问题和总结了一些经验，在这里有必要记录一下。设计图如下：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_picdaozhang.jpg)\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_picdaozhang_detail.jpg)\n\n*****\n\n### 遇到的问题\n\n页面看起来并不复杂，可以后台返回的数据并不是很完整，所以遇到了一些问题，有的问题在我看来不是很难我这里就不再描述了（以我的水平如果觉得不难那一定是非常简单了。。。 - -），具体有以下四个问题：\n\n1. 后台返回的交易类型有三种，根据每种交易类型展示不同的图片，可以参考上面到账详情那张图片。\n2. 请看最近到账那张图片，列表的到账状态有四种，根据不同的状态展示的文字颜色需要不一样。\n3. 后台返回的金额都是以分为单位的，而页面上展示的是以元为单位的。\n4. 详情页面的有些信息后台并没有返回给你，必须从列表页面来获取这些信息运用到这个界面上。\n\n这就是遇到的几个比较让我头疼的问题，下面我来简单说一下每个问题的解决办法。\n\n******\n\n#### 1. 问题一和问题二\n\n问题一和二，其实就是模板语言上面的问题，现在加载页面有一些页面上要展示出来的数据其实是后台返回给你的。所以你要预先读取这些数据并通过浏览器渲染到你的页面上。基本做前端的同学应该都会用到模板语言，而我用的是`handlebars`这个模板语言（其实解决这个问题的办法是换一个模板语言，最后我会简单的说一下），我主要是描述一下用`handlebars`这个模板语言是怎么解决的。\n\n在`handlebars`当中的`#if`只能来做这个变量存不存在的简单判断，而不能在`if`当中加一些参数的判断，所以这里我们需要引用`handlebars helper`，在我理解这个其实就是用来补充`handlebars`中的不足的，在`handlebars helper`中可以进行一些复杂的判断，以我用的这个`helper`为例来分析一下，我这个`helper`的功能是这样的，他可以判断后台返回的一个字段的类型，如果类型是微信支付就显示微信支付的图标，如果是支付宝就显示支付宝的图标。\n\n```js\n\n//这里是注册了一个新的helper，名字叫做compare，而这个helper接受了三个参数，第一个和第二个参数是必填的，第三个参数是选填的\nHandlebars.registerHelper(\"compare\",function(v1,v2,options){\n\t //比较参数  满足条件添加继续执行\n    if(v1 == v2){\n        return options.fn(this);\n    }else{\n    //不满足条件执行{else}部分\n        return options.inverse(this);\n    }\n});\n\n```\n\n如上代码，注释写在了里面，我只想说一下`options.fn(this)`，其实这个意思就是执行下面的部分，这个部分其实不是在我们的js函数中，而是在我们引用这个`helper`的那个html页面中出现`# compare`的这个地方。看如下代码：\n\n```html\n\n//比较type是不是card\n   {#compare type 'card'}\n      <img src=\"img/ic_card.svg\" alt=\"\">\n     {else}\n      <img src=\"img/ic_weixin.svg\" alt=\"\">\n   {/compare}\n\n```\n\n如上，这个就是我在html页面的部分代码，`options.fn(this)`的功能就是执行`# compare`和`else`之间的代码。（以我浅显的理解，通俗的解释。。。。。）。\n\nPS:少写了一个花括号是因为双花括号在markdown语法中不能正常显示出来。。。。\n\n说完`handlebars`模板语言之后，我们来说另一种模板语言，`template.js`这个模板语法相比`handlebars`很轻量级，所以很适合移动端使用。他的语法和`handlebars`类似，而且他可以做一些比较复杂的逻辑判断，比如`if`判断来说他可以支持`if a > b || ( a < c && a == d )`这样的复杂判断。使用这样的模板语言，能够基本完成渲染时碰到的一些常用需求。\n\n****\n\n#### 2. 问题三\n\n后台返给我的数据是以`分`为单位的，而我要显示为以`元`为单位的并且保留两位小数，怎么办？其实这个函数是我网上搜索来的，因为我当时只是单纯的把返回的数据除以了100，这样是变成以`元`为单位了，但是没有保留两位小数。网上的具体方法是这样的：\n\n```js\n\n//分转换为元\nvar fen_yuan = function(val){\n    //toFixed来确定保留两位小数  因为除以100 所以都会整除\n    var str = (val/100).toFixed(2) + '';\n    var intSum = str.substring(0,str.indexOf(\".\")).replace( /\\B(?=(?:\\d{3})+$)/g, ',' );\n    //取到整数部分\n    var dot = str.substring(str.length,str.indexOf(\".\"))\n    //取到小数部分\n    var ret = intSum + dot;\n    return ret;\n}\n\n```\n\n如上代码，我给出了基本的注释，大家应该可以读懂，但是注意`tofixed()`这个函数会把小数点后面的部分进行四舍五入，所以不能得到精确结果。这个地方运用的因为是除以100，所以不存在不精确的问题，如果大家来使用的时候还是要参考当前的需求的。\n\n#### 3. 问题四\n\n有些时候我们在这个页面获得了一些数据，但是我们在去往下一个页面的时候还是需要这些数据而下一个页面的接口没有返回这些数据的时候怎么办？\n\n这时候就需要把我们需要的数据拼接到`url`当中，在到了下一个页面的时候，再把`url`中的参数分离出来，调用我们需要的一些参数。\n\n分离`url`参数的方法贴在下面，供大家参考。\n\n```js\n\nvar getQuery = function(){\n    var url=location.search;\n    var Request = {};\n    if(url.indexOf(\"?\")!=-1)\n    {\n        var str = url.substr(1);\n        strs = str.split(\"&\");\n        for(var i=0;i<strs.length;i++)\n        {\n            var _key = strs[i].split(\"=\")[0];\n            Request[_key]=strs[i].split(\"=\")[1];\n        }\n    }\n    return Request;\n};\n\n```\n\n如上代码，我们把`url`中`?`号部分后面的参数分离出来，组成一个对象，在需要哪个参数的时候，我们只要调用`getQuery`中对应的属性就可以了。\n\n****\n\n### 学习到的经验\n\n#### 1. 添加标识符\n\n在写`ajax`的时候，在`ajax`的不同阶段，应该设置一个标识符来进行标识，以`jquery`的`ajax`为例，比如：`beforeSend`，`success`，`complete`等等不同的阶段，对发送`ajax`的状态来进行标识。\n\n这个经验其实是这样的：我在设置下拉加载更多的时候，发现有的时候可能会发出多次请求，如果我们在程序里加上一个标识符，就可以避免这个问题的发生，如下代码：\n\n```js\n\nbeforeSend: function(){\n    loading = true;\n    },\nsuccess: function(data){\n    page += 1;\n    },\ncomplete: function(){\n    loading = false;\n    }\n\n```\n\n如上代码这个只是举一个例子，并不是全部代码，逻辑大概是这样，当页面滑到底部，就发出一个请求请求`page+1`页的数据。如果我一次下拉发出多次请求的话，在`success`中的`page`就会累加多次，出现错误。如果我们添加了标识符后，当只有`loading`结束的时候才去发送下一次请求，所以当一些特殊情况比如网络不好的情况下，下拉了多次而`ajax`还没有发送成功的时候，是不会发送第二次`ajax`请求的。这样就能避免这个问题的产生。\n\n****\n\n#### 2. 可以通过url把参数带到下一个页面\n\n这个经验在上面的问题中已经说过了，而且我还听同事介绍了，其实这种方式是最常用的一种把参数传导下一个页面的办法，虽说这种办法显得url不够优雅。。。。。\n\n****\n\n#### 3. 如果url所带的参数中有汉字怎么办\n\n在我携带参数的时候，有的参数可能是汉字，而在参数带到下一个页面后，如果调用这个参数的话，会出现乱码类似于`%E5%B7%A5%E4`这样的。其实这个不是乱码，而是浏览器所做的`encodeURI编码`，而我们所要做的就是只要把它`decodeURI`解码后，我们就可以在下一个页面中正常的使用了。\n\n****\n\n#### 4. handlebars helpers的学习\n\n这个在上文中已经做了介绍，其实`helper`还能完成一些更复杂的逻辑，大家可以多试一试，比如我在遇到判断的类型多的时候就写了一个`switch`的`helper`。\n\n以上。\n","source":"_posts/2016-02-19-工作总结.md","raw":"---\nlayout: post\ntitle: 日常工作总结-2016-02-19\ndate: 2016-02-19\ntags: [handlebars,小数点精确,url携带参数]\ncategories: 工作总结\n---\n\n最近几天，在做一个类似列表的一个界面，在做的时候碰到了很多问题和总结了一些经验，在这里有必要记录一下。设计图如下：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_picdaozhang.jpg)\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_picdaozhang_detail.jpg)\n\n*****\n\n### 遇到的问题\n\n页面看起来并不复杂，可以后台返回的数据并不是很完整，所以遇到了一些问题，有的问题在我看来不是很难我这里就不再描述了（以我的水平如果觉得不难那一定是非常简单了。。。 - -），具体有以下四个问题：\n\n1. 后台返回的交易类型有三种，根据每种交易类型展示不同的图片，可以参考上面到账详情那张图片。\n2. 请看最近到账那张图片，列表的到账状态有四种，根据不同的状态展示的文字颜色需要不一样。\n3. 后台返回的金额都是以分为单位的，而页面上展示的是以元为单位的。\n4. 详情页面的有些信息后台并没有返回给你，必须从列表页面来获取这些信息运用到这个界面上。\n\n这就是遇到的几个比较让我头疼的问题，下面我来简单说一下每个问题的解决办法。\n\n******\n\n#### 1. 问题一和问题二\n\n问题一和二，其实就是模板语言上面的问题，现在加载页面有一些页面上要展示出来的数据其实是后台返回给你的。所以你要预先读取这些数据并通过浏览器渲染到你的页面上。基本做前端的同学应该都会用到模板语言，而我用的是`handlebars`这个模板语言（其实解决这个问题的办法是换一个模板语言，最后我会简单的说一下），我主要是描述一下用`handlebars`这个模板语言是怎么解决的。\n\n在`handlebars`当中的`#if`只能来做这个变量存不存在的简单判断，而不能在`if`当中加一些参数的判断，所以这里我们需要引用`handlebars helper`，在我理解这个其实就是用来补充`handlebars`中的不足的，在`handlebars helper`中可以进行一些复杂的判断，以我用的这个`helper`为例来分析一下，我这个`helper`的功能是这样的，他可以判断后台返回的一个字段的类型，如果类型是微信支付就显示微信支付的图标，如果是支付宝就显示支付宝的图标。\n\n```js\n\n//这里是注册了一个新的helper，名字叫做compare，而这个helper接受了三个参数，第一个和第二个参数是必填的，第三个参数是选填的\nHandlebars.registerHelper(\"compare\",function(v1,v2,options){\n\t //比较参数  满足条件添加继续执行\n    if(v1 == v2){\n        return options.fn(this);\n    }else{\n    //不满足条件执行{else}部分\n        return options.inverse(this);\n    }\n});\n\n```\n\n如上代码，注释写在了里面，我只想说一下`options.fn(this)`，其实这个意思就是执行下面的部分，这个部分其实不是在我们的js函数中，而是在我们引用这个`helper`的那个html页面中出现`# compare`的这个地方。看如下代码：\n\n```html\n\n//比较type是不是card\n   {#compare type 'card'}\n      <img src=\"img/ic_card.svg\" alt=\"\">\n     {else}\n      <img src=\"img/ic_weixin.svg\" alt=\"\">\n   {/compare}\n\n```\n\n如上，这个就是我在html页面的部分代码，`options.fn(this)`的功能就是执行`# compare`和`else`之间的代码。（以我浅显的理解，通俗的解释。。。。。）。\n\nPS:少写了一个花括号是因为双花括号在markdown语法中不能正常显示出来。。。。\n\n说完`handlebars`模板语言之后，我们来说另一种模板语言，`template.js`这个模板语法相比`handlebars`很轻量级，所以很适合移动端使用。他的语法和`handlebars`类似，而且他可以做一些比较复杂的逻辑判断，比如`if`判断来说他可以支持`if a > b || ( a < c && a == d )`这样的复杂判断。使用这样的模板语言，能够基本完成渲染时碰到的一些常用需求。\n\n****\n\n#### 2. 问题三\n\n后台返给我的数据是以`分`为单位的，而我要显示为以`元`为单位的并且保留两位小数，怎么办？其实这个函数是我网上搜索来的，因为我当时只是单纯的把返回的数据除以了100，这样是变成以`元`为单位了，但是没有保留两位小数。网上的具体方法是这样的：\n\n```js\n\n//分转换为元\nvar fen_yuan = function(val){\n    //toFixed来确定保留两位小数  因为除以100 所以都会整除\n    var str = (val/100).toFixed(2) + '';\n    var intSum = str.substring(0,str.indexOf(\".\")).replace( /\\B(?=(?:\\d{3})+$)/g, ',' );\n    //取到整数部分\n    var dot = str.substring(str.length,str.indexOf(\".\"))\n    //取到小数部分\n    var ret = intSum + dot;\n    return ret;\n}\n\n```\n\n如上代码，我给出了基本的注释，大家应该可以读懂，但是注意`tofixed()`这个函数会把小数点后面的部分进行四舍五入，所以不能得到精确结果。这个地方运用的因为是除以100，所以不存在不精确的问题，如果大家来使用的时候还是要参考当前的需求的。\n\n#### 3. 问题四\n\n有些时候我们在这个页面获得了一些数据，但是我们在去往下一个页面的时候还是需要这些数据而下一个页面的接口没有返回这些数据的时候怎么办？\n\n这时候就需要把我们需要的数据拼接到`url`当中，在到了下一个页面的时候，再把`url`中的参数分离出来，调用我们需要的一些参数。\n\n分离`url`参数的方法贴在下面，供大家参考。\n\n```js\n\nvar getQuery = function(){\n    var url=location.search;\n    var Request = {};\n    if(url.indexOf(\"?\")!=-1)\n    {\n        var str = url.substr(1);\n        strs = str.split(\"&\");\n        for(var i=0;i<strs.length;i++)\n        {\n            var _key = strs[i].split(\"=\")[0];\n            Request[_key]=strs[i].split(\"=\")[1];\n        }\n    }\n    return Request;\n};\n\n```\n\n如上代码，我们把`url`中`?`号部分后面的参数分离出来，组成一个对象，在需要哪个参数的时候，我们只要调用`getQuery`中对应的属性就可以了。\n\n****\n\n### 学习到的经验\n\n#### 1. 添加标识符\n\n在写`ajax`的时候，在`ajax`的不同阶段，应该设置一个标识符来进行标识，以`jquery`的`ajax`为例，比如：`beforeSend`，`success`，`complete`等等不同的阶段，对发送`ajax`的状态来进行标识。\n\n这个经验其实是这样的：我在设置下拉加载更多的时候，发现有的时候可能会发出多次请求，如果我们在程序里加上一个标识符，就可以避免这个问题的发生，如下代码：\n\n```js\n\nbeforeSend: function(){\n    loading = true;\n    },\nsuccess: function(data){\n    page += 1;\n    },\ncomplete: function(){\n    loading = false;\n    }\n\n```\n\n如上代码这个只是举一个例子，并不是全部代码，逻辑大概是这样，当页面滑到底部，就发出一个请求请求`page+1`页的数据。如果我一次下拉发出多次请求的话，在`success`中的`page`就会累加多次，出现错误。如果我们添加了标识符后，当只有`loading`结束的时候才去发送下一次请求，所以当一些特殊情况比如网络不好的情况下，下拉了多次而`ajax`还没有发送成功的时候，是不会发送第二次`ajax`请求的。这样就能避免这个问题的产生。\n\n****\n\n#### 2. 可以通过url把参数带到下一个页面\n\n这个经验在上面的问题中已经说过了，而且我还听同事介绍了，其实这种方式是最常用的一种把参数传导下一个页面的办法，虽说这种办法显得url不够优雅。。。。。\n\n****\n\n#### 3. 如果url所带的参数中有汉字怎么办\n\n在我携带参数的时候，有的参数可能是汉字，而在参数带到下一个页面后，如果调用这个参数的话，会出现乱码类似于`%E5%B7%A5%E4`这样的。其实这个不是乱码，而是浏览器所做的`encodeURI编码`，而我们所要做的就是只要把它`decodeURI`解码后，我们就可以在下一个页面中正常的使用了。\n\n****\n\n#### 4. handlebars helpers的学习\n\n这个在上文中已经做了介绍，其实`helper`还能完成一些更复杂的逻辑，大家可以多试一试，比如我在遇到判断的类型多的时候就写了一个`switch`的`helper`。\n\n以上。\n","slug":"工作总结","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1yn0010sq5lkeu6fv4y","content":"<p>最近几天，在做一个类似列表的一个界面，在做的时候碰到了很多问题和总结了一些经验，在这里有必要记录一下。设计图如下：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_picdaozhang.jpg\" alt=\"\"></p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_picdaozhang_detail.jpg\" alt=\"\"></p>\n<hr>\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><p>页面看起来并不复杂，可以后台返回的数据并不是很完整，所以遇到了一些问题，有的问题在我看来不是很难我这里就不再描述了（以我的水平如果觉得不难那一定是非常简单了。。。 - -），具体有以下四个问题：</p>\n<ol>\n<li>后台返回的交易类型有三种，根据每种交易类型展示不同的图片，可以参考上面到账详情那张图片。</li>\n<li>请看最近到账那张图片，列表的到账状态有四种，根据不同的状态展示的文字颜色需要不一样。</li>\n<li>后台返回的金额都是以分为单位的，而页面上展示的是以元为单位的。</li>\n<li>详情页面的有些信息后台并没有返回给你，必须从列表页面来获取这些信息运用到这个界面上。</li>\n</ol>\n<p>这就是遇到的几个比较让我头疼的问题，下面我来简单说一下每个问题的解决办法。</p>\n<hr>\n<h4 id=\"1-问题一和问题二\"><a href=\"#1-问题一和问题二\" class=\"headerlink\" title=\"1. 问题一和问题二\"></a>1. 问题一和问题二</h4><p>问题一和二，其实就是模板语言上面的问题，现在加载页面有一些页面上要展示出来的数据其实是后台返回给你的。所以你要预先读取这些数据并通过浏览器渲染到你的页面上。基本做前端的同学应该都会用到模板语言，而我用的是<code>handlebars</code>这个模板语言（其实解决这个问题的办法是换一个模板语言，最后我会简单的说一下），我主要是描述一下用<code>handlebars</code>这个模板语言是怎么解决的。</p>\n<p>在<code>handlebars</code>当中的<code>#if</code>只能来做这个变量存不存在的简单判断，而不能在<code>if</code>当中加一些参数的判断，所以这里我们需要引用<code>handlebars helper</code>，在我理解这个其实就是用来补充<code>handlebars</code>中的不足的，在<code>handlebars helper</code>中可以进行一些复杂的判断，以我用的这个<code>helper</code>为例来分析一下，我这个<code>helper</code>的功能是这样的，他可以判断后台返回的一个字段的类型，如果类型是微信支付就显示微信支付的图标，如果是支付宝就显示支付宝的图标。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里是注册了一个新的helper，名字叫做compare，而这个helper接受了三个参数，第一个和第二个参数是必填的，第三个参数是选填的</span></span><br><span class=\"line\">Handlebars.registerHelper(<span class=\"string\">\"compare\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v1,v2,options</span>)</span>&#123;</span><br><span class=\"line\">\t <span class=\"comment\">//比较参数  满足条件添加继续执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(v1 == v2)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> options.fn(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不满足条件执行&#123;else&#125;部分</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> options.inverse(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如上代码，注释写在了里面，我只想说一下<code>options.fn(this)</code>，其实这个意思就是执行下面的部分，这个部分其实不是在我们的js函数中，而是在我们引用这个<code>helper</code>的那个html页面中出现<code># compare</code>的这个地方。看如下代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">//比较type是不是card</span><br><span class=\"line\">   &#123;#compare type 'card'&#125;</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"img/ic_card.svg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">     &#123;else&#125;</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"img/ic_weixin.svg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">   &#123;/compare&#125;</span><br></pre></td></tr></table></figure>\n<p>如上，这个就是我在html页面的部分代码，<code>options.fn(this)</code>的功能就是执行<code># compare</code>和<code>else</code>之间的代码。（以我浅显的理解，通俗的解释。。。。。）。</p>\n<p>PS:少写了一个花括号是因为双花括号在markdown语法中不能正常显示出来。。。。</p>\n<p>说完<code>handlebars</code>模板语言之后，我们来说另一种模板语言，<code>template.js</code>这个模板语法相比<code>handlebars</code>很轻量级，所以很适合移动端使用。他的语法和<code>handlebars</code>类似，而且他可以做一些比较复杂的逻辑判断，比如<code>if</code>判断来说他可以支持<code>if a &gt; b || ( a &lt; c &amp;&amp; a == d )</code>这样的复杂判断。使用这样的模板语言，能够基本完成渲染时碰到的一些常用需求。</p>\n<hr>\n<h4 id=\"2-问题三\"><a href=\"#2-问题三\" class=\"headerlink\" title=\"2. 问题三\"></a>2. 问题三</h4><p>后台返给我的数据是以<code>分</code>为单位的，而我要显示为以<code>元</code>为单位的并且保留两位小数，怎么办？其实这个函数是我网上搜索来的，因为我当时只是单纯的把返回的数据除以了100，这样是变成以<code>元</code>为单位了，但是没有保留两位小数。网上的具体方法是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//分转换为元</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fen_yuan = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//toFixed来确定保留两位小数  因为除以100 所以都会整除</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> str = (val/<span class=\"number\">100</span>).toFixed(<span class=\"number\">2</span>) + <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> intSum = str.substring(<span class=\"number\">0</span>,str.indexOf(<span class=\"string\">\".\"</span>)).replace( <span class=\"regexp\">/\\B(?=(?:\\d&#123;3&#125;)+$)/g</span>, <span class=\"string\">','</span> );</span><br><span class=\"line\">    <span class=\"comment\">//取到整数部分</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dot = str.substring(str.length,str.indexOf(<span class=\"string\">\".\"</span>))</span><br><span class=\"line\">    <span class=\"comment\">//取到小数部分</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = intSum + dot;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码，我给出了基本的注释，大家应该可以读懂，但是注意<code>tofixed()</code>这个函数会把小数点后面的部分进行四舍五入，所以不能得到精确结果。这个地方运用的因为是除以100，所以不存在不精确的问题，如果大家来使用的时候还是要参考当前的需求的。</p>\n<h4 id=\"3-问题四\"><a href=\"#3-问题四\" class=\"headerlink\" title=\"3. 问题四\"></a>3. 问题四</h4><p>有些时候我们在这个页面获得了一些数据，但是我们在去往下一个页面的时候还是需要这些数据而下一个页面的接口没有返回这些数据的时候怎么办？</p>\n<p>这时候就需要把我们需要的数据拼接到<code>url</code>当中，在到了下一个页面的时候，再把<code>url</code>中的参数分离出来，调用我们需要的一些参数。</p>\n<p>分离<code>url</code>参数的方法贴在下面，供大家参考。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> url=location.search;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> Request = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(url.indexOf(<span class=\"string\">\"?\"</span>)!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> str = url.substr(<span class=\"number\">1</span>);</span><br><span class=\"line\">        strs = str.split(<span class=\"string\">\"&amp;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;strs.length;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> _key = strs[i].split(<span class=\"string\">\"=\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">            Request[_key]=strs[i].split(<span class=\"string\">\"=\"</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Request;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上代码，我们把<code>url</code>中<code>?</code>号部分后面的参数分离出来，组成一个对象，在需要哪个参数的时候，我们只要调用<code>getQuery</code>中对应的属性就可以了。</p>\n<hr>\n<h3 id=\"学习到的经验\"><a href=\"#学习到的经验\" class=\"headerlink\" title=\"学习到的经验\"></a>学习到的经验</h3><h4 id=\"1-添加标识符\"><a href=\"#1-添加标识符\" class=\"headerlink\" title=\"1. 添加标识符\"></a>1. 添加标识符</h4><p>在写<code>ajax</code>的时候，在<code>ajax</code>的不同阶段，应该设置一个标识符来进行标识，以<code>jquery</code>的<code>ajax</code>为例，比如：<code>beforeSend</code>，<code>success</code>，<code>complete</code>等等不同的阶段，对发送<code>ajax</code>的状态来进行标识。</p>\n<p>这个经验其实是这样的：我在设置下拉加载更多的时候，发现有的时候可能会发出多次请求，如果我们在程序里加上一个标识符，就可以避免这个问题的发生，如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">beforeSend: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    loading = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    page += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">complete: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    loading = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码这个只是举一个例子，并不是全部代码，逻辑大概是这样，当页面滑到底部，就发出一个请求请求<code>page+1</code>页的数据。如果我一次下拉发出多次请求的话，在<code>success</code>中的<code>page</code>就会累加多次，出现错误。如果我们添加了标识符后，当只有<code>loading</code>结束的时候才去发送下一次请求，所以当一些特殊情况比如网络不好的情况下，下拉了多次而<code>ajax</code>还没有发送成功的时候，是不会发送第二次<code>ajax</code>请求的。这样就能避免这个问题的产生。</p>\n<hr>\n<h4 id=\"2-可以通过url把参数带到下一个页面\"><a href=\"#2-可以通过url把参数带到下一个页面\" class=\"headerlink\" title=\"2. 可以通过url把参数带到下一个页面\"></a>2. 可以通过url把参数带到下一个页面</h4><p>这个经验在上面的问题中已经说过了，而且我还听同事介绍了，其实这种方式是最常用的一种把参数传导下一个页面的办法，虽说这种办法显得url不够优雅。。。。。</p>\n<hr>\n<h4 id=\"3-如果url所带的参数中有汉字怎么办\"><a href=\"#3-如果url所带的参数中有汉字怎么办\" class=\"headerlink\" title=\"3. 如果url所带的参数中有汉字怎么办\"></a>3. 如果url所带的参数中有汉字怎么办</h4><p>在我携带参数的时候，有的参数可能是汉字，而在参数带到下一个页面后，如果调用这个参数的话，会出现乱码类似于<code>%E5%B7%A5%E4</code>这样的。其实这个不是乱码，而是浏览器所做的<code>encodeURI编码</code>，而我们所要做的就是只要把它<code>decodeURI</code>解码后，我们就可以在下一个页面中正常的使用了。</p>\n<hr>\n<h4 id=\"4-handlebars-helpers的学习\"><a href=\"#4-handlebars-helpers的学习\" class=\"headerlink\" title=\"4. handlebars helpers的学习\"></a>4. handlebars helpers的学习</h4><p>这个在上文中已经做了介绍，其实<code>helper</code>还能完成一些更复杂的逻辑，大家可以多试一试，比如我在遇到判断的类型多的时候就写了一个<code>switch</code>的<code>helper</code>。</p>\n<p>以上。</p>\n","excerpt":"","more":"<p>最近几天，在做一个类似列表的一个界面，在做的时候碰到了很多问题和总结了一些经验，在这里有必要记录一下。设计图如下：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_picdaozhang.jpg\" alt=\"\"></p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_picdaozhang_detail.jpg\" alt=\"\"></p>\n<hr>\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><p>页面看起来并不复杂，可以后台返回的数据并不是很完整，所以遇到了一些问题，有的问题在我看来不是很难我这里就不再描述了（以我的水平如果觉得不难那一定是非常简单了。。。 - -），具体有以下四个问题：</p>\n<ol>\n<li>后台返回的交易类型有三种，根据每种交易类型展示不同的图片，可以参考上面到账详情那张图片。</li>\n<li>请看最近到账那张图片，列表的到账状态有四种，根据不同的状态展示的文字颜色需要不一样。</li>\n<li>后台返回的金额都是以分为单位的，而页面上展示的是以元为单位的。</li>\n<li>详情页面的有些信息后台并没有返回给你，必须从列表页面来获取这些信息运用到这个界面上。</li>\n</ol>\n<p>这就是遇到的几个比较让我头疼的问题，下面我来简单说一下每个问题的解决办法。</p>\n<hr>\n<h4 id=\"1-问题一和问题二\"><a href=\"#1-问题一和问题二\" class=\"headerlink\" title=\"1. 问题一和问题二\"></a>1. 问题一和问题二</h4><p>问题一和二，其实就是模板语言上面的问题，现在加载页面有一些页面上要展示出来的数据其实是后台返回给你的。所以你要预先读取这些数据并通过浏览器渲染到你的页面上。基本做前端的同学应该都会用到模板语言，而我用的是<code>handlebars</code>这个模板语言（其实解决这个问题的办法是换一个模板语言，最后我会简单的说一下），我主要是描述一下用<code>handlebars</code>这个模板语言是怎么解决的。</p>\n<p>在<code>handlebars</code>当中的<code>#if</code>只能来做这个变量存不存在的简单判断，而不能在<code>if</code>当中加一些参数的判断，所以这里我们需要引用<code>handlebars helper</code>，在我理解这个其实就是用来补充<code>handlebars</code>中的不足的，在<code>handlebars helper</code>中可以进行一些复杂的判断，以我用的这个<code>helper</code>为例来分析一下，我这个<code>helper</code>的功能是这样的，他可以判断后台返回的一个字段的类型，如果类型是微信支付就显示微信支付的图标，如果是支付宝就显示支付宝的图标。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里是注册了一个新的helper，名字叫做compare，而这个helper接受了三个参数，第一个和第二个参数是必填的，第三个参数是选填的</span></span><br><span class=\"line\">Handlebars.registerHelper(<span class=\"string\">\"compare\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v1,v2,options</span>)</span>&#123;</span><br><span class=\"line\">\t <span class=\"comment\">//比较参数  满足条件添加继续执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(v1 == v2)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> options.fn(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不满足条件执行&#123;else&#125;部分</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> options.inverse(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如上代码，注释写在了里面，我只想说一下<code>options.fn(this)</code>，其实这个意思就是执行下面的部分，这个部分其实不是在我们的js函数中，而是在我们引用这个<code>helper</code>的那个html页面中出现<code># compare</code>的这个地方。看如下代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">//比较type是不是card</span><br><span class=\"line\">   &#123;#compare type 'card'&#125;</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"img/ic_card.svg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">     &#123;else&#125;</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"img/ic_weixin.svg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\">   &#123;/compare&#125;</span><br></pre></td></tr></table></figure>\n<p>如上，这个就是我在html页面的部分代码，<code>options.fn(this)</code>的功能就是执行<code># compare</code>和<code>else</code>之间的代码。（以我浅显的理解，通俗的解释。。。。。）。</p>\n<p>PS:少写了一个花括号是因为双花括号在markdown语法中不能正常显示出来。。。。</p>\n<p>说完<code>handlebars</code>模板语言之后，我们来说另一种模板语言，<code>template.js</code>这个模板语法相比<code>handlebars</code>很轻量级，所以很适合移动端使用。他的语法和<code>handlebars</code>类似，而且他可以做一些比较复杂的逻辑判断，比如<code>if</code>判断来说他可以支持<code>if a &gt; b || ( a &lt; c &amp;&amp; a == d )</code>这样的复杂判断。使用这样的模板语言，能够基本完成渲染时碰到的一些常用需求。</p>\n<hr>\n<h4 id=\"2-问题三\"><a href=\"#2-问题三\" class=\"headerlink\" title=\"2. 问题三\"></a>2. 问题三</h4><p>后台返给我的数据是以<code>分</code>为单位的，而我要显示为以<code>元</code>为单位的并且保留两位小数，怎么办？其实这个函数是我网上搜索来的，因为我当时只是单纯的把返回的数据除以了100，这样是变成以<code>元</code>为单位了，但是没有保留两位小数。网上的具体方法是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//分转换为元</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fen_yuan = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//toFixed来确定保留两位小数  因为除以100 所以都会整除</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> str = (val/<span class=\"number\">100</span>).toFixed(<span class=\"number\">2</span>) + <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> intSum = str.substring(<span class=\"number\">0</span>,str.indexOf(<span class=\"string\">\".\"</span>)).replace( <span class=\"regexp\">/\\B(?=(?:\\d&#123;3&#125;)+$)/g</span>, <span class=\"string\">','</span> );</span><br><span class=\"line\">    <span class=\"comment\">//取到整数部分</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dot = str.substring(str.length,str.indexOf(<span class=\"string\">\".\"</span>))</span><br><span class=\"line\">    <span class=\"comment\">//取到小数部分</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> ret = intSum + dot;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码，我给出了基本的注释，大家应该可以读懂，但是注意<code>tofixed()</code>这个函数会把小数点后面的部分进行四舍五入，所以不能得到精确结果。这个地方运用的因为是除以100，所以不存在不精确的问题，如果大家来使用的时候还是要参考当前的需求的。</p>\n<h4 id=\"3-问题四\"><a href=\"#3-问题四\" class=\"headerlink\" title=\"3. 问题四\"></a>3. 问题四</h4><p>有些时候我们在这个页面获得了一些数据，但是我们在去往下一个页面的时候还是需要这些数据而下一个页面的接口没有返回这些数据的时候怎么办？</p>\n<p>这时候就需要把我们需要的数据拼接到<code>url</code>当中，在到了下一个页面的时候，再把<code>url</code>中的参数分离出来，调用我们需要的一些参数。</p>\n<p>分离<code>url</code>参数的方法贴在下面，供大家参考。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> getQuery = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> url=location.search;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> Request = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(url.indexOf(<span class=\"string\">\"?\"</span>)!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> str = url.substr(<span class=\"number\">1</span>);</span><br><span class=\"line\">        strs = str.split(<span class=\"string\">\"&amp;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;strs.length;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> _key = strs[i].split(<span class=\"string\">\"=\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">            Request[_key]=strs[i].split(<span class=\"string\">\"=\"</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Request;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如上代码，我们把<code>url</code>中<code>?</code>号部分后面的参数分离出来，组成一个对象，在需要哪个参数的时候，我们只要调用<code>getQuery</code>中对应的属性就可以了。</p>\n<hr>\n<h3 id=\"学习到的经验\"><a href=\"#学习到的经验\" class=\"headerlink\" title=\"学习到的经验\"></a>学习到的经验</h3><h4 id=\"1-添加标识符\"><a href=\"#1-添加标识符\" class=\"headerlink\" title=\"1. 添加标识符\"></a>1. 添加标识符</h4><p>在写<code>ajax</code>的时候，在<code>ajax</code>的不同阶段，应该设置一个标识符来进行标识，以<code>jquery</code>的<code>ajax</code>为例，比如：<code>beforeSend</code>，<code>success</code>，<code>complete</code>等等不同的阶段，对发送<code>ajax</code>的状态来进行标识。</p>\n<p>这个经验其实是这样的：我在设置下拉加载更多的时候，发现有的时候可能会发出多次请求，如果我们在程序里加上一个标识符，就可以避免这个问题的发生，如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">beforeSend: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    loading = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    page += <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">complete: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    loading = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码这个只是举一个例子，并不是全部代码，逻辑大概是这样，当页面滑到底部，就发出一个请求请求<code>page+1</code>页的数据。如果我一次下拉发出多次请求的话，在<code>success</code>中的<code>page</code>就会累加多次，出现错误。如果我们添加了标识符后，当只有<code>loading</code>结束的时候才去发送下一次请求，所以当一些特殊情况比如网络不好的情况下，下拉了多次而<code>ajax</code>还没有发送成功的时候，是不会发送第二次<code>ajax</code>请求的。这样就能避免这个问题的产生。</p>\n<hr>\n<h4 id=\"2-可以通过url把参数带到下一个页面\"><a href=\"#2-可以通过url把参数带到下一个页面\" class=\"headerlink\" title=\"2. 可以通过url把参数带到下一个页面\"></a>2. 可以通过url把参数带到下一个页面</h4><p>这个经验在上面的问题中已经说过了，而且我还听同事介绍了，其实这种方式是最常用的一种把参数传导下一个页面的办法，虽说这种办法显得url不够优雅。。。。。</p>\n<hr>\n<h4 id=\"3-如果url所带的参数中有汉字怎么办\"><a href=\"#3-如果url所带的参数中有汉字怎么办\" class=\"headerlink\" title=\"3. 如果url所带的参数中有汉字怎么办\"></a>3. 如果url所带的参数中有汉字怎么办</h4><p>在我携带参数的时候，有的参数可能是汉字，而在参数带到下一个页面后，如果调用这个参数的话，会出现乱码类似于<code>%E5%B7%A5%E4</code>这样的。其实这个不是乱码，而是浏览器所做的<code>encodeURI编码</code>，而我们所要做的就是只要把它<code>decodeURI</code>解码后，我们就可以在下一个页面中正常的使用了。</p>\n<hr>\n<h4 id=\"4-handlebars-helpers的学习\"><a href=\"#4-handlebars-helpers的学习\" class=\"headerlink\" title=\"4. handlebars helpers的学习\"></a>4. handlebars helpers的学习</h4><p>这个在上文中已经做了介绍，其实<code>helper</code>还能完成一些更复杂的逻辑，大家可以多试一试，比如我在遇到判断的类型多的时候就写了一个<code>switch</code>的<code>helper</code>。</p>\n<p>以上。</p>\n"},{"layout":"post","title":"初学React遇到的坑","date":"2016-02-16T16:00:00.000Z","_content":"\n新建一个React.createClass时，变量名的首字母必须大写！！ 不然渲染出来的变量名变成了html的标签名。\n\n在render里面写的标签必须有闭合符号（单标签也要有闭合符号），如`<p>xxxxxx</p>`或`<input />` \n\nchrome里面有一个`React Developer Tool`的扩展程序，安装这个插件之后，打开开发者面板后，上面一栏会显示一个`react`的选项，\n","source":"_posts/2016-02-18-初学React遇到的坑.md","raw":"---\nlayout: post\ntitle: 初学React遇到的坑\ndate: 2016-02-17\ntags: [React]\ncategories: React\n---\n\n新建一个React.createClass时，变量名的首字母必须大写！！ 不然渲染出来的变量名变成了html的标签名。\n\n在render里面写的标签必须有闭合符号（单标签也要有闭合符号），如`<p>xxxxxx</p>`或`<input />` \n\nchrome里面有一个`React Developer Tool`的扩展程序，安装这个插件之后，打开开发者面板后，上面一栏会显示一个`react`的选项，\n","slug":"初学React遇到的坑","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1yo0015sq5l4epynmyy","content":"<p>新建一个React.createClass时，变量名的首字母必须大写！！ 不然渲染出来的变量名变成了html的标签名。</p>\n<p>在render里面写的标签必须有闭合符号（单标签也要有闭合符号），如<code>&lt;p&gt;xxxxxx&lt;/p&gt;</code>或<code>&lt;input /&gt;</code> </p>\n<p>chrome里面有一个<code>React Developer Tool</code>的扩展程序，安装这个插件之后，打开开发者面板后，上面一栏会显示一个<code>react</code>的选项，</p>\n","excerpt":"","more":"<p>新建一个React.createClass时，变量名的首字母必须大写！！ 不然渲染出来的变量名变成了html的标签名。</p>\n<p>在render里面写的标签必须有闭合符号（单标签也要有闭合符号），如<code>&lt;p&gt;xxxxxx&lt;/p&gt;</code>或<code>&lt;input /&gt;</code> </p>\n<p>chrome里面有一个<code>React Developer Tool</code>的扩展程序，安装这个插件之后，打开开发者面板后，上面一栏会显示一个<code>react</code>的选项，</p>\n"},{"layout":"post","title":"日常工作总结-2016-03-10","date":"2016-03-09T16:00:00.000Z","_content":"\n\n这个星期，接到了一个红包页面的任务，逻辑方面并不是特别复杂，但是在仔细想过之后也可以实现。最让我头疼的问题是调微信的两个接口：一个是登录接口，另一个是注册JSSDK的接口，因为我从来没有接触过这个问题，所以遇到了很多的坑，这也直接导致和我配合的后台同学受到了我的拖累，调接口用了很长很长时间。\n\n首先我们先来看一下这个页面的逻辑，然后分析一下这两个接口的JS，最后说一说我碰到的一些坑和学到的东西吧。\n\n### 1.页面的逻辑\n\n首先来看一下页面的逻辑，我做了一张图，大致的逻辑就是这样，其中可以还包含着一些交互和动画方面的细节，我这里就详细阐述了。逻辑如下图：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_1.png)\n\n****\n\n\n### 2.分析接口\n\n首先，这两个接口分别是，微信授权登录的接口和注册JSSDK的接口。\n\n#### 1.微信授权登录的接口\n\n```js\n\nvar redirect_uri = 'https://marketing.qfpay.com/v1/mkw/page_obtain?share_code=' + code;\n\nvar redirect_uri = encodeURIComponent(redirect_uri);\n\nlocation.href = 'https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxeb6e671f5571abce&redirect_uri=https://o2.qfpay.com/trade/wechat/v1/get_weixin_code&response_type=code&scope=snsapi_userinfo&state='+redirect_uri;\n\n```\n\n具体后台是怎么处理的我不是特别清楚，大概是这样，open.weixin这个登录接口，是会接收两个参数的`appid`应该是公众号的一个唯一标识，标识是授权给这个公众号登陆的，还有一个参数是`redirect_url`这个是经过微信授权后你要跳转回的链接，这个链接是跳回到后台，后台要对url进行处理后再返回给前端的页面。\n\n**这里要注意一个问题就是本来我们要对`redirect_url`这个参数进行URI编码处理，原因是因为如果不进行编码处理，url传到后台的时候可能会出现问题。**\n\n*****\n\n#### 2.JSSDK\n\n这个简单来其实就是用微信给的一些方法，来调出微信一些功能，比如分享朋友圈，发送给朋友等等。也可以根据微信给出的一些方法，来禁用掉微信的一些按钮。\n\n这也是我遇到困难最多的地方，可能是第一次接触吧，所以对其中的一些原理不是太了解，所以做了很多蠢事，再次对后台配合的同学感到抱歉啊，现在就来分析分析这个JSSDK吧。\n\n首先我们可以看一下微信的官方文档，点击[这里](http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html)。\n\n第一步我们暂时忽略，引入JS文件，这里要注意`http`和`https`协议要引入的JS是不一样的这里大家要注意一下。\n\n第三步，`wx.config`这个接口，我们需要先注入一些配置信息，我在这里也遇到问题，这个是我粗心没有仔细阅读文档，在`jsApiList`这个配置项当中，之后所有要调用的方法都要先通过这里注册，如果没有的话，下面的调用都是无效的。\n\n第四步，`ready`接口中可以监听各个接口的事件，比如点击哪个按钮后出发什么事件等等。（可能我说的不够准确，按我自己的理解来说）。\n\n下面来读一下代码，来总结和再次理解一下，代码是原来同事已经写好的一个一些代码，就是做JSSDK注册的。我们只要读懂，并能按实际应用来修改就好了。\n\n\n```js\n\n//这里是来发一个ajax来获取一些，这里是用了一个原生的ajax请求\n\nvar configWx = function(cb) {\n\t\t//新new了一个xhr对象\n        var xhrHttp = new XMLHttpRequest();\n        //取用get请求去访问这个接口，这个接口的作用可能是会返回一些需要wx.config的配置项\n        xhrHttp.open(\"GET\",'/v1/manage/wxjs_conf?url='+ encodeURIComponent(location.href));\n        xhrHttp.send(null);\n        xhrHttp.onreadystatechange = function() {\n        //如果服务器返回了正确而的状态码\n            if ((xhrHttp.readyState == 4) && (xhrHttp.status == 200)) {\n            //把返回的text变成一个json对象\n                var data  = JSON.parse(xhrHttp.responseText);\n                var respCode = data.respcd;\n                if (respCode === '0000') {\n                    data = data.data;\n                    data.debug = false;\n                    //这里是要调用到的所有微信的接口 必须在这里先初始化\n                    data.jsApiList = [\n                        'checkJsApi',\n                        'hideAllNonBaseMenuItem',\n                        'showMenuItems',\n                        'onMenuShareTimeline',\n                        'onMenuShareAppMessage',\n                        'onMenuShareQQ',\n                        'onMenuShareWeibo'\n                    ];\n                    //这里的shareUrl是 其他JS中\n                    data.url = shareUrl;\n                    wx.config(data);\n                    if (cb) {\n                        cb();\n                    }\n                }\n            }\n        }\n    };\n    var share = function(data) {\n        //data.appId = data.appId || 'wxeb6e671f5571abce';\n        data.desc = util.removeHtmlTab(util.escape2Html(data.desc)).substring(0, 100);\n        if (!data.isConfiged) {\n            configWx();\n        }\n        wx.ready(function() {\n            // 2. 分享接口\n            // 2.1 监听“分享给朋友”，按钮点击、自定义分享内容及分享结果接口\n            wx.onMenuShareAppMessage(data);\n            // 2.2 监听“分享到朋友圈”按钮点击、自定义分享内容及分享结果接口\n            wx.onMenuShareTimeline(data);\n            // 2.3 监听“分享到QQ”按钮点击、自定义分享内容及分享结果接口\n            wx.onMenuShareQQ(data);\n            // 2.4 监听“分享到微博”按钮点击、自定义分享内容及分享结果接口\n            wx.onMenuShareWeibo(data);\n            wx.hideAllNonBaseMenuItem({\n                success: function(){\n                //注意 这里因为在hideAllNonBaseMenuItem的回调里有showMenuItems接口，所以showMenuItems也必须在jsApiList中初始化。\n                    wx.showMenuItems({\n                        menuList: ['menuItem:share:appMessage']\n                    });\n                }\n            });\n        });\n    };\n    //可以自己定义分享内容接口\n    // title: '', // 分享标题\n    //desc: '', // 分享描述\n    //link: '', // 分享链接\n    //imgUrl: '', // 分享图标\n    \n    share({\n        link: shareUrl,\n        title: shareTitle,\n        desc: shareDesc,\n        imgUrl: shareIconurl\n    });\n\n```\n\n这个就是大概我在这个JSSDK中所用到的代码了，但是因为是第一次用，在修改代码的时候，出现了很多错误，这也导致了，分享的JSSDK注册的失败，在调用分享接口获取分享内容时，调用失败，等等的错误。下面我来举几个例子。\n\n首先，是我在调用接口之前，没有在`jsApiList`当中注册，这就导致调用的这个接口是不起作用的。还有当我们调`share`这个函数的时候，我们把所有所有要自定义的内容其实都写到了`data`这个对象的里面了。当时我一开始自己手贱删了`wx.onMenuShareAppMessage(data)`这个，导致再按了分享按钮之后，不能正常定义分享的内容了。之后把这个加上了但还是不起作用。这是因为我蠢，我的代码是这么写的。\n\n\n```js\n\n    wx.onMenuShareAppMessage(data);\n    // 2.2 监听“分享到朋友圈”按钮点击、自定义分享内容及分享结果接口\n    wx.onMenuShareTimeline(data);\n    // 2.3 监听“分享到QQ”按钮点击、自定义分享内容及分享结果接口\n    wx.onMenuShareQQ(data);\n    // 2.4 监听“分享到微博”按钮点击、自定义分享内容及分享结果接口\n    wx.onMenuShareWeibo(data);\n\n    wx.hideAllNonBaseMenuItem({\n        success: function(){\n            wx.showMenuItems({\n                menuList: ['menuItem:share:appMessage']\n            });\n        }\n    });\n    wx.onMenuShareAppMessage({\n        success: function () {\n            $('#cover').css({display : 'none'});\n        },\n        trigger : function(){\n            $('#cover').css({display : 'none'});\n        },\n    });\n    \n```\n\n\n不知道大家看没看出来问题。我原意是想，在定义了分享内容的同时，来监听一下这个按钮，如果确认分享以后，我执行回调函数，把引导分享的遮罩层隐藏掉。但是这里问题出现了，我很想当然的觉得这么写没有问题，但如果两次来调用这个接口，其实第一次调用时的赋值就被覆盖了。所以我不能正常的自定义分享内容了。\n\n那应该怎么写呢？应该这样，把这个也写到data对象当中。\n\n```js\n\nshare({\n        link: shareUrl,\n        title: shareTitle,\n        desc: shareDesc,\n        imgUrl: shareIconurl,\n        success : function(){\n        \t\t//回调\n        },\n        trigger : function(){\n        \t\t//回调\n        }\n    });\n\n```\n\n如上代码，就可以完成这个功能了。\n\n其实我觉得呢，调用这些接口都是一个熟练功，第一次可能会出现很多问题，但是越用就会越熟悉，我觉得在我下次再调用这个接口的时候，我该不会出现这些低级的问题了。（话说我觉得我计算机基础真的很差）。\n\n******\n\n### 3. 这次项目遇到的一些坑\n\n这次的坑我觉得有两个：\n\n#### 1. translate3d 位移后会占据空间\n\n这个问题和需求是有关系的，红包要求上下打开，我使用的就是`translate3d`配合`animation`来实现的，一般在css中动画不要用`position`的位移，因为如果手机性能不好的话，动画会很卡。所以都会用`translate`、`transform`、`animation`配合来用。但是我发现了，`translate`之后的部分，是会占据空间的。这个导致我的红包上下打开之后，下面会把页面撑的很长，即使在我页面下面没有内容的时候，依旧会留下很大的空白。\n\n我解决的本法是，用了一种变通的方法。\n\n```js\n\n@keyframes downward {\n  0% {-webkit-transform:translate3d(0,0,0); transform:translate3d(0,0,0); display: none; opacity: 1;}\n  99% {-webkit-transform:translate3d(0,15.3333rem,0); transform:translate3d(0,15.3333rem,0); display: none; opacity: 0.5;}\n  100%{-webkit-transform:translate3d(0,-20.3333rem,0); transform: translate3d(0,-20.3333rem,0); display: none; opacity: 0;}\n\n```\n\n如上代码所示，因为我发现，在页面的上边超出的部分是不会使页面变化的，所以我在动画结束之前，把向下移动的部分，变成透明并快速移到页面的上方。这样视觉上并不会有变化，也能解决这个问题，但是我觉得这始终是个投机取巧的办法。但是因为我上网没有搜索到答案，和问题的根源，所以最后用了这种折中的方法。\n\n*******\n\n#### 2. iOS微信不能识别二维码的问题\n\n这个问题在安卓手机上是不存在的，之后再iOS中会存在。网上搜索了一下解决办法，但是说的那些问题可能微信官方其实已经解决了，所以我试了那些办法都没有成功。我不知道产生的原因是什么，但是加上这个meta标签确实是可以识别二维码了。`<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0, maximum-scale=1.0,user-scalable=no\"/>`。\n\n还学到了一些经验吧，在不同环境测试的时候，需要配置的域名都是不一样的，所以在切换环境的时候，如果你配置的域名是写死的，那等到切换环境的时候是非常辛苦而且容易出错的。就拿昨天的上线来说，我真是对和自己配合的后台小伙伴感到抱歉，因为我经验的不足，从线上测到线下。。。。来回切环境，结果就是域名得来回改。\n\n下次我知道了，应该把需要配置的参数，写到一个对象里面，改的时候直接改这个对象就可以了，而不用在所有代码中来回改。。。。只能说我太年轻了。。。哎悲剧死了。。。。。\n\n问题差不多就这么多总结完了，回家睡觉。\n\n\n\n\n","source":"_posts/2016-03-10-工作总结.md","raw":"---\nlayout: post\ntitle: 日常工作总结-2016-03-10\ndate: 2016-03-10\ntags: [JSSDK,iOS微信二维码]\ncategories: 工作总结\n---\n\n\n这个星期，接到了一个红包页面的任务，逻辑方面并不是特别复杂，但是在仔细想过之后也可以实现。最让我头疼的问题是调微信的两个接口：一个是登录接口，另一个是注册JSSDK的接口，因为我从来没有接触过这个问题，所以遇到了很多的坑，这也直接导致和我配合的后台同学受到了我的拖累，调接口用了很长很长时间。\n\n首先我们先来看一下这个页面的逻辑，然后分析一下这两个接口的JS，最后说一说我碰到的一些坑和学到的东西吧。\n\n### 1.页面的逻辑\n\n首先来看一下页面的逻辑，我做了一张图，大致的逻辑就是这样，其中可以还包含着一些交互和动画方面的细节，我这里就详细阐述了。逻辑如下图：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_1.png)\n\n****\n\n\n### 2.分析接口\n\n首先，这两个接口分别是，微信授权登录的接口和注册JSSDK的接口。\n\n#### 1.微信授权登录的接口\n\n```js\n\nvar redirect_uri = 'https://marketing.qfpay.com/v1/mkw/page_obtain?share_code=' + code;\n\nvar redirect_uri = encodeURIComponent(redirect_uri);\n\nlocation.href = 'https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxeb6e671f5571abce&redirect_uri=https://o2.qfpay.com/trade/wechat/v1/get_weixin_code&response_type=code&scope=snsapi_userinfo&state='+redirect_uri;\n\n```\n\n具体后台是怎么处理的我不是特别清楚，大概是这样，open.weixin这个登录接口，是会接收两个参数的`appid`应该是公众号的一个唯一标识，标识是授权给这个公众号登陆的，还有一个参数是`redirect_url`这个是经过微信授权后你要跳转回的链接，这个链接是跳回到后台，后台要对url进行处理后再返回给前端的页面。\n\n**这里要注意一个问题就是本来我们要对`redirect_url`这个参数进行URI编码处理，原因是因为如果不进行编码处理，url传到后台的时候可能会出现问题。**\n\n*****\n\n#### 2.JSSDK\n\n这个简单来其实就是用微信给的一些方法，来调出微信一些功能，比如分享朋友圈，发送给朋友等等。也可以根据微信给出的一些方法，来禁用掉微信的一些按钮。\n\n这也是我遇到困难最多的地方，可能是第一次接触吧，所以对其中的一些原理不是太了解，所以做了很多蠢事，再次对后台配合的同学感到抱歉啊，现在就来分析分析这个JSSDK吧。\n\n首先我们可以看一下微信的官方文档，点击[这里](http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html)。\n\n第一步我们暂时忽略，引入JS文件，这里要注意`http`和`https`协议要引入的JS是不一样的这里大家要注意一下。\n\n第三步，`wx.config`这个接口，我们需要先注入一些配置信息，我在这里也遇到问题，这个是我粗心没有仔细阅读文档，在`jsApiList`这个配置项当中，之后所有要调用的方法都要先通过这里注册，如果没有的话，下面的调用都是无效的。\n\n第四步，`ready`接口中可以监听各个接口的事件，比如点击哪个按钮后出发什么事件等等。（可能我说的不够准确，按我自己的理解来说）。\n\n下面来读一下代码，来总结和再次理解一下，代码是原来同事已经写好的一个一些代码，就是做JSSDK注册的。我们只要读懂，并能按实际应用来修改就好了。\n\n\n```js\n\n//这里是来发一个ajax来获取一些，这里是用了一个原生的ajax请求\n\nvar configWx = function(cb) {\n\t\t//新new了一个xhr对象\n        var xhrHttp = new XMLHttpRequest();\n        //取用get请求去访问这个接口，这个接口的作用可能是会返回一些需要wx.config的配置项\n        xhrHttp.open(\"GET\",'/v1/manage/wxjs_conf?url='+ encodeURIComponent(location.href));\n        xhrHttp.send(null);\n        xhrHttp.onreadystatechange = function() {\n        //如果服务器返回了正确而的状态码\n            if ((xhrHttp.readyState == 4) && (xhrHttp.status == 200)) {\n            //把返回的text变成一个json对象\n                var data  = JSON.parse(xhrHttp.responseText);\n                var respCode = data.respcd;\n                if (respCode === '0000') {\n                    data = data.data;\n                    data.debug = false;\n                    //这里是要调用到的所有微信的接口 必须在这里先初始化\n                    data.jsApiList = [\n                        'checkJsApi',\n                        'hideAllNonBaseMenuItem',\n                        'showMenuItems',\n                        'onMenuShareTimeline',\n                        'onMenuShareAppMessage',\n                        'onMenuShareQQ',\n                        'onMenuShareWeibo'\n                    ];\n                    //这里的shareUrl是 其他JS中\n                    data.url = shareUrl;\n                    wx.config(data);\n                    if (cb) {\n                        cb();\n                    }\n                }\n            }\n        }\n    };\n    var share = function(data) {\n        //data.appId = data.appId || 'wxeb6e671f5571abce';\n        data.desc = util.removeHtmlTab(util.escape2Html(data.desc)).substring(0, 100);\n        if (!data.isConfiged) {\n            configWx();\n        }\n        wx.ready(function() {\n            // 2. 分享接口\n            // 2.1 监听“分享给朋友”，按钮点击、自定义分享内容及分享结果接口\n            wx.onMenuShareAppMessage(data);\n            // 2.2 监听“分享到朋友圈”按钮点击、自定义分享内容及分享结果接口\n            wx.onMenuShareTimeline(data);\n            // 2.3 监听“分享到QQ”按钮点击、自定义分享内容及分享结果接口\n            wx.onMenuShareQQ(data);\n            // 2.4 监听“分享到微博”按钮点击、自定义分享内容及分享结果接口\n            wx.onMenuShareWeibo(data);\n            wx.hideAllNonBaseMenuItem({\n                success: function(){\n                //注意 这里因为在hideAllNonBaseMenuItem的回调里有showMenuItems接口，所以showMenuItems也必须在jsApiList中初始化。\n                    wx.showMenuItems({\n                        menuList: ['menuItem:share:appMessage']\n                    });\n                }\n            });\n        });\n    };\n    //可以自己定义分享内容接口\n    // title: '', // 分享标题\n    //desc: '', // 分享描述\n    //link: '', // 分享链接\n    //imgUrl: '', // 分享图标\n    \n    share({\n        link: shareUrl,\n        title: shareTitle,\n        desc: shareDesc,\n        imgUrl: shareIconurl\n    });\n\n```\n\n这个就是大概我在这个JSSDK中所用到的代码了，但是因为是第一次用，在修改代码的时候，出现了很多错误，这也导致了，分享的JSSDK注册的失败，在调用分享接口获取分享内容时，调用失败，等等的错误。下面我来举几个例子。\n\n首先，是我在调用接口之前，没有在`jsApiList`当中注册，这就导致调用的这个接口是不起作用的。还有当我们调`share`这个函数的时候，我们把所有所有要自定义的内容其实都写到了`data`这个对象的里面了。当时我一开始自己手贱删了`wx.onMenuShareAppMessage(data)`这个，导致再按了分享按钮之后，不能正常定义分享的内容了。之后把这个加上了但还是不起作用。这是因为我蠢，我的代码是这么写的。\n\n\n```js\n\n    wx.onMenuShareAppMessage(data);\n    // 2.2 监听“分享到朋友圈”按钮点击、自定义分享内容及分享结果接口\n    wx.onMenuShareTimeline(data);\n    // 2.3 监听“分享到QQ”按钮点击、自定义分享内容及分享结果接口\n    wx.onMenuShareQQ(data);\n    // 2.4 监听“分享到微博”按钮点击、自定义分享内容及分享结果接口\n    wx.onMenuShareWeibo(data);\n\n    wx.hideAllNonBaseMenuItem({\n        success: function(){\n            wx.showMenuItems({\n                menuList: ['menuItem:share:appMessage']\n            });\n        }\n    });\n    wx.onMenuShareAppMessage({\n        success: function () {\n            $('#cover').css({display : 'none'});\n        },\n        trigger : function(){\n            $('#cover').css({display : 'none'});\n        },\n    });\n    \n```\n\n\n不知道大家看没看出来问题。我原意是想，在定义了分享内容的同时，来监听一下这个按钮，如果确认分享以后，我执行回调函数，把引导分享的遮罩层隐藏掉。但是这里问题出现了，我很想当然的觉得这么写没有问题，但如果两次来调用这个接口，其实第一次调用时的赋值就被覆盖了。所以我不能正常的自定义分享内容了。\n\n那应该怎么写呢？应该这样，把这个也写到data对象当中。\n\n```js\n\nshare({\n        link: shareUrl,\n        title: shareTitle,\n        desc: shareDesc,\n        imgUrl: shareIconurl,\n        success : function(){\n        \t\t//回调\n        },\n        trigger : function(){\n        \t\t//回调\n        }\n    });\n\n```\n\n如上代码，就可以完成这个功能了。\n\n其实我觉得呢，调用这些接口都是一个熟练功，第一次可能会出现很多问题，但是越用就会越熟悉，我觉得在我下次再调用这个接口的时候，我该不会出现这些低级的问题了。（话说我觉得我计算机基础真的很差）。\n\n******\n\n### 3. 这次项目遇到的一些坑\n\n这次的坑我觉得有两个：\n\n#### 1. translate3d 位移后会占据空间\n\n这个问题和需求是有关系的，红包要求上下打开，我使用的就是`translate3d`配合`animation`来实现的，一般在css中动画不要用`position`的位移，因为如果手机性能不好的话，动画会很卡。所以都会用`translate`、`transform`、`animation`配合来用。但是我发现了，`translate`之后的部分，是会占据空间的。这个导致我的红包上下打开之后，下面会把页面撑的很长，即使在我页面下面没有内容的时候，依旧会留下很大的空白。\n\n我解决的本法是，用了一种变通的方法。\n\n```js\n\n@keyframes downward {\n  0% {-webkit-transform:translate3d(0,0,0); transform:translate3d(0,0,0); display: none; opacity: 1;}\n  99% {-webkit-transform:translate3d(0,15.3333rem,0); transform:translate3d(0,15.3333rem,0); display: none; opacity: 0.5;}\n  100%{-webkit-transform:translate3d(0,-20.3333rem,0); transform: translate3d(0,-20.3333rem,0); display: none; opacity: 0;}\n\n```\n\n如上代码所示，因为我发现，在页面的上边超出的部分是不会使页面变化的，所以我在动画结束之前，把向下移动的部分，变成透明并快速移到页面的上方。这样视觉上并不会有变化，也能解决这个问题，但是我觉得这始终是个投机取巧的办法。但是因为我上网没有搜索到答案，和问题的根源，所以最后用了这种折中的方法。\n\n*******\n\n#### 2. iOS微信不能识别二维码的问题\n\n这个问题在安卓手机上是不存在的，之后再iOS中会存在。网上搜索了一下解决办法，但是说的那些问题可能微信官方其实已经解决了，所以我试了那些办法都没有成功。我不知道产生的原因是什么，但是加上这个meta标签确实是可以识别二维码了。`<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0, maximum-scale=1.0,user-scalable=no\"/>`。\n\n还学到了一些经验吧，在不同环境测试的时候，需要配置的域名都是不一样的，所以在切换环境的时候，如果你配置的域名是写死的，那等到切换环境的时候是非常辛苦而且容易出错的。就拿昨天的上线来说，我真是对和自己配合的后台小伙伴感到抱歉，因为我经验的不足，从线上测到线下。。。。来回切环境，结果就是域名得来回改。\n\n下次我知道了，应该把需要配置的参数，写到一个对象里面，改的时候直接改这个对象就可以了，而不用在所有代码中来回改。。。。只能说我太年轻了。。。哎悲剧死了。。。。。\n\n问题差不多就这么多总结完了，回家睡觉。\n\n\n\n\n","slug":"工作总结","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1yq0018sq5lre8syy0i","content":"<p>这个星期，接到了一个红包页面的任务，逻辑方面并不是特别复杂，但是在仔细想过之后也可以实现。最让我头疼的问题是调微信的两个接口：一个是登录接口，另一个是注册JSSDK的接口，因为我从来没有接触过这个问题，所以遇到了很多的坑，这也直接导致和我配合的后台同学受到了我的拖累，调接口用了很长很长时间。</p>\n<p>首先我们先来看一下这个页面的逻辑，然后分析一下这两个接口的JS，最后说一说我碰到的一些坑和学到的东西吧。</p>\n<h3 id=\"1-页面的逻辑\"><a href=\"#1-页面的逻辑\" class=\"headerlink\" title=\"1.页面的逻辑\"></a>1.页面的逻辑</h3><p>首先来看一下页面的逻辑，我做了一张图，大致的逻辑就是这样，其中可以还包含着一些交互和动画方面的细节，我这里就详细阐述了。逻辑如下图：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_1.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"2-分析接口\"><a href=\"#2-分析接口\" class=\"headerlink\" title=\"2.分析接口\"></a>2.分析接口</h3><p>首先，这两个接口分别是，微信授权登录的接口和注册JSSDK的接口。</p>\n<h4 id=\"1-微信授权登录的接口\"><a href=\"#1-微信授权登录的接口\" class=\"headerlink\" title=\"1.微信授权登录的接口\"></a>1.微信授权登录的接口</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> redirect_uri = <span class=\"string\">'https://marketing.qfpay.com/v1/mkw/page_obtain?share_code='</span> + code;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> redirect_uri = <span class=\"built_in\">encodeURIComponent</span>(redirect_uri);</span><br><span class=\"line\"></span><br><span class=\"line\">location.href = <span class=\"string\">'https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxeb6e671f5571abce&amp;redirect_uri=https://o2.qfpay.com/trade/wechat/v1/get_weixin_code&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state='</span>+redirect_uri;</span><br></pre></td></tr></table></figure>\n<p>具体后台是怎么处理的我不是特别清楚，大概是这样，open.weixin这个登录接口，是会接收两个参数的<code>appid</code>应该是公众号的一个唯一标识，标识是授权给这个公众号登陆的，还有一个参数是<code>redirect_url</code>这个是经过微信授权后你要跳转回的链接，这个链接是跳回到后台，后台要对url进行处理后再返回给前端的页面。</p>\n<p><strong>这里要注意一个问题就是本来我们要对<code>redirect_url</code>这个参数进行URI编码处理，原因是因为如果不进行编码处理，url传到后台的时候可能会出现问题。</strong></p>\n<hr>\n<h4 id=\"2-JSSDK\"><a href=\"#2-JSSDK\" class=\"headerlink\" title=\"2.JSSDK\"></a>2.JSSDK</h4><p>这个简单来其实就是用微信给的一些方法，来调出微信一些功能，比如分享朋友圈，发送给朋友等等。也可以根据微信给出的一些方法，来禁用掉微信的一些按钮。</p>\n<p>这也是我遇到困难最多的地方，可能是第一次接触吧，所以对其中的一些原理不是太了解，所以做了很多蠢事，再次对后台配合的同学感到抱歉啊，现在就来分析分析这个JSSDK吧。</p>\n<p>首先我们可以看一下微信的官方文档，点击<a href=\"http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<p>第一步我们暂时忽略，引入JS文件，这里要注意<code>http</code>和<code>https</code>协议要引入的JS是不一样的这里大家要注意一下。</p>\n<p>第三步，<code>wx.config</code>这个接口，我们需要先注入一些配置信息，我在这里也遇到问题，这个是我粗心没有仔细阅读文档，在<code>jsApiList</code>这个配置项当中，之后所有要调用的方法都要先通过这里注册，如果没有的话，下面的调用都是无效的。</p>\n<p>第四步，<code>ready</code>接口中可以监听各个接口的事件，比如点击哪个按钮后出发什么事件等等。（可能我说的不够准确，按我自己的理解来说）。</p>\n<p>下面来读一下代码，来总结和再次理解一下，代码是原来同事已经写好的一个一些代码，就是做JSSDK注册的。我们只要读懂，并能按实际应用来修改就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里是来发一个ajax来获取一些，这里是用了一个原生的ajax请求</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> configWx = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//新new了一个xhr对象</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> xhrHttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        <span class=\"comment\">//取用get请求去访问这个接口，这个接口的作用可能是会返回一些需要wx.config的配置项</span></span><br><span class=\"line\">        xhrHttp.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">'/v1/manage/wxjs_conf?url='</span>+ <span class=\"built_in\">encodeURIComponent</span>(location.href));</span><br><span class=\"line\">        xhrHttp.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        xhrHttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果服务器返回了正确而的状态码</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((xhrHttp.readyState == <span class=\"number\">4</span>) &amp;&amp; (xhrHttp.status == <span class=\"number\">200</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//把返回的text变成一个json对象</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> data  = <span class=\"built_in\">JSON</span>.parse(xhrHttp.responseText);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> respCode = data.respcd;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (respCode === <span class=\"string\">'0000'</span>) &#123;</span><br><span class=\"line\">                    data = data.data;</span><br><span class=\"line\">                    data.debug = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//这里是要调用到的所有微信的接口 必须在这里先初始化</span></span><br><span class=\"line\">                    data.jsApiList = [</span><br><span class=\"line\">                        <span class=\"string\">'checkJsApi'</span>,</span><br><span class=\"line\">                        <span class=\"string\">'hideAllNonBaseMenuItem'</span>,</span><br><span class=\"line\">                        <span class=\"string\">'showMenuItems'</span>,</span><br><span class=\"line\">                        <span class=\"string\">'onMenuShareTimeline'</span>,</span><br><span class=\"line\">                        <span class=\"string\">'onMenuShareAppMessage'</span>,</span><br><span class=\"line\">                        <span class=\"string\">'onMenuShareQQ'</span>,</span><br><span class=\"line\">                        <span class=\"string\">'onMenuShareWeibo'</span></span><br><span class=\"line\">                    ];</span><br><span class=\"line\">                    <span class=\"comment\">//这里的shareUrl是 其他JS中</span></span><br><span class=\"line\">                    data.url = shareUrl;</span><br><span class=\"line\">                    wx.config(data);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">                        cb();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> share = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//data.appId = data.appId || 'wxeb6e671f5571abce';</span></span><br><span class=\"line\">        data.desc = util.removeHtmlTab(util.escape2Html(data.desc)).substring(<span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data.isConfiged) &#123;</span><br><span class=\"line\">            configWx();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        wx.ready(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 2. 分享接口</span></span><br><span class=\"line\">            <span class=\"comment\">// 2.1 监听“分享给朋友”，按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">            wx.onMenuShareAppMessage(data);</span><br><span class=\"line\">            <span class=\"comment\">// 2.2 监听“分享到朋友圈”按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">            wx.onMenuShareTimeline(data);</span><br><span class=\"line\">            <span class=\"comment\">// 2.3 监听“分享到QQ”按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">            wx.onMenuShareQQ(data);</span><br><span class=\"line\">            <span class=\"comment\">// 2.4 监听“分享到微博”按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">            wx.onMenuShareWeibo(data);</span><br><span class=\"line\">            wx.hideAllNonBaseMenuItem(&#123;</span><br><span class=\"line\">                success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//注意 这里因为在hideAllNonBaseMenuItem的回调里有showMenuItems接口，所以showMenuItems也必须在jsApiList中初始化。</span></span><br><span class=\"line\">                    wx.showMenuItems(&#123;</span><br><span class=\"line\">                        menuList: [<span class=\"string\">'menuItem:share:appMessage'</span>]</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//可以自己定义分享内容接口</span></span><br><span class=\"line\">    <span class=\"comment\">// title: '', // 分享标题</span></span><br><span class=\"line\">    <span class=\"comment\">//desc: '', // 分享描述</span></span><br><span class=\"line\">    <span class=\"comment\">//link: '', // 分享链接</span></span><br><span class=\"line\">    <span class=\"comment\">//imgUrl: '', // 分享图标</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    share(&#123;</span><br><span class=\"line\">        link: shareUrl,</span><br><span class=\"line\">        title: shareTitle,</span><br><span class=\"line\">        desc: shareDesc,</span><br><span class=\"line\">        imgUrl: shareIconurl</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>这个就是大概我在这个JSSDK中所用到的代码了，但是因为是第一次用，在修改代码的时候，出现了很多错误，这也导致了，分享的JSSDK注册的失败，在调用分享接口获取分享内容时，调用失败，等等的错误。下面我来举几个例子。</p>\n<p>首先，是我在调用接口之前，没有在<code>jsApiList</code>当中注册，这就导致调用的这个接口是不起作用的。还有当我们调<code>share</code>这个函数的时候，我们把所有所有要自定义的内容其实都写到了<code>data</code>这个对象的里面了。当时我一开始自己手贱删了<code>wx.onMenuShareAppMessage(data)</code>这个，导致再按了分享按钮之后，不能正常定义分享的内容了。之后把这个加上了但还是不起作用。这是因为我蠢，我的代码是这么写的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">wx.onMenuShareAppMessage(data);</span><br><span class=\"line\"><span class=\"comment\">// 2.2 监听“分享到朋友圈”按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">wx.onMenuShareTimeline(data);</span><br><span class=\"line\"><span class=\"comment\">// 2.3 监听“分享到QQ”按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">wx.onMenuShareQQ(data);</span><br><span class=\"line\"><span class=\"comment\">// 2.4 监听“分享到微博”按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">wx.onMenuShareWeibo(data);</span><br><span class=\"line\"></span><br><span class=\"line\">wx.hideAllNonBaseMenuItem(&#123;</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        wx.showMenuItems(&#123;</span><br><span class=\"line\">            menuList: [<span class=\"string\">'menuItem:share:appMessage'</span>]</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">wx.onMenuShareAppMessage(&#123;</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        $(<span class=\"string\">'#cover'</span>).css(&#123;display : <span class=\"string\">'none'</span>&#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    trigger : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        $(<span class=\"string\">'#cover'</span>).css(&#123;display : <span class=\"string\">'none'</span>&#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>不知道大家看没看出来问题。我原意是想，在定义了分享内容的同时，来监听一下这个按钮，如果确认分享以后，我执行回调函数，把引导分享的遮罩层隐藏掉。但是这里问题出现了，我很想当然的觉得这么写没有问题，但如果两次来调用这个接口，其实第一次调用时的赋值就被覆盖了。所以我不能正常的自定义分享内容了。</p>\n<p>那应该怎么写呢？应该这样，把这个也写到data对象当中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">share(&#123;</span><br><span class=\"line\">        link: shareUrl,</span><br><span class=\"line\">        title: shareTitle,</span><br><span class=\"line\">        desc: shareDesc,</span><br><span class=\"line\">        imgUrl: shareIconurl,</span><br><span class=\"line\">        success : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        \t\t<span class=\"comment\">//回调</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        trigger : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        \t\t<span class=\"comment\">//回调</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>如上代码，就可以完成这个功能了。</p>\n<p>其实我觉得呢，调用这些接口都是一个熟练功，第一次可能会出现很多问题，但是越用就会越熟悉，我觉得在我下次再调用这个接口的时候，我该不会出现这些低级的问题了。（话说我觉得我计算机基础真的很差）。</p>\n<hr>\n<h3 id=\"3-这次项目遇到的一些坑\"><a href=\"#3-这次项目遇到的一些坑\" class=\"headerlink\" title=\"3. 这次项目遇到的一些坑\"></a>3. 这次项目遇到的一些坑</h3><p>这次的坑我觉得有两个：</p>\n<h4 id=\"1-translate3d-位移后会占据空间\"><a href=\"#1-translate3d-位移后会占据空间\" class=\"headerlink\" title=\"1. translate3d 位移后会占据空间\"></a>1. translate3d 位移后会占据空间</h4><p>这个问题和需求是有关系的，红包要求上下打开，我使用的就是<code>translate3d</code>配合<code>animation</code>来实现的，一般在css中动画不要用<code>position</code>的位移，因为如果手机性能不好的话，动画会很卡。所以都会用<code>translate</code>、<code>transform</code>、<code>animation</code>配合来用。但是我发现了，<code>translate</code>之后的部分，是会占据空间的。这个导致我的红包上下打开之后，下面会把页面撑的很长，即使在我页面下面没有内容的时候，依旧会留下很大的空白。</p>\n<p>我解决的本法是，用了一种变通的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">@keyframes downward &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>% &#123;-webkit-transform:translate3d(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>); transform:translate3d(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>); display: none; opacity: <span class=\"number\">1</span>;&#125;</span><br><span class=\"line\">  <span class=\"number\">99</span>% &#123;-webkit-transform:translate3d(<span class=\"number\">0</span>,<span class=\"number\">15.3333</span>rem,<span class=\"number\">0</span>); transform:translate3d(<span class=\"number\">0</span>,<span class=\"number\">15.3333</span>rem,<span class=\"number\">0</span>); display: none; opacity: <span class=\"number\">0.5</span>;&#125;</span><br><span class=\"line\">  <span class=\"number\">100</span>%&#123;-webkit-transform:translate3d(<span class=\"number\">0</span>,<span class=\"number\">-20.3333</span>rem,<span class=\"number\">0</span>); transform: translate3d(<span class=\"number\">0</span>,<span class=\"number\">-20.3333</span>rem,<span class=\"number\">0</span>); display: none; opacity: <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码所示，因为我发现，在页面的上边超出的部分是不会使页面变化的，所以我在动画结束之前，把向下移动的部分，变成透明并快速移到页面的上方。这样视觉上并不会有变化，也能解决这个问题，但是我觉得这始终是个投机取巧的办法。但是因为我上网没有搜索到答案，和问题的根源，所以最后用了这种折中的方法。</p>\n<hr>\n<h4 id=\"2-iOS微信不能识别二维码的问题\"><a href=\"#2-iOS微信不能识别二维码的问题\" class=\"headerlink\" title=\"2. iOS微信不能识别二维码的问题\"></a>2. iOS微信不能识别二维码的问题</h4><p>这个问题在安卓手机上是不存在的，之后再iOS中会存在。网上搜索了一下解决办法，但是说的那些问题可能微信官方其实已经解决了，所以我试了那些办法都没有成功。我不知道产生的原因是什么，但是加上这个meta标签确实是可以识别二维码了。<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0,user-scalable=no&quot;/&gt;</code>。</p>\n<p>还学到了一些经验吧，在不同环境测试的时候，需要配置的域名都是不一样的，所以在切换环境的时候，如果你配置的域名是写死的，那等到切换环境的时候是非常辛苦而且容易出错的。就拿昨天的上线来说，我真是对和自己配合的后台小伙伴感到抱歉，因为我经验的不足，从线上测到线下。。。。来回切环境，结果就是域名得来回改。</p>\n<p>下次我知道了，应该把需要配置的参数，写到一个对象里面，改的时候直接改这个对象就可以了，而不用在所有代码中来回改。。。。只能说我太年轻了。。。哎悲剧死了。。。。。</p>\n<p>问题差不多就这么多总结完了，回家睡觉。</p>\n","excerpt":"","more":"<p>这个星期，接到了一个红包页面的任务，逻辑方面并不是特别复杂，但是在仔细想过之后也可以实现。最让我头疼的问题是调微信的两个接口：一个是登录接口，另一个是注册JSSDK的接口，因为我从来没有接触过这个问题，所以遇到了很多的坑，这也直接导致和我配合的后台同学受到了我的拖累，调接口用了很长很长时间。</p>\n<p>首先我们先来看一下这个页面的逻辑，然后分析一下这两个接口的JS，最后说一说我碰到的一些坑和学到的东西吧。</p>\n<h3 id=\"1-页面的逻辑\"><a href=\"#1-页面的逻辑\" class=\"headerlink\" title=\"1.页面的逻辑\"></a>1.页面的逻辑</h3><p>首先来看一下页面的逻辑，我做了一张图，大致的逻辑就是这样，其中可以还包含着一些交互和动画方面的细节，我这里就详细阐述了。逻辑如下图：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_1.png\" alt=\"\"></p>\n<hr>\n<h3 id=\"2-分析接口\"><a href=\"#2-分析接口\" class=\"headerlink\" title=\"2.分析接口\"></a>2.分析接口</h3><p>首先，这两个接口分别是，微信授权登录的接口和注册JSSDK的接口。</p>\n<h4 id=\"1-微信授权登录的接口\"><a href=\"#1-微信授权登录的接口\" class=\"headerlink\" title=\"1.微信授权登录的接口\"></a>1.微信授权登录的接口</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> redirect_uri = <span class=\"string\">'https://marketing.qfpay.com/v1/mkw/page_obtain?share_code='</span> + code;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> redirect_uri = <span class=\"built_in\">encodeURIComponent</span>(redirect_uri);</span><br><span class=\"line\"></span><br><span class=\"line\">location.href = <span class=\"string\">'https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxeb6e671f5571abce&amp;redirect_uri=https://o2.qfpay.com/trade/wechat/v1/get_weixin_code&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state='</span>+redirect_uri;</span><br></pre></td></tr></table></figure>\n<p>具体后台是怎么处理的我不是特别清楚，大概是这样，open.weixin这个登录接口，是会接收两个参数的<code>appid</code>应该是公众号的一个唯一标识，标识是授权给这个公众号登陆的，还有一个参数是<code>redirect_url</code>这个是经过微信授权后你要跳转回的链接，这个链接是跳回到后台，后台要对url进行处理后再返回给前端的页面。</p>\n<p><strong>这里要注意一个问题就是本来我们要对<code>redirect_url</code>这个参数进行URI编码处理，原因是因为如果不进行编码处理，url传到后台的时候可能会出现问题。</strong></p>\n<hr>\n<h4 id=\"2-JSSDK\"><a href=\"#2-JSSDK\" class=\"headerlink\" title=\"2.JSSDK\"></a>2.JSSDK</h4><p>这个简单来其实就是用微信给的一些方法，来调出微信一些功能，比如分享朋友圈，发送给朋友等等。也可以根据微信给出的一些方法，来禁用掉微信的一些按钮。</p>\n<p>这也是我遇到困难最多的地方，可能是第一次接触吧，所以对其中的一些原理不是太了解，所以做了很多蠢事，再次对后台配合的同学感到抱歉啊，现在就来分析分析这个JSSDK吧。</p>\n<p>首先我们可以看一下微信的官方文档，点击<a href=\"http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html\">这里</a>。</p>\n<p>第一步我们暂时忽略，引入JS文件，这里要注意<code>http</code>和<code>https</code>协议要引入的JS是不一样的这里大家要注意一下。</p>\n<p>第三步，<code>wx.config</code>这个接口，我们需要先注入一些配置信息，我在这里也遇到问题，这个是我粗心没有仔细阅读文档，在<code>jsApiList</code>这个配置项当中，之后所有要调用的方法都要先通过这里注册，如果没有的话，下面的调用都是无效的。</p>\n<p>第四步，<code>ready</code>接口中可以监听各个接口的事件，比如点击哪个按钮后出发什么事件等等。（可能我说的不够准确，按我自己的理解来说）。</p>\n<p>下面来读一下代码，来总结和再次理解一下，代码是原来同事已经写好的一个一些代码，就是做JSSDK注册的。我们只要读懂，并能按实际应用来修改就好了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里是来发一个ajax来获取一些，这里是用了一个原生的ajax请求</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> configWx = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//新new了一个xhr对象</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> xhrHttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        <span class=\"comment\">//取用get请求去访问这个接口，这个接口的作用可能是会返回一些需要wx.config的配置项</span></span><br><span class=\"line\">        xhrHttp.open(<span class=\"string\">\"GET\"</span>,<span class=\"string\">'/v1/manage/wxjs_conf?url='</span>+ <span class=\"built_in\">encodeURIComponent</span>(location.href));</span><br><span class=\"line\">        xhrHttp.send(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        xhrHttp.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果服务器返回了正确而的状态码</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((xhrHttp.readyState == <span class=\"number\">4</span>) &amp;&amp; (xhrHttp.status == <span class=\"number\">200</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//把返回的text变成一个json对象</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> data  = <span class=\"built_in\">JSON</span>.parse(xhrHttp.responseText);</span><br><span class=\"line\">                <span class=\"keyword\">var</span> respCode = data.respcd;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (respCode === <span class=\"string\">'0000'</span>) &#123;</span><br><span class=\"line\">                    data = data.data;</span><br><span class=\"line\">                    data.debug = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//这里是要调用到的所有微信的接口 必须在这里先初始化</span></span><br><span class=\"line\">                    data.jsApiList = [</span><br><span class=\"line\">                        <span class=\"string\">'checkJsApi'</span>,</span><br><span class=\"line\">                        <span class=\"string\">'hideAllNonBaseMenuItem'</span>,</span><br><span class=\"line\">                        <span class=\"string\">'showMenuItems'</span>,</span><br><span class=\"line\">                        <span class=\"string\">'onMenuShareTimeline'</span>,</span><br><span class=\"line\">                        <span class=\"string\">'onMenuShareAppMessage'</span>,</span><br><span class=\"line\">                        <span class=\"string\">'onMenuShareQQ'</span>,</span><br><span class=\"line\">                        <span class=\"string\">'onMenuShareWeibo'</span></span><br><span class=\"line\">                    ];</span><br><span class=\"line\">                    <span class=\"comment\">//这里的shareUrl是 其他JS中</span></span><br><span class=\"line\">                    data.url = shareUrl;</span><br><span class=\"line\">                    wx.config(data);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cb) &#123;</span><br><span class=\"line\">                        cb();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> share = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//data.appId = data.appId || 'wxeb6e671f5571abce';</span></span><br><span class=\"line\">        data.desc = util.removeHtmlTab(util.escape2Html(data.desc)).substring(<span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data.isConfiged) &#123;</span><br><span class=\"line\">            configWx();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        wx.ready(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 2. 分享接口</span></span><br><span class=\"line\">            <span class=\"comment\">// 2.1 监听“分享给朋友”，按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">            wx.onMenuShareAppMessage(data);</span><br><span class=\"line\">            <span class=\"comment\">// 2.2 监听“分享到朋友圈”按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">            wx.onMenuShareTimeline(data);</span><br><span class=\"line\">            <span class=\"comment\">// 2.3 监听“分享到QQ”按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">            wx.onMenuShareQQ(data);</span><br><span class=\"line\">            <span class=\"comment\">// 2.4 监听“分享到微博”按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">            wx.onMenuShareWeibo(data);</span><br><span class=\"line\">            wx.hideAllNonBaseMenuItem(&#123;</span><br><span class=\"line\">                success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//注意 这里因为在hideAllNonBaseMenuItem的回调里有showMenuItems接口，所以showMenuItems也必须在jsApiList中初始化。</span></span><br><span class=\"line\">                    wx.showMenuItems(&#123;</span><br><span class=\"line\">                        menuList: [<span class=\"string\">'menuItem:share:appMessage'</span>]</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">//可以自己定义分享内容接口</span></span><br><span class=\"line\">    <span class=\"comment\">// title: '', // 分享标题</span></span><br><span class=\"line\">    <span class=\"comment\">//desc: '', // 分享描述</span></span><br><span class=\"line\">    <span class=\"comment\">//link: '', // 分享链接</span></span><br><span class=\"line\">    <span class=\"comment\">//imgUrl: '', // 分享图标</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    share(&#123;</span><br><span class=\"line\">        link: shareUrl,</span><br><span class=\"line\">        title: shareTitle,</span><br><span class=\"line\">        desc: shareDesc,</span><br><span class=\"line\">        imgUrl: shareIconurl</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>这个就是大概我在这个JSSDK中所用到的代码了，但是因为是第一次用，在修改代码的时候，出现了很多错误，这也导致了，分享的JSSDK注册的失败，在调用分享接口获取分享内容时，调用失败，等等的错误。下面我来举几个例子。</p>\n<p>首先，是我在调用接口之前，没有在<code>jsApiList</code>当中注册，这就导致调用的这个接口是不起作用的。还有当我们调<code>share</code>这个函数的时候，我们把所有所有要自定义的内容其实都写到了<code>data</code>这个对象的里面了。当时我一开始自己手贱删了<code>wx.onMenuShareAppMessage(data)</code>这个，导致再按了分享按钮之后，不能正常定义分享的内容了。之后把这个加上了但还是不起作用。这是因为我蠢，我的代码是这么写的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">wx.onMenuShareAppMessage(data);</span><br><span class=\"line\"><span class=\"comment\">// 2.2 监听“分享到朋友圈”按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">wx.onMenuShareTimeline(data);</span><br><span class=\"line\"><span class=\"comment\">// 2.3 监听“分享到QQ”按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">wx.onMenuShareQQ(data);</span><br><span class=\"line\"><span class=\"comment\">// 2.4 监听“分享到微博”按钮点击、自定义分享内容及分享结果接口</span></span><br><span class=\"line\">wx.onMenuShareWeibo(data);</span><br><span class=\"line\"></span><br><span class=\"line\">wx.hideAllNonBaseMenuItem(&#123;</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        wx.showMenuItems(&#123;</span><br><span class=\"line\">            menuList: [<span class=\"string\">'menuItem:share:appMessage'</span>]</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">wx.onMenuShareAppMessage(&#123;</span><br><span class=\"line\">    success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        $(<span class=\"string\">'#cover'</span>).css(&#123;display : <span class=\"string\">'none'</span>&#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    trigger : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        $(<span class=\"string\">'#cover'</span>).css(&#123;display : <span class=\"string\">'none'</span>&#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>不知道大家看没看出来问题。我原意是想，在定义了分享内容的同时，来监听一下这个按钮，如果确认分享以后，我执行回调函数，把引导分享的遮罩层隐藏掉。但是这里问题出现了，我很想当然的觉得这么写没有问题，但如果两次来调用这个接口，其实第一次调用时的赋值就被覆盖了。所以我不能正常的自定义分享内容了。</p>\n<p>那应该怎么写呢？应该这样，把这个也写到data对象当中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">share(&#123;</span><br><span class=\"line\">        link: shareUrl,</span><br><span class=\"line\">        title: shareTitle,</span><br><span class=\"line\">        desc: shareDesc,</span><br><span class=\"line\">        imgUrl: shareIconurl,</span><br><span class=\"line\">        success : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        \t\t<span class=\"comment\">//回调</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        trigger : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        \t\t<span class=\"comment\">//回调</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>如上代码，就可以完成这个功能了。</p>\n<p>其实我觉得呢，调用这些接口都是一个熟练功，第一次可能会出现很多问题，但是越用就会越熟悉，我觉得在我下次再调用这个接口的时候，我该不会出现这些低级的问题了。（话说我觉得我计算机基础真的很差）。</p>\n<hr>\n<h3 id=\"3-这次项目遇到的一些坑\"><a href=\"#3-这次项目遇到的一些坑\" class=\"headerlink\" title=\"3. 这次项目遇到的一些坑\"></a>3. 这次项目遇到的一些坑</h3><p>这次的坑我觉得有两个：</p>\n<h4 id=\"1-translate3d-位移后会占据空间\"><a href=\"#1-translate3d-位移后会占据空间\" class=\"headerlink\" title=\"1. translate3d 位移后会占据空间\"></a>1. translate3d 位移后会占据空间</h4><p>这个问题和需求是有关系的，红包要求上下打开，我使用的就是<code>translate3d</code>配合<code>animation</code>来实现的，一般在css中动画不要用<code>position</code>的位移，因为如果手机性能不好的话，动画会很卡。所以都会用<code>translate</code>、<code>transform</code>、<code>animation</code>配合来用。但是我发现了，<code>translate</code>之后的部分，是会占据空间的。这个导致我的红包上下打开之后，下面会把页面撑的很长，即使在我页面下面没有内容的时候，依旧会留下很大的空白。</p>\n<p>我解决的本法是，用了一种变通的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">@keyframes downward &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>% &#123;-webkit-transform:translate3d(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>); transform:translate3d(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>); display: none; opacity: <span class=\"number\">1</span>;&#125;</span><br><span class=\"line\">  <span class=\"number\">99</span>% &#123;-webkit-transform:translate3d(<span class=\"number\">0</span>,<span class=\"number\">15.3333</span>rem,<span class=\"number\">0</span>); transform:translate3d(<span class=\"number\">0</span>,<span class=\"number\">15.3333</span>rem,<span class=\"number\">0</span>); display: none; opacity: <span class=\"number\">0.5</span>;&#125;</span><br><span class=\"line\">  <span class=\"number\">100</span>%&#123;-webkit-transform:translate3d(<span class=\"number\">0</span>,<span class=\"number\">-20.3333</span>rem,<span class=\"number\">0</span>); transform: translate3d(<span class=\"number\">0</span>,<span class=\"number\">-20.3333</span>rem,<span class=\"number\">0</span>); display: none; opacity: <span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<p>如上代码所示，因为我发现，在页面的上边超出的部分是不会使页面变化的，所以我在动画结束之前，把向下移动的部分，变成透明并快速移到页面的上方。这样视觉上并不会有变化，也能解决这个问题，但是我觉得这始终是个投机取巧的办法。但是因为我上网没有搜索到答案，和问题的根源，所以最后用了这种折中的方法。</p>\n<hr>\n<h4 id=\"2-iOS微信不能识别二维码的问题\"><a href=\"#2-iOS微信不能识别二维码的问题\" class=\"headerlink\" title=\"2. iOS微信不能识别二维码的问题\"></a>2. iOS微信不能识别二维码的问题</h4><p>这个问题在安卓手机上是不存在的，之后再iOS中会存在。网上搜索了一下解决办法，但是说的那些问题可能微信官方其实已经解决了，所以我试了那些办法都没有成功。我不知道产生的原因是什么，但是加上这个meta标签确实是可以识别二维码了。<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0,user-scalable=no&quot;/&gt;</code>。</p>\n<p>还学到了一些经验吧，在不同环境测试的时候，需要配置的域名都是不一样的，所以在切换环境的时候，如果你配置的域名是写死的，那等到切换环境的时候是非常辛苦而且容易出错的。就拿昨天的上线来说，我真是对和自己配合的后台小伙伴感到抱歉，因为我经验的不足，从线上测到线下。。。。来回切环境，结果就是域名得来回改。</p>\n<p>下次我知道了，应该把需要配置的参数，写到一个对象里面，改的时候直接改这个对象就可以了，而不用在所有代码中来回改。。。。只能说我太年轻了。。。哎悲剧死了。。。。。</p>\n<p>问题差不多就这么多总结完了，回家睡觉。</p>\n"},{"layout":"post","title":"未来三个月的计划","date":"2016-03-15T16:00:00.000Z","_content":"\n感觉自己的进度比工作之前要慢了很多，该计划一下未来三个月应该多学习哪方面的知识，而且也需要做出一些自己的东西来了，不能只停留在做一些小demo和理论上面。\n\n1. 学习react\n2. 学习vue (√)\n3. 美化自己的博客 （√）\n4. 用react和vue来重构自己的博客 \n5. 最好是可以用react和vue写一个自己的手机webapp来（选做）(√)\n6. 学习关于后端及node，可以搭起自己的一个后台，为了下一步可以自己建一个网站做准备。(√)\n\n未来每个月总结一下，看看完成这个计划的进度如何。\n\n### update 4.18\n\n已经一个月了吧，最近工作也比较繁琐，学习时间也不是特别充足，也有了一些惰性，一个月之内完成了博客的美化和vue的学习，vue把文档看了一遍，准备在工作的一个小项目中先试试手，我觉得我目前这个计划列的有些大，react方面和node方面的东西可能有些仓促了，没有时间来专心学习，未来一个月准备写一下vue然后把红皮书好好看一遍，巩固一下基础吧，就酱。。。。\n\n### update 6.8\n\n最近工作挺忙的，这个计划也是不能达成了，但是确实计划的太多了，但是vue方面基本可以运用在实际工作中了，node也写了一些，现在可以增删查数据了，但只是限于很简单的逻辑，毕竟后台不是那么容易入门的。react暂时先放下，等不忙了会拿起来和vue比较一下。\n\n### update 7.20\n\n今天下了好大的雨，最近学习了一段时间的vue，也做了这个webapp出来，算是完成了计划的一部分。做的是一个知乎日报的web版。\n\n[demo地址](http://zhihudaily-vue.yatessss.com/)\n\n[github地址](https://github.com/yatessss/zhihudaily-vue)\n\n看下来计划也完成了一部分但不是全部，react没来得及学习，node也只是一些皮毛，觉得自己要学习的还有很多，接下来半年，准备扎实一下基础，在平时工作的时候，多总结一些不足。加油！","source":"_posts/2016-03-16-未来三个月自己的计划.md","raw":"---\nlayout: post\ntitle: 未来三个月的计划\ndate: 2016-03-16\ncategories: 杂事二三\n---\n\n感觉自己的进度比工作之前要慢了很多，该计划一下未来三个月应该多学习哪方面的知识，而且也需要做出一些自己的东西来了，不能只停留在做一些小demo和理论上面。\n\n1. 学习react\n2. 学习vue (√)\n3. 美化自己的博客 （√）\n4. 用react和vue来重构自己的博客 \n5. 最好是可以用react和vue写一个自己的手机webapp来（选做）(√)\n6. 学习关于后端及node，可以搭起自己的一个后台，为了下一步可以自己建一个网站做准备。(√)\n\n未来每个月总结一下，看看完成这个计划的进度如何。\n\n### update 4.18\n\n已经一个月了吧，最近工作也比较繁琐，学习时间也不是特别充足，也有了一些惰性，一个月之内完成了博客的美化和vue的学习，vue把文档看了一遍，准备在工作的一个小项目中先试试手，我觉得我目前这个计划列的有些大，react方面和node方面的东西可能有些仓促了，没有时间来专心学习，未来一个月准备写一下vue然后把红皮书好好看一遍，巩固一下基础吧，就酱。。。。\n\n### update 6.8\n\n最近工作挺忙的，这个计划也是不能达成了，但是确实计划的太多了，但是vue方面基本可以运用在实际工作中了，node也写了一些，现在可以增删查数据了，但只是限于很简单的逻辑，毕竟后台不是那么容易入门的。react暂时先放下，等不忙了会拿起来和vue比较一下。\n\n### update 7.20\n\n今天下了好大的雨，最近学习了一段时间的vue，也做了这个webapp出来，算是完成了计划的一部分。做的是一个知乎日报的web版。\n\n[demo地址](http://zhihudaily-vue.yatessss.com/)\n\n[github地址](https://github.com/yatessss/zhihudaily-vue)\n\n看下来计划也完成了一部分但不是全部，react没来得及学习，node也只是一些皮毛，觉得自己要学习的还有很多，接下来半年，准备扎实一下基础，在平时工作的时候，多总结一些不足。加油！","slug":"未来三个月自己的计划","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1yt001csq5l0x4cpk5v","content":"<p>感觉自己的进度比工作之前要慢了很多，该计划一下未来三个月应该多学习哪方面的知识，而且也需要做出一些自己的东西来了，不能只停留在做一些小demo和理论上面。</p>\n<ol>\n<li>学习react</li>\n<li>学习vue (√)</li>\n<li>美化自己的博客 （√）</li>\n<li>用react和vue来重构自己的博客 </li>\n<li>最好是可以用react和vue写一个自己的手机webapp来（选做）(√)</li>\n<li>学习关于后端及node，可以搭起自己的一个后台，为了下一步可以自己建一个网站做准备。(√)</li>\n</ol>\n<p>未来每个月总结一下，看看完成这个计划的进度如何。</p>\n<h3 id=\"update-4-18\"><a href=\"#update-4-18\" class=\"headerlink\" title=\"update 4.18\"></a>update 4.18</h3><p>已经一个月了吧，最近工作也比较繁琐，学习时间也不是特别充足，也有了一些惰性，一个月之内完成了博客的美化和vue的学习，vue把文档看了一遍，准备在工作的一个小项目中先试试手，我觉得我目前这个计划列的有些大，react方面和node方面的东西可能有些仓促了，没有时间来专心学习，未来一个月准备写一下vue然后把红皮书好好看一遍，巩固一下基础吧，就酱。。。。</p>\n<h3 id=\"update-6-8\"><a href=\"#update-6-8\" class=\"headerlink\" title=\"update 6.8\"></a>update 6.8</h3><p>最近工作挺忙的，这个计划也是不能达成了，但是确实计划的太多了，但是vue方面基本可以运用在实际工作中了，node也写了一些，现在可以增删查数据了，但只是限于很简单的逻辑，毕竟后台不是那么容易入门的。react暂时先放下，等不忙了会拿起来和vue比较一下。</p>\n<h3 id=\"update-7-20\"><a href=\"#update-7-20\" class=\"headerlink\" title=\"update 7.20\"></a>update 7.20</h3><p>今天下了好大的雨，最近学习了一段时间的vue，也做了这个webapp出来，算是完成了计划的一部分。做的是一个知乎日报的web版。</p>\n<p><a href=\"http://zhihudaily-vue.yatessss.com/\" target=\"_blank\" rel=\"external\">demo地址</a></p>\n<p><a href=\"https://github.com/yatessss/zhihudaily-vue\" target=\"_blank\" rel=\"external\">github地址</a></p>\n<p>看下来计划也完成了一部分但不是全部，react没来得及学习，node也只是一些皮毛，觉得自己要学习的还有很多，接下来半年，准备扎实一下基础，在平时工作的时候，多总结一些不足。加油！</p>\n","excerpt":"","more":"<p>感觉自己的进度比工作之前要慢了很多，该计划一下未来三个月应该多学习哪方面的知识，而且也需要做出一些自己的东西来了，不能只停留在做一些小demo和理论上面。</p>\n<ol>\n<li>学习react</li>\n<li>学习vue (√)</li>\n<li>美化自己的博客 （√）</li>\n<li>用react和vue来重构自己的博客 </li>\n<li>最好是可以用react和vue写一个自己的手机webapp来（选做）(√)</li>\n<li>学习关于后端及node，可以搭起自己的一个后台，为了下一步可以自己建一个网站做准备。(√)</li>\n</ol>\n<p>未来每个月总结一下，看看完成这个计划的进度如何。</p>\n<h3 id=\"update-4-18\"><a href=\"#update-4-18\" class=\"headerlink\" title=\"update 4.18\"></a>update 4.18</h3><p>已经一个月了吧，最近工作也比较繁琐，学习时间也不是特别充足，也有了一些惰性，一个月之内完成了博客的美化和vue的学习，vue把文档看了一遍，准备在工作的一个小项目中先试试手，我觉得我目前这个计划列的有些大，react方面和node方面的东西可能有些仓促了，没有时间来专心学习，未来一个月准备写一下vue然后把红皮书好好看一遍，巩固一下基础吧，就酱。。。。</p>\n<h3 id=\"update-6-8\"><a href=\"#update-6-8\" class=\"headerlink\" title=\"update 6.8\"></a>update 6.8</h3><p>最近工作挺忙的，这个计划也是不能达成了，但是确实计划的太多了，但是vue方面基本可以运用在实际工作中了，node也写了一些，现在可以增删查数据了，但只是限于很简单的逻辑，毕竟后台不是那么容易入门的。react暂时先放下，等不忙了会拿起来和vue比较一下。</p>\n<h3 id=\"update-7-20\"><a href=\"#update-7-20\" class=\"headerlink\" title=\"update 7.20\"></a>update 7.20</h3><p>今天下了好大的雨，最近学习了一段时间的vue，也做了这个webapp出来，算是完成了计划的一部分。做的是一个知乎日报的web版。</p>\n<p><a href=\"http://zhihudaily-vue.yatessss.com/\">demo地址</a></p>\n<p><a href=\"https://github.com/yatessss/zhihudaily-vue\">github地址</a></p>\n<p>看下来计划也完成了一部分但不是全部，react没来得及学习，node也只是一些皮毛，觉得自己要学习的还有很多，接下来半年，准备扎实一下基础，在平时工作的时候，多总结一些不足。加油！</p>\n"},{"layout":"post","title":"HTML5新标签的学习","date":"2016-03-17T16:00:00.000Z","_content":"\n虽说已经知道html5很长时间了，但是我们平常写页面的时候是不是还是会这样呢？\n\n```html\n<div class=\"header\">\n  //一些内容\n</div>\n\n<div class=\"main-body\">\n  //一些内容\n</div>\n\n<div class=\"footer\">\n  //一些内容\n</div>\n```\n\n其实我们可以这么写：\n\n```html\n<header>\n  //一些内容\n</header>\n\n<main>\n  //一些内容\n</main>\n\n<footer>\n  //一些内容\n</footer>\n```\n\nhtml5给了我们很多新的标签可供使用，以前对html5有些了解，但没有仔细的学习，正好最近在看百度ife的任务题([点击这里](http://ife.baidu.com/task/all))，我们就来一起学一学我们以前知道但是没有注意的html5新标签吧~~~\n\n就像我们上面那个例子看到的那样，我觉得这是里面最常用的的标签了。`<header>`、`<footer>`、`<main>`、`<section>`、`<nav>`，以前我们都会用`id`或者`class`去表明这个`div`的意图，现在我们多了这几个标签之后，我们可以更加语义化的去编写html的结构了。\n\n******\n\n#### header和footer标签\n\n`<header>`和`<footer>`标签就是定义页眉和页脚，语义很明显。用法和`div`和没有本质的区别。\n\n*******\n\n#### main标签\n\n接下来是`<main>`标签了，这个标签貌似不是h5新出来的标签，但是之前我都没有注意过，W3School给出他的定义和用法是这样的(w3c的在这里。。。。有能力的同学可以看这个[地址](http://w3c.github.io/html/index.html#contents))。\n\n\n>`<main>` 标签规定文档的主要内容。\n>`<main>` 元素中的内容对于文档来说应当是唯一的。它不应包含在文档中重复出现的内容，比如侧栏、导航栏、版权信息、站点标志或搜索表单。\n\n>**在一个文档中，不能出现一个以上的 `<main>` 元素。`<main>` 元素不能是以下元素的后代：`<article>`、`<aside>`、`<footer>`、`<header>` 或 `<nav>`。**\n\n根据这个说明，我们可以知道`<main>`标签很适合做主要内容的标签，而不用再用`div`来定义一个`class=\"main-body\"`类似这样的结构来编写主要内容部分了。\n\n******\n\n#### nav标签\n\n以前在写头部的导航标签的时候我们一般是这样：\n\n```html\n<ul>\n\t<li><a href=\"/html/index.asp\">Home</a></li>\n\t<li><a href=\"/html/index.asp\">Home</a></li>\n\t<li><a href=\"/html/index.asp\">Home</a></li>\n</ul>\n```\n\n但是html5新加了一个专门用于导航的标签`<nav>`，他主要是应用在需要导航链接的地方和页脚需要加很多链接列表的地方，所以以后我们在写导航栏的时候就可以这样：\n\n```html\n<nav>\n    <ul>\n      <li><a href=\"/\">Home</a></li>\n      <li><a href=\"/events\">Current Events</a></li>\n      ...more...\n    </ul>\n  </nav>\n```\n\n******\n\n#### section和article标签\n\n我在review别的同学的代码的时候看到了有些同学用`section`标签来代替`div`标签来做容器标签，其实这样是不对的。\n\n官方的文档里是这么说的[这里](http://w3c.github.io/html/sections.html#the-section-element)：\n>The section element is not a generic container element. When an element is needed only for styling purposes or as a convenience for scripting, authors are encouraged to use the div element instead. A general rule is that the section element is appropriate only if the element’s contents would be listed explicitly in the document’s outline.\n\n我英语不好。。。用百度翻译了一下。。。。大概的意思就是这个`<section>`标签并不是一个通用的容器标签，如果只是为了布局需要用到容器元素的话还是推荐`div`，`section`标签是在文章中单独内容区块所用的(就好像我们小学时候的内容段，额。。。就是整篇文章分为几个大段。。。)。\n\n而且`section`标签内应该包含`<h>`和`<p>`标签，他应该和`<article>`标签一起用，`<article>`表示一整篇文章，而`<section>`来区分里面的内容段。\n\n****\n\n#### figure和figcaption标签\n\n用途：`<figure>` 标签规定独立的流内容（图像、图表、照片、代码等等）。以前我们在写一个`<img>`标签的时候如果需要给这个img标签定位的话我们会在外面包裹一个`<div>`或者是设置`<img>`标签的display，现在就有一个专门的标签来包裹他了。\n\n`<figcaption>`的用法如下：\n><figcaption> 标签定义 figure 元素的标题（caption）。\n\"figcaption\" 元素应该被置于 \"figure\" 元素的第一个或最后一个子元素的位置。\n\n*****\n\n\n剩下的还有很多新标签，我就不在这里叙述了，有兴趣的可以到相关网站上看一下，我觉得以后在相关可以语义化的时候，我们可以尝试用一下新的标签~ \n\n以上。\n\n\n\n\n\n","source":"_posts/2016-03-18-HTML5的学习.md","raw":"---\nlayout: post\ntitle: HTML5新标签的学习\ndate: 2016-03-18\ncategories: HTML\t\n---\n\n虽说已经知道html5很长时间了，但是我们平常写页面的时候是不是还是会这样呢？\n\n```html\n<div class=\"header\">\n  //一些内容\n</div>\n\n<div class=\"main-body\">\n  //一些内容\n</div>\n\n<div class=\"footer\">\n  //一些内容\n</div>\n```\n\n其实我们可以这么写：\n\n```html\n<header>\n  //一些内容\n</header>\n\n<main>\n  //一些内容\n</main>\n\n<footer>\n  //一些内容\n</footer>\n```\n\nhtml5给了我们很多新的标签可供使用，以前对html5有些了解，但没有仔细的学习，正好最近在看百度ife的任务题([点击这里](http://ife.baidu.com/task/all))，我们就来一起学一学我们以前知道但是没有注意的html5新标签吧~~~\n\n就像我们上面那个例子看到的那样，我觉得这是里面最常用的的标签了。`<header>`、`<footer>`、`<main>`、`<section>`、`<nav>`，以前我们都会用`id`或者`class`去表明这个`div`的意图，现在我们多了这几个标签之后，我们可以更加语义化的去编写html的结构了。\n\n******\n\n#### header和footer标签\n\n`<header>`和`<footer>`标签就是定义页眉和页脚，语义很明显。用法和`div`和没有本质的区别。\n\n*******\n\n#### main标签\n\n接下来是`<main>`标签了，这个标签貌似不是h5新出来的标签，但是之前我都没有注意过，W3School给出他的定义和用法是这样的(w3c的在这里。。。。有能力的同学可以看这个[地址](http://w3c.github.io/html/index.html#contents))。\n\n\n>`<main>` 标签规定文档的主要内容。\n>`<main>` 元素中的内容对于文档来说应当是唯一的。它不应包含在文档中重复出现的内容，比如侧栏、导航栏、版权信息、站点标志或搜索表单。\n\n>**在一个文档中，不能出现一个以上的 `<main>` 元素。`<main>` 元素不能是以下元素的后代：`<article>`、`<aside>`、`<footer>`、`<header>` 或 `<nav>`。**\n\n根据这个说明，我们可以知道`<main>`标签很适合做主要内容的标签，而不用再用`div`来定义一个`class=\"main-body\"`类似这样的结构来编写主要内容部分了。\n\n******\n\n#### nav标签\n\n以前在写头部的导航标签的时候我们一般是这样：\n\n```html\n<ul>\n\t<li><a href=\"/html/index.asp\">Home</a></li>\n\t<li><a href=\"/html/index.asp\">Home</a></li>\n\t<li><a href=\"/html/index.asp\">Home</a></li>\n</ul>\n```\n\n但是html5新加了一个专门用于导航的标签`<nav>`，他主要是应用在需要导航链接的地方和页脚需要加很多链接列表的地方，所以以后我们在写导航栏的时候就可以这样：\n\n```html\n<nav>\n    <ul>\n      <li><a href=\"/\">Home</a></li>\n      <li><a href=\"/events\">Current Events</a></li>\n      ...more...\n    </ul>\n  </nav>\n```\n\n******\n\n#### section和article标签\n\n我在review别的同学的代码的时候看到了有些同学用`section`标签来代替`div`标签来做容器标签，其实这样是不对的。\n\n官方的文档里是这么说的[这里](http://w3c.github.io/html/sections.html#the-section-element)：\n>The section element is not a generic container element. When an element is needed only for styling purposes or as a convenience for scripting, authors are encouraged to use the div element instead. A general rule is that the section element is appropriate only if the element’s contents would be listed explicitly in the document’s outline.\n\n我英语不好。。。用百度翻译了一下。。。。大概的意思就是这个`<section>`标签并不是一个通用的容器标签，如果只是为了布局需要用到容器元素的话还是推荐`div`，`section`标签是在文章中单独内容区块所用的(就好像我们小学时候的内容段，额。。。就是整篇文章分为几个大段。。。)。\n\n而且`section`标签内应该包含`<h>`和`<p>`标签，他应该和`<article>`标签一起用，`<article>`表示一整篇文章，而`<section>`来区分里面的内容段。\n\n****\n\n#### figure和figcaption标签\n\n用途：`<figure>` 标签规定独立的流内容（图像、图表、照片、代码等等）。以前我们在写一个`<img>`标签的时候如果需要给这个img标签定位的话我们会在外面包裹一个`<div>`或者是设置`<img>`标签的display，现在就有一个专门的标签来包裹他了。\n\n`<figcaption>`的用法如下：\n><figcaption> 标签定义 figure 元素的标题（caption）。\n\"figcaption\" 元素应该被置于 \"figure\" 元素的第一个或最后一个子元素的位置。\n\n*****\n\n\n剩下的还有很多新标签，我就不在这里叙述了，有兴趣的可以到相关网站上看一下，我觉得以后在相关可以语义化的时候，我们可以尝试用一下新的标签~ \n\n以上。\n\n\n\n\n\n","slug":"HTML5的学习","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1yv001fsq5l5yfru4xr","content":"<p>虽说已经知道html5很长时间了，但是我们平常写页面的时候是不是还是会这样呢？</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"header\"</span>&gt;</span></span><br><span class=\"line\">  //一些内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"main-body\"</span>&gt;</span></span><br><span class=\"line\">  //一些内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"footer\"</span>&gt;</span></span><br><span class=\"line\">  //一些内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>其实我们可以这么写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\">  //一些内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\">  //一些内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">  //一些内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>html5给了我们很多新的标签可供使用，以前对html5有些了解，但没有仔细的学习，正好最近在看百度ife的任务题(<a href=\"http://ife.baidu.com/task/all\" target=\"_blank\" rel=\"external\">点击这里</a>)，我们就来一起学一学我们以前知道但是没有注意的html5新标签吧~~~</p>\n<p>就像我们上面那个例子看到的那样，我觉得这是里面最常用的的标签了。<code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;main&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;nav&gt;</code>，以前我们都会用<code>id</code>或者<code>class</code>去表明这个<code>div</code>的意图，现在我们多了这几个标签之后，我们可以更加语义化的去编写html的结构了。</p>\n<hr>\n<h4 id=\"header和footer标签\"><a href=\"#header和footer标签\" class=\"headerlink\" title=\"header和footer标签\"></a>header和footer标签</h4><p><code>&lt;header&gt;</code>和<code>&lt;footer&gt;</code>标签就是定义页眉和页脚，语义很明显。用法和<code>div</code>和没有本质的区别。</p>\n<hr>\n<h4 id=\"main标签\"><a href=\"#main标签\" class=\"headerlink\" title=\"main标签\"></a>main标签</h4><p>接下来是<code>&lt;main&gt;</code>标签了，这个标签貌似不是h5新出来的标签，但是之前我都没有注意过，W3School给出他的定义和用法是这样的(w3c的在这里。。。。有能力的同学可以看这个<a href=\"http://w3c.github.io/html/index.html#contents\" target=\"_blank\" rel=\"external\">地址</a>)。</p>\n<blockquote>\n<p><code>&lt;main&gt;</code> 标签规定文档的主要内容。<br><code>&lt;main&gt;</code> 元素中的内容对于文档来说应当是唯一的。它不应包含在文档中重复出现的内容，比如侧栏、导航栏、版权信息、站点标志或搜索表单。</p>\n<p><strong>在一个文档中，不能出现一个以上的 <code>&lt;main&gt;</code> 元素。<code>&lt;main&gt;</code> 元素不能是以下元素的后代：<code>&lt;article&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;header&gt;</code> 或 <code>&lt;nav&gt;</code>。</strong></p>\n</blockquote>\n<p>根据这个说明，我们可以知道<code>&lt;main&gt;</code>标签很适合做主要内容的标签，而不用再用<code>div</code>来定义一个<code>class=&quot;main-body&quot;</code>类似这样的结构来编写主要内容部分了。</p>\n<hr>\n<h4 id=\"nav标签\"><a href=\"#nav标签\" class=\"headerlink\" title=\"nav标签\"></a>nav标签</h4><p>以前在写头部的导航标签的时候我们一般是这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/html/index.asp\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/html/index.asp\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/html/index.asp\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但是html5新加了一个专门用于导航的标签<code>&lt;nav&gt;</code>，他主要是应用在需要导航链接的地方和页脚需要加很多链接列表的地方，所以以后我们在写导航栏的时候就可以这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">nav</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/events\"</span>&gt;</span>Current Events<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">      ...more...</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"section和article标签\"><a href=\"#section和article标签\" class=\"headerlink\" title=\"section和article标签\"></a>section和article标签</h4><p>我在review别的同学的代码的时候看到了有些同学用<code>section</code>标签来代替<code>div</code>标签来做容器标签，其实这样是不对的。</p>\n<p>官方的文档里是这么说的<a href=\"http://w3c.github.io/html/sections.html#the-section-element\" target=\"_blank\" rel=\"external\">这里</a>：</p>\n<blockquote>\n<p>The section element is not a generic container element. When an element is needed only for styling purposes or as a convenience for scripting, authors are encouraged to use the div element instead. A general rule is that the section element is appropriate only if the element’s contents would be listed explicitly in the document’s outline.</p>\n</blockquote>\n<p>我英语不好。。。用百度翻译了一下。。。。大概的意思就是这个<code>&lt;section&gt;</code>标签并不是一个通用的容器标签，如果只是为了布局需要用到容器元素的话还是推荐<code>div</code>，<code>section</code>标签是在文章中单独内容区块所用的(就好像我们小学时候的内容段，额。。。就是整篇文章分为几个大段。。。)。</p>\n<p>而且<code>section</code>标签内应该包含<code>&lt;h&gt;</code>和<code>&lt;p&gt;</code>标签，他应该和<code>&lt;article&gt;</code>标签一起用，<code>&lt;article&gt;</code>表示一整篇文章，而<code>&lt;section&gt;</code>来区分里面的内容段。</p>\n<hr>\n<h4 id=\"figure和figcaption标签\"><a href=\"#figure和figcaption标签\" class=\"headerlink\" title=\"figure和figcaption标签\"></a>figure和figcaption标签</h4><p>用途：<code>&lt;figure&gt;</code> 标签规定独立的流内容（图像、图表、照片、代码等等）。以前我们在写一个<code>&lt;img&gt;</code>标签的时候如果需要给这个img标签定位的话我们会在外面包裹一个<code>&lt;div&gt;</code>或者是设置<code>&lt;img&gt;</code>标签的display，现在就有一个专门的标签来包裹他了。</p>\n<p><code>&lt;figcaption&gt;</code>的用法如下：</p>\n<blockquote>\n<p><figcaption> 标签定义 figure 元素的标题（caption）。<br>“figcaption” 元素应该被置于 “figure” 元素的第一个或最后一个子元素的位置。</figcaption></p>\n</blockquote>\n<hr>\n<p>剩下的还有很多新标签，我就不在这里叙述了，有兴趣的可以到相关网站上看一下，我觉得以后在相关可以语义化的时候，我们可以尝试用一下新的标签~ </p>\n<p>以上。</p>\n","excerpt":"","more":"<p>虽说已经知道html5很长时间了，但是我们平常写页面的时候是不是还是会这样呢？</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"header\"</span>&gt;</span></span><br><span class=\"line\">  //一些内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"main-body\"</span>&gt;</span></span><br><span class=\"line\">  //一些内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"footer\"</span>&gt;</span></span><br><span class=\"line\">  //一些内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>其实我们可以这么写：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\">  //一些内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\">  //一些内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">  //一些内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>html5给了我们很多新的标签可供使用，以前对html5有些了解，但没有仔细的学习，正好最近在看百度ife的任务题(<a href=\"http://ife.baidu.com/task/all\">点击这里</a>)，我们就来一起学一学我们以前知道但是没有注意的html5新标签吧~~~</p>\n<p>就像我们上面那个例子看到的那样，我觉得这是里面最常用的的标签了。<code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;main&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;nav&gt;</code>，以前我们都会用<code>id</code>或者<code>class</code>去表明这个<code>div</code>的意图，现在我们多了这几个标签之后，我们可以更加语义化的去编写html的结构了。</p>\n<hr>\n<h4 id=\"header和footer标签\"><a href=\"#header和footer标签\" class=\"headerlink\" title=\"header和footer标签\"></a>header和footer标签</h4><p><code>&lt;header&gt;</code>和<code>&lt;footer&gt;</code>标签就是定义页眉和页脚，语义很明显。用法和<code>div</code>和没有本质的区别。</p>\n<hr>\n<h4 id=\"main标签\"><a href=\"#main标签\" class=\"headerlink\" title=\"main标签\"></a>main标签</h4><p>接下来是<code>&lt;main&gt;</code>标签了，这个标签貌似不是h5新出来的标签，但是之前我都没有注意过，W3School给出他的定义和用法是这样的(w3c的在这里。。。。有能力的同学可以看这个<a href=\"http://w3c.github.io/html/index.html#contents\">地址</a>)。</p>\n<blockquote>\n<p><code>&lt;main&gt;</code> 标签规定文档的主要内容。<br><code>&lt;main&gt;</code> 元素中的内容对于文档来说应当是唯一的。它不应包含在文档中重复出现的内容，比如侧栏、导航栏、版权信息、站点标志或搜索表单。</p>\n<p><strong>在一个文档中，不能出现一个以上的 <code>&lt;main&gt;</code> 元素。<code>&lt;main&gt;</code> 元素不能是以下元素的后代：<code>&lt;article&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;header&gt;</code> 或 <code>&lt;nav&gt;</code>。</strong></p>\n</blockquote>\n<p>根据这个说明，我们可以知道<code>&lt;main&gt;</code>标签很适合做主要内容的标签，而不用再用<code>div</code>来定义一个<code>class=&quot;main-body&quot;</code>类似这样的结构来编写主要内容部分了。</p>\n<hr>\n<h4 id=\"nav标签\"><a href=\"#nav标签\" class=\"headerlink\" title=\"nav标签\"></a>nav标签</h4><p>以前在写头部的导航标签的时候我们一般是这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/html/index.asp\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/html/index.asp\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/html/index.asp\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>但是html5新加了一个专门用于导航的标签<code>&lt;nav&gt;</code>，他主要是应用在需要导航链接的地方和页脚需要加很多链接列表的地方，所以以后我们在写导航栏的时候就可以这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">nav</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/\"</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/events\"</span>&gt;</span>Current Events<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">      ...more...</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"section和article标签\"><a href=\"#section和article标签\" class=\"headerlink\" title=\"section和article标签\"></a>section和article标签</h4><p>我在review别的同学的代码的时候看到了有些同学用<code>section</code>标签来代替<code>div</code>标签来做容器标签，其实这样是不对的。</p>\n<p>官方的文档里是这么说的<a href=\"http://w3c.github.io/html/sections.html#the-section-element\">这里</a>：</p>\n<blockquote>\n<p>The section element is not a generic container element. When an element is needed only for styling purposes or as a convenience for scripting, authors are encouraged to use the div element instead. A general rule is that the section element is appropriate only if the element’s contents would be listed explicitly in the document’s outline.</p>\n</blockquote>\n<p>我英语不好。。。用百度翻译了一下。。。。大概的意思就是这个<code>&lt;section&gt;</code>标签并不是一个通用的容器标签，如果只是为了布局需要用到容器元素的话还是推荐<code>div</code>，<code>section</code>标签是在文章中单独内容区块所用的(就好像我们小学时候的内容段，额。。。就是整篇文章分为几个大段。。。)。</p>\n<p>而且<code>section</code>标签内应该包含<code>&lt;h&gt;</code>和<code>&lt;p&gt;</code>标签，他应该和<code>&lt;article&gt;</code>标签一起用，<code>&lt;article&gt;</code>表示一整篇文章，而<code>&lt;section&gt;</code>来区分里面的内容段。</p>\n<hr>\n<h4 id=\"figure和figcaption标签\"><a href=\"#figure和figcaption标签\" class=\"headerlink\" title=\"figure和figcaption标签\"></a>figure和figcaption标签</h4><p>用途：<code>&lt;figure&gt;</code> 标签规定独立的流内容（图像、图表、照片、代码等等）。以前我们在写一个<code>&lt;img&gt;</code>标签的时候如果需要给这个img标签定位的话我们会在外面包裹一个<code>&lt;div&gt;</code>或者是设置<code>&lt;img&gt;</code>标签的display，现在就有一个专门的标签来包裹他了。</p>\n<p><code>&lt;figcaption&gt;</code>的用法如下：</p>\n<blockquote>\n<p><figcaption> 标签定义 figure 元素的标题（caption）。<br>“figcaption” 元素应该被置于 “figure” 元素的第一个或最后一个子元素的位置。</p>\n</blockquote>\n<hr>\n<p>剩下的还有很多新标签，我就不在这里叙述了，有兴趣的可以到相关网站上看一下，我觉得以后在相关可以语义化的时候，我们可以尝试用一下新的标签~ </p>\n<p>以上。</p>\n"},{"layout":"post","title":"百度ife项目之html","date":"2016-03-22T16:00:00.000Z","_content":"\n历时两天半的断断续续，我做完了本次百度ife的第七个任务（[这里](http://ife.baidu.com/task/detail?taskId=7)），是一个html的布局任务，我做好的demo（[这里](http://yatessss.github.io/demo/baidu_ife/task_7/index.html)）。\n\n尽管已经有过很多html布局的经验了，但不得不说很多东西我还都不太熟悉，下面就来总结一下做完这个任务的一些收获吧。\n\n我大概总结了这些收获吧：\n\n1. html5的新标签的应用，这个我专门总结了一下（[这里](http://www.yatessss.com/html/2016/03/18/HTML5%E7%9A%84%E5%AD%A6%E4%B9%A0.html)）\n2. 等宽多栏布局的实现\n3. 父元素与子元素的`margin-top`\n4. `border-width`\n5. 超过行数限制显示……\n6. `letter-spacing`\n7. 伪类标签\n\n*****\n\n#### 等宽多栏布局\n\n其中有一个部分是这样的：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_2.png)\n\n这个是四栏布局，每个栏等宽且宽度应该随着屏幕宽度变化，要求有一个最小的宽度。\n\n我大概想到了这么几种布局的方案：使用`inline-block`布局、使用`flex`布局、使用`float`布局、使用框架的栅格布局。\n\n首先来说一下我最后选用的布局方案，我采用的是`float`布局，我给每一栏定了25%的宽，然后定了一个最小宽度`min-width`，然后让他向左浮动。\n\n```css\n\n    text-align: center;\n    float: left;\n    height: inherit;\n    width: 25%;\n    min-width: 320px;\n\n```\n\n**为什么选择这种方案？**如果使用`inline-block`布局两栏之间会有一个间隙，还得去处理这个间隙；使用`flex`布局的话移动端是很好的，但是如果是pc端的话会有兼容方面的问题；栅格布局肯定是可以的，但是在这上使用一个框架的话显得有些大材小用了。所以浮动我认为是一个比较好的方法。\n\n简单来说一下每一种布局方案：\n\n1. 使用`inline-block`布局，这种布局方案会有一个小问题，就是在每个栏之间会有间隙，这个问题的具体解决与描述我找到了一篇文章（[这里](http://www.w3cplus.com/css/fighting-the-space-between-inline-block-elements)）。这里详细的说明了这个问题的解决办法，所以如果是本来每栏之间就有间距的话，用`inline-block`布局是最好的了，他还可以配合`text-align`把多栏居中，用起来真的不错。\n2. 使用`flex`布局，使用`dispaly: flex`，`flex : 1 ` 这样就保证了每栏等宽了，不过他有浏览器的兼容问题这个必须要注意，在ie10以上的浏览器中。\n3. 栅格布局，他会把整个屏幕平均分成12列，根据自己的宽度来定义占用几列，这个大家得看具体的框架了，我就不详细描述了（因为我自己的实践也不是很多 - -）\n4. `float`布局，这个主要注意的就是如果你的父容器如果没有定高的话记得清除浮动。不然父容器会没有高。。。。\n\n*****\n\n#### 父元素与子元素的`margin-top`\n\n这个就是如果你给父容器的第一个子元素设定了`margin-top`的话，页面的效果不是子元素向下移动，而是父元素向下移动，而父元素和子元素的边距是没有变化的。这里我查找到的答案（[这里](http://blog.csdn.net/duran1986/article/details/6930967)），我简单描述一下，在盒子模型中规定：所有毗邻的两个或更多盒元素的margin将会合并为一个margin共享之。毗邻的定义为：同级或者嵌套(父子之间)的盒元素，并且它们之间没有非空内容、Padding或Border分隔。所以父元素和子元素会共享这个边距。解决办法其实理解了上述的那篇文章自然就可以解决了。解决办法如下：\n\n1. 修改父元素的高度，增加padding-top样式模拟（padding-top：1px；常用） \n2. 为父元素添加overflow：hidden；样式即可（完美） \n3. 为父元素或者子元素声明浮动（float：left；可用） \n4. 为父元素添加border（border:1px solid transparent可用） \n5. 为父元素或者子元素声明绝对定位\n\n*****\n\n#### `border-width`\n\n通常我们写`border`时就会直接写成这样：`border: 1px solid #000;`类似这样，那这个`border-width`有什么用呢？这个可以定义四条边是不同宽度的，他的顺序和`margin`之类的是一样的上右下左这个顺序。\n\n还有这个用处，而且我这次写页面的时候就用到了：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_3.png)\n\n这个向下小箭头这么实现呢？当然我们可以用图标字体也可以用图片，但是用css我们也可以实现，这可能算是一个hack的方法吧，但是我觉得挺有趣的，我也是review别人代码是学习的。具体css如下：\n\n```css\n\n    display: block;\n    width: 6px;\n    height: 6px;\n    border: solid #867e7a;\n    border-width: 0 1px 1px 0;\n    -webkit-transform: rotate(45deg);\n    transform: rotate(45deg);\n    \n```\n\n哈哈，真的很聪明，这样用`border-width`属性隐藏掉两边，再旋转一下就可以了！\n\n****\n\n#### 超过行数限制显示……\n\n这个也是学习的啦，[张鑫旭的博客](http://www.zhangxinxu.com/study/201510/webkit-line-clamp-text-overflow-ellipsis.html)，下面贴出css：\n\n```css\n\n    .box {\n    width: 400px; \n    display: -webkit-box;\n    -webkit-line-clamp: 3;\n    -webkit-box-orient: vertical;\n    overflow: hidden;\n}\n\n```\n\n*****\n\n#### `letter-spacing`\n\n遇到这样的样式不知道大家是怎么解决的？\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_4.png)\n\n大家是不是在两个字之间加很多的空格（`&nbsp;`）呢？还是怎么样？可以用一下这个css属性`letter-spacing`他可以改变字之间的间距，但是他有一个问题就是他会在`搜索`两个字的后面都加间距字不是居中的，所以配合`padding-left`加一个和间距相同的左内边距，这样就可以保证字是居中的了。\n\n******\n\n#### 伪类标签\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_5.png)\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_6.png)\n\n像图中对勾和横线这样的无意义的标签，我们最好是用before和after伪类来代替。\n","source":"_posts/2016-03-23-百度ife之html.md","raw":"---\nlayout: post\ntitle: 百度ife项目之html\ndate: 2016-03-23\ncategories: HTML\t\n---\n\n历时两天半的断断续续，我做完了本次百度ife的第七个任务（[这里](http://ife.baidu.com/task/detail?taskId=7)），是一个html的布局任务，我做好的demo（[这里](http://yatessss.github.io/demo/baidu_ife/task_7/index.html)）。\n\n尽管已经有过很多html布局的经验了，但不得不说很多东西我还都不太熟悉，下面就来总结一下做完这个任务的一些收获吧。\n\n我大概总结了这些收获吧：\n\n1. html5的新标签的应用，这个我专门总结了一下（[这里](http://www.yatessss.com/html/2016/03/18/HTML5%E7%9A%84%E5%AD%A6%E4%B9%A0.html)）\n2. 等宽多栏布局的实现\n3. 父元素与子元素的`margin-top`\n4. `border-width`\n5. 超过行数限制显示……\n6. `letter-spacing`\n7. 伪类标签\n\n*****\n\n#### 等宽多栏布局\n\n其中有一个部分是这样的：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_2.png)\n\n这个是四栏布局，每个栏等宽且宽度应该随着屏幕宽度变化，要求有一个最小的宽度。\n\n我大概想到了这么几种布局的方案：使用`inline-block`布局、使用`flex`布局、使用`float`布局、使用框架的栅格布局。\n\n首先来说一下我最后选用的布局方案，我采用的是`float`布局，我给每一栏定了25%的宽，然后定了一个最小宽度`min-width`，然后让他向左浮动。\n\n```css\n\n    text-align: center;\n    float: left;\n    height: inherit;\n    width: 25%;\n    min-width: 320px;\n\n```\n\n**为什么选择这种方案？**如果使用`inline-block`布局两栏之间会有一个间隙，还得去处理这个间隙；使用`flex`布局的话移动端是很好的，但是如果是pc端的话会有兼容方面的问题；栅格布局肯定是可以的，但是在这上使用一个框架的话显得有些大材小用了。所以浮动我认为是一个比较好的方法。\n\n简单来说一下每一种布局方案：\n\n1. 使用`inline-block`布局，这种布局方案会有一个小问题，就是在每个栏之间会有间隙，这个问题的具体解决与描述我找到了一篇文章（[这里](http://www.w3cplus.com/css/fighting-the-space-between-inline-block-elements)）。这里详细的说明了这个问题的解决办法，所以如果是本来每栏之间就有间距的话，用`inline-block`布局是最好的了，他还可以配合`text-align`把多栏居中，用起来真的不错。\n2. 使用`flex`布局，使用`dispaly: flex`，`flex : 1 ` 这样就保证了每栏等宽了，不过他有浏览器的兼容问题这个必须要注意，在ie10以上的浏览器中。\n3. 栅格布局，他会把整个屏幕平均分成12列，根据自己的宽度来定义占用几列，这个大家得看具体的框架了，我就不详细描述了（因为我自己的实践也不是很多 - -）\n4. `float`布局，这个主要注意的就是如果你的父容器如果没有定高的话记得清除浮动。不然父容器会没有高。。。。\n\n*****\n\n#### 父元素与子元素的`margin-top`\n\n这个就是如果你给父容器的第一个子元素设定了`margin-top`的话，页面的效果不是子元素向下移动，而是父元素向下移动，而父元素和子元素的边距是没有变化的。这里我查找到的答案（[这里](http://blog.csdn.net/duran1986/article/details/6930967)），我简单描述一下，在盒子模型中规定：所有毗邻的两个或更多盒元素的margin将会合并为一个margin共享之。毗邻的定义为：同级或者嵌套(父子之间)的盒元素，并且它们之间没有非空内容、Padding或Border分隔。所以父元素和子元素会共享这个边距。解决办法其实理解了上述的那篇文章自然就可以解决了。解决办法如下：\n\n1. 修改父元素的高度，增加padding-top样式模拟（padding-top：1px；常用） \n2. 为父元素添加overflow：hidden；样式即可（完美） \n3. 为父元素或者子元素声明浮动（float：left；可用） \n4. 为父元素添加border（border:1px solid transparent可用） \n5. 为父元素或者子元素声明绝对定位\n\n*****\n\n#### `border-width`\n\n通常我们写`border`时就会直接写成这样：`border: 1px solid #000;`类似这样，那这个`border-width`有什么用呢？这个可以定义四条边是不同宽度的，他的顺序和`margin`之类的是一样的上右下左这个顺序。\n\n还有这个用处，而且我这次写页面的时候就用到了：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_3.png)\n\n这个向下小箭头这么实现呢？当然我们可以用图标字体也可以用图片，但是用css我们也可以实现，这可能算是一个hack的方法吧，但是我觉得挺有趣的，我也是review别人代码是学习的。具体css如下：\n\n```css\n\n    display: block;\n    width: 6px;\n    height: 6px;\n    border: solid #867e7a;\n    border-width: 0 1px 1px 0;\n    -webkit-transform: rotate(45deg);\n    transform: rotate(45deg);\n    \n```\n\n哈哈，真的很聪明，这样用`border-width`属性隐藏掉两边，再旋转一下就可以了！\n\n****\n\n#### 超过行数限制显示……\n\n这个也是学习的啦，[张鑫旭的博客](http://www.zhangxinxu.com/study/201510/webkit-line-clamp-text-overflow-ellipsis.html)，下面贴出css：\n\n```css\n\n    .box {\n    width: 400px; \n    display: -webkit-box;\n    -webkit-line-clamp: 3;\n    -webkit-box-orient: vertical;\n    overflow: hidden;\n}\n\n```\n\n*****\n\n#### `letter-spacing`\n\n遇到这样的样式不知道大家是怎么解决的？\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_4.png)\n\n大家是不是在两个字之间加很多的空格（`&nbsp;`）呢？还是怎么样？可以用一下这个css属性`letter-spacing`他可以改变字之间的间距，但是他有一个问题就是他会在`搜索`两个字的后面都加间距字不是居中的，所以配合`padding-left`加一个和间距相同的左内边距，这样就可以保证字是居中的了。\n\n******\n\n#### 伪类标签\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_5.png)\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_6.png)\n\n像图中对勾和横线这样的无意义的标签，我们最好是用before和after伪类来代替。\n","slug":"百度ife之html","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1yy001jsq5letvmc6g4","content":"<p>历时两天半的断断续续，我做完了本次百度ife的第七个任务（<a href=\"http://ife.baidu.com/task/detail?taskId=7\" target=\"_blank\" rel=\"external\">这里</a>），是一个html的布局任务，我做好的demo（<a href=\"http://yatessss.github.io/demo/baidu_ife/task_7/index.html\" target=\"_blank\" rel=\"external\">这里</a>）。</p>\n<p>尽管已经有过很多html布局的经验了，但不得不说很多东西我还都不太熟悉，下面就来总结一下做完这个任务的一些收获吧。</p>\n<p>我大概总结了这些收获吧：</p>\n<ol>\n<li>html5的新标签的应用，这个我专门总结了一下（<a href=\"http://www.yatessss.com/html/2016/03/18/HTML5%E7%9A%84%E5%AD%A6%E4%B9%A0.html\">这里</a>）</li>\n<li>等宽多栏布局的实现</li>\n<li>父元素与子元素的<code>margin-top</code></li>\n<li><code>border-width</code></li>\n<li>超过行数限制显示……</li>\n<li><code>letter-spacing</code></li>\n<li>伪类标签</li>\n</ol>\n<hr>\n<h4 id=\"等宽多栏布局\"><a href=\"#等宽多栏布局\" class=\"headerlink\" title=\"等宽多栏布局\"></a>等宽多栏布局</h4><p>其中有一个部分是这样的：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_2.png\" alt=\"\"></p>\n<p>这个是四栏布局，每个栏等宽且宽度应该随着屏幕宽度变化，要求有一个最小的宽度。</p>\n<p>我大概想到了这么几种布局的方案：使用<code>inline-block</code>布局、使用<code>flex</code>布局、使用<code>float</code>布局、使用框架的栅格布局。</p>\n<p>首先来说一下我最后选用的布局方案，我采用的是<code>float</code>布局，我给每一栏定了25%的宽，然后定了一个最小宽度<code>min-width</code>，然后让他向左浮动。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">text-align</span>: <span class=\"selector-tag\">center</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">height</span>: <span class=\"selector-tag\">inherit</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">width</span>: 25%;</span><br><span class=\"line\"><span class=\"selector-tag\">min-width</span>: 320<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>为什么选择这种方案？</strong>如果使用<code>inline-block</code>布局两栏之间会有一个间隙，还得去处理这个间隙；使用<code>flex</code>布局的话移动端是很好的，但是如果是pc端的话会有兼容方面的问题；栅格布局肯定是可以的，但是在这上使用一个框架的话显得有些大材小用了。所以浮动我认为是一个比较好的方法。</p>\n<p>简单来说一下每一种布局方案：</p>\n<ol>\n<li>使用<code>inline-block</code>布局，这种布局方案会有一个小问题，就是在每个栏之间会有间隙，这个问题的具体解决与描述我找到了一篇文章（<a href=\"http://www.w3cplus.com/css/fighting-the-space-between-inline-block-elements\" target=\"_blank\" rel=\"external\">这里</a>）。这里详细的说明了这个问题的解决办法，所以如果是本来每栏之间就有间距的话，用<code>inline-block</code>布局是最好的了，他还可以配合<code>text-align</code>把多栏居中，用起来真的不错。</li>\n<li>使用<code>flex</code>布局，使用<code>dispaly: flex</code>，<code>flex : 1</code> 这样就保证了每栏等宽了，不过他有浏览器的兼容问题这个必须要注意，在ie10以上的浏览器中。</li>\n<li>栅格布局，他会把整个屏幕平均分成12列，根据自己的宽度来定义占用几列，这个大家得看具体的框架了，我就不详细描述了（因为我自己的实践也不是很多 - -）</li>\n<li><code>float</code>布局，这个主要注意的就是如果你的父容器如果没有定高的话记得清除浮动。不然父容器会没有高。。。。</li>\n</ol>\n<hr>\n<h4 id=\"父元素与子元素的margin-top\"><a href=\"#父元素与子元素的margin-top\" class=\"headerlink\" title=\"父元素与子元素的margin-top\"></a>父元素与子元素的<code>margin-top</code></h4><p>这个就是如果你给父容器的第一个子元素设定了<code>margin-top</code>的话，页面的效果不是子元素向下移动，而是父元素向下移动，而父元素和子元素的边距是没有变化的。这里我查找到的答案（<a href=\"http://blog.csdn.net/duran1986/article/details/6930967\" target=\"_blank\" rel=\"external\">这里</a>），我简单描述一下，在盒子模型中规定：所有毗邻的两个或更多盒元素的margin将会合并为一个margin共享之。毗邻的定义为：同级或者嵌套(父子之间)的盒元素，并且它们之间没有非空内容、Padding或Border分隔。所以父元素和子元素会共享这个边距。解决办法其实理解了上述的那篇文章自然就可以解决了。解决办法如下：</p>\n<ol>\n<li>修改父元素的高度，增加padding-top样式模拟（padding-top：1px；常用） </li>\n<li>为父元素添加overflow：hidden；样式即可（完美） </li>\n<li>为父元素或者子元素声明浮动（float：left；可用） </li>\n<li>为父元素添加border（border:1px solid transparent可用） </li>\n<li>为父元素或者子元素声明绝对定位</li>\n</ol>\n<hr>\n<h4 id=\"border-width\"><a href=\"#border-width\" class=\"headerlink\" title=\"border-width\"></a><code>border-width</code></h4><p>通常我们写<code>border</code>时就会直接写成这样：<code>border: 1px solid #000;</code>类似这样，那这个<code>border-width</code>有什么用呢？这个可以定义四条边是不同宽度的，他的顺序和<code>margin</code>之类的是一样的上右下左这个顺序。</p>\n<p>还有这个用处，而且我这次写页面的时候就用到了：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_3.png\" alt=\"\"></p>\n<p>这个向下小箭头这么实现呢？当然我们可以用图标字体也可以用图片，但是用css我们也可以实现，这可能算是一个hack的方法吧，但是我觉得挺有趣的，我也是review别人代码是学习的。具体css如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">block</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">width</span>: 6<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">height</span>: 6<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border</span>: <span class=\"selector-tag\">solid</span> <span class=\"selector-id\">#867e7a</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border-width</span>: 0 1<span class=\"selector-tag\">px</span> 1<span class=\"selector-tag\">px</span> 0;</span><br><span class=\"line\"><span class=\"selector-tag\">-webkit-transform</span>: <span class=\"selector-tag\">rotate</span>(45<span class=\"selector-tag\">deg</span>);</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span>: <span class=\"selector-tag\">rotate</span>(45<span class=\"selector-tag\">deg</span>);</span><br></pre></td></tr></table></figure>\n<p>哈哈，真的很聪明，这样用<code>border-width</code>属性隐藏掉两边，再旋转一下就可以了！</p>\n<hr>\n<h4 id=\"超过行数限制显示……\"><a href=\"#超过行数限制显示……\" class=\"headerlink\" title=\"超过行数限制显示……\"></a>超过行数限制显示……</h4><p>这个也是学习的啦，<a href=\"http://www.zhangxinxu.com/study/201510/webkit-line-clamp-text-overflow-ellipsis.html\" target=\"_blank\" rel=\"external\">张鑫旭的博客</a>，下面贴出css：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    <span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">400px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -webkit-box;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-line-clamp</span>: <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-box-orient</span>: vertical;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"letter-spacing\"><a href=\"#letter-spacing\" class=\"headerlink\" title=\"letter-spacing\"></a><code>letter-spacing</code></h4><p>遇到这样的样式不知道大家是怎么解决的？</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_4.png\" alt=\"\"></p>\n<p>大家是不是在两个字之间加很多的空格（<code>&amp;nbsp;</code>）呢？还是怎么样？可以用一下这个css属性<code>letter-spacing</code>他可以改变字之间的间距，但是他有一个问题就是他会在<code>搜索</code>两个字的后面都加间距字不是居中的，所以配合<code>padding-left</code>加一个和间距相同的左内边距，这样就可以保证字是居中的了。</p>\n<hr>\n<h4 id=\"伪类标签\"><a href=\"#伪类标签\" class=\"headerlink\" title=\"伪类标签\"></a>伪类标签</h4><p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_5.png\" alt=\"\"></p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_6.png\" alt=\"\"></p>\n<p>像图中对勾和横线这样的无意义的标签，我们最好是用before和after伪类来代替。</p>\n","excerpt":"","more":"<p>历时两天半的断断续续，我做完了本次百度ife的第七个任务（<a href=\"http://ife.baidu.com/task/detail?taskId=7\">这里</a>），是一个html的布局任务，我做好的demo（<a href=\"http://yatessss.github.io/demo/baidu_ife/task_7/index.html\">这里</a>）。</p>\n<p>尽管已经有过很多html布局的经验了，但不得不说很多东西我还都不太熟悉，下面就来总结一下做完这个任务的一些收获吧。</p>\n<p>我大概总结了这些收获吧：</p>\n<ol>\n<li>html5的新标签的应用，这个我专门总结了一下（<a href=\"http://www.yatessss.com/html/2016/03/18/HTML5%E7%9A%84%E5%AD%A6%E4%B9%A0.html\">这里</a>）</li>\n<li>等宽多栏布局的实现</li>\n<li>父元素与子元素的<code>margin-top</code></li>\n<li><code>border-width</code></li>\n<li>超过行数限制显示……</li>\n<li><code>letter-spacing</code></li>\n<li>伪类标签</li>\n</ol>\n<hr>\n<h4 id=\"等宽多栏布局\"><a href=\"#等宽多栏布局\" class=\"headerlink\" title=\"等宽多栏布局\"></a>等宽多栏布局</h4><p>其中有一个部分是这样的：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_2.png\" alt=\"\"></p>\n<p>这个是四栏布局，每个栏等宽且宽度应该随着屏幕宽度变化，要求有一个最小的宽度。</p>\n<p>我大概想到了这么几种布局的方案：使用<code>inline-block</code>布局、使用<code>flex</code>布局、使用<code>float</code>布局、使用框架的栅格布局。</p>\n<p>首先来说一下我最后选用的布局方案，我采用的是<code>float</code>布局，我给每一栏定了25%的宽，然后定了一个最小宽度<code>min-width</code>，然后让他向左浮动。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">text-align</span>: <span class=\"selector-tag\">center</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">left</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">height</span>: <span class=\"selector-tag\">inherit</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">width</span>: 25%;</span><br><span class=\"line\"><span class=\"selector-tag\">min-width</span>: 320<span class=\"selector-tag\">px</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>为什么选择这种方案？</strong>如果使用<code>inline-block</code>布局两栏之间会有一个间隙，还得去处理这个间隙；使用<code>flex</code>布局的话移动端是很好的，但是如果是pc端的话会有兼容方面的问题；栅格布局肯定是可以的，但是在这上使用一个框架的话显得有些大材小用了。所以浮动我认为是一个比较好的方法。</p>\n<p>简单来说一下每一种布局方案：</p>\n<ol>\n<li>使用<code>inline-block</code>布局，这种布局方案会有一个小问题，就是在每个栏之间会有间隙，这个问题的具体解决与描述我找到了一篇文章（<a href=\"http://www.w3cplus.com/css/fighting-the-space-between-inline-block-elements\">这里</a>）。这里详细的说明了这个问题的解决办法，所以如果是本来每栏之间就有间距的话，用<code>inline-block</code>布局是最好的了，他还可以配合<code>text-align</code>把多栏居中，用起来真的不错。</li>\n<li>使用<code>flex</code>布局，使用<code>dispaly: flex</code>，<code>flex : 1</code> 这样就保证了每栏等宽了，不过他有浏览器的兼容问题这个必须要注意，在ie10以上的浏览器中。</li>\n<li>栅格布局，他会把整个屏幕平均分成12列，根据自己的宽度来定义占用几列，这个大家得看具体的框架了，我就不详细描述了（因为我自己的实践也不是很多 - -）</li>\n<li><code>float</code>布局，这个主要注意的就是如果你的父容器如果没有定高的话记得清除浮动。不然父容器会没有高。。。。</li>\n</ol>\n<hr>\n<h4 id=\"父元素与子元素的margin-top\"><a href=\"#父元素与子元素的margin-top\" class=\"headerlink\" title=\"父元素与子元素的margin-top\"></a>父元素与子元素的<code>margin-top</code></h4><p>这个就是如果你给父容器的第一个子元素设定了<code>margin-top</code>的话，页面的效果不是子元素向下移动，而是父元素向下移动，而父元素和子元素的边距是没有变化的。这里我查找到的答案（<a href=\"http://blog.csdn.net/duran1986/article/details/6930967\">这里</a>），我简单描述一下，在盒子模型中规定：所有毗邻的两个或更多盒元素的margin将会合并为一个margin共享之。毗邻的定义为：同级或者嵌套(父子之间)的盒元素，并且它们之间没有非空内容、Padding或Border分隔。所以父元素和子元素会共享这个边距。解决办法其实理解了上述的那篇文章自然就可以解决了。解决办法如下：</p>\n<ol>\n<li>修改父元素的高度，增加padding-top样式模拟（padding-top：1px；常用） </li>\n<li>为父元素添加overflow：hidden；样式即可（完美） </li>\n<li>为父元素或者子元素声明浮动（float：left；可用） </li>\n<li>为父元素添加border（border:1px solid transparent可用） </li>\n<li>为父元素或者子元素声明绝对定位</li>\n</ol>\n<hr>\n<h4 id=\"border-width\"><a href=\"#border-width\" class=\"headerlink\" title=\"border-width\"></a><code>border-width</code></h4><p>通常我们写<code>border</code>时就会直接写成这样：<code>border: 1px solid #000;</code>类似这样，那这个<code>border-width</code>有什么用呢？这个可以定义四条边是不同宽度的，他的顺序和<code>margin</code>之类的是一样的上右下左这个顺序。</p>\n<p>还有这个用处，而且我这次写页面的时候就用到了：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_3.png\" alt=\"\"></p>\n<p>这个向下小箭头这么实现呢？当然我们可以用图标字体也可以用图片，但是用css我们也可以实现，这可能算是一个hack的方法吧，但是我觉得挺有趣的，我也是review别人代码是学习的。具体css如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">block</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">width</span>: 6<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">height</span>: 6<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border</span>: <span class=\"selector-tag\">solid</span> <span class=\"selector-id\">#867e7a</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">border-width</span>: 0 1<span class=\"selector-tag\">px</span> 1<span class=\"selector-tag\">px</span> 0;</span><br><span class=\"line\"><span class=\"selector-tag\">-webkit-transform</span>: <span class=\"selector-tag\">rotate</span>(45<span class=\"selector-tag\">deg</span>);</span><br><span class=\"line\"><span class=\"selector-tag\">transform</span>: <span class=\"selector-tag\">rotate</span>(45<span class=\"selector-tag\">deg</span>);</span><br></pre></td></tr></table></figure>\n<p>哈哈，真的很聪明，这样用<code>border-width</code>属性隐藏掉两边，再旋转一下就可以了！</p>\n<hr>\n<h4 id=\"超过行数限制显示……\"><a href=\"#超过行数限制显示……\" class=\"headerlink\" title=\"超过行数限制显示……\"></a>超过行数限制显示……</h4><p>这个也是学习的啦，<a href=\"http://www.zhangxinxu.com/study/201510/webkit-line-clamp-text-overflow-ellipsis.html\">张鑫旭的博客</a>，下面贴出css：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    <span class=\"selector-class\">.box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">400px</span>; </span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -webkit-box;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-line-clamp</span>: <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-box-orient</span>: vertical;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"letter-spacing\"><a href=\"#letter-spacing\" class=\"headerlink\" title=\"letter-spacing\"></a><code>letter-spacing</code></h4><p>遇到这样的样式不知道大家是怎么解决的？</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_4.png\" alt=\"\"></p>\n<p>大家是不是在两个字之间加很多的空格（<code>&amp;nbsp;</code>）呢？还是怎么样？可以用一下这个css属性<code>letter-spacing</code>他可以改变字之间的间距，但是他有一个问题就是他会在<code>搜索</code>两个字的后面都加间距字不是居中的，所以配合<code>padding-left</code>加一个和间距相同的左内边距，这样就可以保证字是居中的了。</p>\n<hr>\n<h4 id=\"伪类标签\"><a href=\"#伪类标签\" class=\"headerlink\" title=\"伪类标签\"></a>伪类标签</h4><p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_5.png\" alt=\"\"></p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_6.png\" alt=\"\"></p>\n<p>像图中对勾和横线这样的无意义的标签，我们最好是用before和after伪类来代替。</p>\n"},{"layout":"post","title":"《你不知道的JavaScript》读书笔记——作用域","date":"2016-03-27T16:00:00.000Z","_content":"\n这几天在看《你不知道的JavaScript》这本书，内容简单易懂而且觉得讲的很有意思，趁着还热乎，把刚看完的总结一下吧。这个是第一部分讲的是作用域。\n\n### 1. 初识作用域\n\n作用域是一套规则，用于确定在何处以及如何查找变量。编译器有一个术语，比如我们查找变量a的值，引擎会进行LHS和RHS查询。LHS和RHS是什么呢？通俗的讲就是对赋值操作的左侧和右侧进行查询。\n\n举一个例子，比如对`var a=2`这个赋值操作来讲，左侧和右侧就是`=`等于符号的左侧和右侧（并不一定就是`=`号）。这个`a=2`的赋值操作其实分成两步来进行:\n1. `var a`在其作用域中声明新的变量，这个会在执行`var a=2`之前进行。\n2. 然后会对`a = 2`进行LHS查询变量a，并对a进行赋值。\n\n所有的查询都会从当前作用域开始查找，如果没有找到这个变量呢？就会逐级向上查找直到全局作用域，如果还是没有找到查找都会停止。\n\n不成功的`LHS`查询（就是没有找到这个变量）就会在全局作用域当中创建一个全局变量（非严格模式下）；不成功的`RHS`（就是没有找到这个变量的值）就会抛出一个异常。\n\n****\n\n### 2. 词法作用域\n\n词法作用域通俗讲，就是我们在编写代码时变量的作用域。我们来考虑下面的代码：\n\n```js\nfunction foo(a){\n    var b = a * 2;\n    function bar(c) {\n        console.log(a , b , c);\n    }\n    bar( b * 3 );\n}\n\nfoo( 2 ); // 2, 4 ,12\n   \n```\n\n\n这段代码会包含三个逐级嵌套的作用域：\n1. 最外层的是全局作用域，其中有一个标识符：foo。\n2. 往里是`foo`所创建的作用域，其中有三个标识符：a、bar和b。\n3. `bar`所创建的作用域，其中有一个标识符：c。\n\n在程序运行`console.log( a, b, c )`的时候会查找a、b、c这三个变量，会先在当前的作用域开始查找，也就是`bar`的作用域，如果没有找到呢他就会开始往外查找，直到第一个匹配的标识符的时候，他就会停止了。对`a`来说就是在`foo`的作用域找到的，`b`也是；`c`就在`bar`作用域就找到了。\n\n每一层作用域当中呢，都可以存在同名的变量，但是当你找到第一个匹配的变量的时候，外层作用域这个同名的变量就会被遮蔽，这个叫做**遮蔽效应**。\n**我们可以通过`window.a`这种方式来访问到被遮蔽的同名全局变量，但是其他被遮蔽的同名变量就访问不到了。\n\n文章中还讲到了`词法欺骗`，但是文章不建议使用它们，我就不叙述了。\n\n******\n\n### 3.函数作用域和块作用域\n\n#### 1.函数中的作用域\n\n函数作用域是说：这个函数内部的变量可以在整个函数范围内使用和复用。比如这段代码：\n\n```js\nfunction foo(a) {\n     var b = 2;\n     // ...\n     function bar() {\n         // ...\n     }\n     // ...\n     var c = 3;\n}\n```\n\n标识符`a`、`b`、`c`和`bar`都属于`foo`这个函数的作用域内部，我们在`foo`函数的外部是无法访问到他们的。\n\n#### 2.隐藏内部实现\n\n利用上面说到的，函数外部是无法访问到内部的变量这个特性可以在设计模块或对象的API的时候使用。\n\n比如：\n\n```js\nfunction doSomething(a) {\n     b = a + doSomethingElse( a * 2 );\n     console.log( b * 3 );\n}\nfunction doSomethingElse(a) {\n     return a - 1;\n}\nvar b;\ndoSomething( 2 ); // 15\n```\n\n如果这样来写的话，函数内部的变量都是在全局作用域下的，这个可能会有隐患。可以改变一下，变成这样：\n\n```js\nfunction doSomething(a) {\n     function doSomethingElse(a) {\n     return a - 1; \n     }\n     var b;\n     b = a + doSomethingElse( a * 2 );\n     console.log( b * 3 );\n}\ndoSomething( 2 ); // 15\n```\n \n这样变量都在函数的内部了，外部就没有办法访问到了。这样隐藏内部实现还有好处就是可以避免命名冲突，会造成意外的错误。\n \n```js\nfunction foo() {\n    function bar(a) {\n\t    i = 3; // \n         console.log( a + i );\n     }\n     for (var i=0; i<10; i++) {\n        bar( i * 2 ); // 会出现错误，无限循环\n     } \n}\nfoo();\n\n```\n\n这就是`i=3`覆盖了for循环中的i，造成了错误。可以改成`var i = 3`或者用不同的变量代替，来修改这个错误。\n\n#### 3.全局命名空间\n\n在加载很多第三方库的时候，为什么不会造成命名冲突，是因为库通常会声明一个对象，而将所有用到的变量，放到这个对象的属性中。\n\n```js\nvar MyReallyCoolLibrary = {\n     awesome: \"stuff\",\n     doSomething: function() {\n     // ... \n     },\n     doAnotherThing: function() {\n     // ...\n     } \n};\n\n```\n\n#### 4.函数作用域\n\n我们可以通过隐藏的方式，使外部无法访问到内部的内容：\n\n```js\nvar a = 2;\nfunction foo() { // <-- 添加这行\n     var a = 3;\n     console.log( a ); // 3\n} // <-- 这行 \nfoo(); // <-- 这行\nconsole.log( a ); // 2\n\n```\n\n但是这样`foo`这个命名本身就污染了他所在的作用域，而且需要显式的调用，我们可以用立即执行函数表达式来解决这个问题。\n\n***区分函数表达式和函数声明：看`function`关键字的位置，如果`function`是声明的第一个词，那就是函数声明，否则就是函数表达式。***\n\n立即执行函数表达式又叫IIFE（Immediately Invoked Function Expression），它有两种形式：`(function(){...})()`和`(function(){...}())`，两种形式功能是一样。\n\nIIFE还可以传递参数进去：\n\n```js\nvar a = 2;\n (function IIFE( global ) {\n     var a = 3;\n     console.log( a ); // 3\n     console.log( global.a ); // 2\n })( window );\n console.log( a ); // 2\n```\n \nIIFE还有另外一种变化：\n\n```js\nvar a = 2; \n (function IIFE( def ) {\n     def( window );\n })(function def( global ) {\n     var a = 3;\n     console.log( a ); // 3\n     console.log( global.a ); // 2\n}); \n```\n函数表达式def定义在第二部分，然后当做参数被传递到第一部分中，参数def被调用，把window当做global参数的值传入进去。\n\n#### 5.块作用域\n\nES3开始，有`try/catch`会有块作用域。\n\nES6中新加了`let`关键字，他会有隐式的块作用域。\n\n```js\nvar foo = true;\n if (foo) {\n     let bar = foo * 2;\n     bar = something( bar );\n     console.log( bar );\n }\n console.log( bar ); // ReferenceError\n```\n\n但是这样隐式的块作用域不方便阅读，最好是写成显式的块作用域：\n\n```js\nvar foo = true;\nif (foo) {\n    { // <-- 显式的块\n         let bar = foo * 2;\n         bar = something( bar );\n         console.log( bar );\n    } \n} \nconsole.log( bar ); // ReferenceError\n\n``` \n\n***`let`声明不会进行提升，就是在`let`声明的代码被运行之前，声明不会存在。***\n\n```js\n console.log( bar ); // ReferenceError!\n let bar = 2; \n\n```\n\n除了`let`，ES6还引入了`const`，这个也是用来创建块作用域变量，而且声明的变量值是固定的（常量），修改值的操作会引起错误。\n\n```js\nvar foo = true;\n if (foo) {\n     var a = 2; \n     const b = 3; //  包含在if中的块作用域常量\n     a = 3; // \n     b=4;// 错误! \n } \n console.log( a ); // 3\n console.log( b ); // ReferenceError!\n\n```\n\n*******\n\n### 4.提升\n\n有这样一段代码：\n\n```js\n{\n   console.log( a );\n   var a = 2 ;\n}\n```\n输出的结果是`undefined`，这就是变量声明的提升。当我们看到`var a = 2`这个变量声明的时候，其实有两步：`var a`和`a = 2;`。第一步在编译阶段进行，第二步赋值步骤会在执行到这句代码的时候在进行。\n\n所以上面的代码其实是这么运行的：\n\n```js\nvar a;\nconsole.log( a );\na = 2;\n```\n\n这个过程就叫做**提升**。\n\n***每个作用域都会进行提升操作，变量的声明都会提升到每个作用域的上方。***\n\n```js\nfoo(); \nfunction foo() {\n    console.log( a ); // undefined\n    var a = 2;\n} \n```\n上面这段代码来说，全局作用域和foo的作用域都会分别做提升，实际代码执行起来是这样的：\n\n```js\nfunction foo() {\n     var a;\n     console.log( a ); // undefined\n     a = 2; \n}\nfoo();\n```\n***函数声明会被提升，函数表达式不会被提升***\n\n```js\nfoo(); // TypeError\n bar(); // ReferenceError\n var foo = function bar() {\n     // ...\n}; \n```\n\n如果是一个函数声明的话，变量`foo`其实会被提升，（所以不会报ReferenceError）但是那时没有赋值，`foo`会是`undefined`，会`undefined`进行函数调用时非法的所以报`TypeError`异常。\n\n***函数优先***\n\n```js\nfoo(); // 1\n var foo;\n function foo() {\n     console.log( 1 );\n }\n foo = function() {\n     console.log( 2 );\n}; \n```\n\n函数声明和变量声明都会被提升，如果一个标识符重复声明为变量和函数，函数会首先被提升。上面的代码其实会被引擎理解成这样：\n\n```js\nfunction foo() {\n     console.log( 1 );\n} \nfoo(); // 1 \n foo = function() {\n     console.log( 2 );\n}; \n```\n\n虽说`var foo`是在函数声明之前，但是函数声明会提升，并且会忽略掉重读的var声明。\n\n**但是如果是重复的函数声明，后面的函数声明是可以覆盖前面的。**\n\n```js\nfoo(); // 3 \n function foo() {\n     console.log( 1 );\n} \n var foo = function() {\n     console.log( 2 );\n}; \n function foo() {\n     console.log( 3 );\n} \n```\n\n\n\n\n\n","source":"_posts/2016-03-28-你不知道的JavaScript读书笔记——作用域.md","raw":"---\nlayout: post\ntitle: 《你不知道的JavaScript》读书笔记——作用域\ndate: 2016-03-28\ntags: ['JavaScript','作用域']\ncategories: JavaScript\t\n---\n\n这几天在看《你不知道的JavaScript》这本书，内容简单易懂而且觉得讲的很有意思，趁着还热乎，把刚看完的总结一下吧。这个是第一部分讲的是作用域。\n\n### 1. 初识作用域\n\n作用域是一套规则，用于确定在何处以及如何查找变量。编译器有一个术语，比如我们查找变量a的值，引擎会进行LHS和RHS查询。LHS和RHS是什么呢？通俗的讲就是对赋值操作的左侧和右侧进行查询。\n\n举一个例子，比如对`var a=2`这个赋值操作来讲，左侧和右侧就是`=`等于符号的左侧和右侧（并不一定就是`=`号）。这个`a=2`的赋值操作其实分成两步来进行:\n1. `var a`在其作用域中声明新的变量，这个会在执行`var a=2`之前进行。\n2. 然后会对`a = 2`进行LHS查询变量a，并对a进行赋值。\n\n所有的查询都会从当前作用域开始查找，如果没有找到这个变量呢？就会逐级向上查找直到全局作用域，如果还是没有找到查找都会停止。\n\n不成功的`LHS`查询（就是没有找到这个变量）就会在全局作用域当中创建一个全局变量（非严格模式下）；不成功的`RHS`（就是没有找到这个变量的值）就会抛出一个异常。\n\n****\n\n### 2. 词法作用域\n\n词法作用域通俗讲，就是我们在编写代码时变量的作用域。我们来考虑下面的代码：\n\n```js\nfunction foo(a){\n    var b = a * 2;\n    function bar(c) {\n        console.log(a , b , c);\n    }\n    bar( b * 3 );\n}\n\nfoo( 2 ); // 2, 4 ,12\n   \n```\n\n\n这段代码会包含三个逐级嵌套的作用域：\n1. 最外层的是全局作用域，其中有一个标识符：foo。\n2. 往里是`foo`所创建的作用域，其中有三个标识符：a、bar和b。\n3. `bar`所创建的作用域，其中有一个标识符：c。\n\n在程序运行`console.log( a, b, c )`的时候会查找a、b、c这三个变量，会先在当前的作用域开始查找，也就是`bar`的作用域，如果没有找到呢他就会开始往外查找，直到第一个匹配的标识符的时候，他就会停止了。对`a`来说就是在`foo`的作用域找到的，`b`也是；`c`就在`bar`作用域就找到了。\n\n每一层作用域当中呢，都可以存在同名的变量，但是当你找到第一个匹配的变量的时候，外层作用域这个同名的变量就会被遮蔽，这个叫做**遮蔽效应**。\n**我们可以通过`window.a`这种方式来访问到被遮蔽的同名全局变量，但是其他被遮蔽的同名变量就访问不到了。\n\n文章中还讲到了`词法欺骗`，但是文章不建议使用它们，我就不叙述了。\n\n******\n\n### 3.函数作用域和块作用域\n\n#### 1.函数中的作用域\n\n函数作用域是说：这个函数内部的变量可以在整个函数范围内使用和复用。比如这段代码：\n\n```js\nfunction foo(a) {\n     var b = 2;\n     // ...\n     function bar() {\n         // ...\n     }\n     // ...\n     var c = 3;\n}\n```\n\n标识符`a`、`b`、`c`和`bar`都属于`foo`这个函数的作用域内部，我们在`foo`函数的外部是无法访问到他们的。\n\n#### 2.隐藏内部实现\n\n利用上面说到的，函数外部是无法访问到内部的变量这个特性可以在设计模块或对象的API的时候使用。\n\n比如：\n\n```js\nfunction doSomething(a) {\n     b = a + doSomethingElse( a * 2 );\n     console.log( b * 3 );\n}\nfunction doSomethingElse(a) {\n     return a - 1;\n}\nvar b;\ndoSomething( 2 ); // 15\n```\n\n如果这样来写的话，函数内部的变量都是在全局作用域下的，这个可能会有隐患。可以改变一下，变成这样：\n\n```js\nfunction doSomething(a) {\n     function doSomethingElse(a) {\n     return a - 1; \n     }\n     var b;\n     b = a + doSomethingElse( a * 2 );\n     console.log( b * 3 );\n}\ndoSomething( 2 ); // 15\n```\n \n这样变量都在函数的内部了，外部就没有办法访问到了。这样隐藏内部实现还有好处就是可以避免命名冲突，会造成意外的错误。\n \n```js\nfunction foo() {\n    function bar(a) {\n\t    i = 3; // \n         console.log( a + i );\n     }\n     for (var i=0; i<10; i++) {\n        bar( i * 2 ); // 会出现错误，无限循环\n     } \n}\nfoo();\n\n```\n\n这就是`i=3`覆盖了for循环中的i，造成了错误。可以改成`var i = 3`或者用不同的变量代替，来修改这个错误。\n\n#### 3.全局命名空间\n\n在加载很多第三方库的时候，为什么不会造成命名冲突，是因为库通常会声明一个对象，而将所有用到的变量，放到这个对象的属性中。\n\n```js\nvar MyReallyCoolLibrary = {\n     awesome: \"stuff\",\n     doSomething: function() {\n     // ... \n     },\n     doAnotherThing: function() {\n     // ...\n     } \n};\n\n```\n\n#### 4.函数作用域\n\n我们可以通过隐藏的方式，使外部无法访问到内部的内容：\n\n```js\nvar a = 2;\nfunction foo() { // <-- 添加这行\n     var a = 3;\n     console.log( a ); // 3\n} // <-- 这行 \nfoo(); // <-- 这行\nconsole.log( a ); // 2\n\n```\n\n但是这样`foo`这个命名本身就污染了他所在的作用域，而且需要显式的调用，我们可以用立即执行函数表达式来解决这个问题。\n\n***区分函数表达式和函数声明：看`function`关键字的位置，如果`function`是声明的第一个词，那就是函数声明，否则就是函数表达式。***\n\n立即执行函数表达式又叫IIFE（Immediately Invoked Function Expression），它有两种形式：`(function(){...})()`和`(function(){...}())`，两种形式功能是一样。\n\nIIFE还可以传递参数进去：\n\n```js\nvar a = 2;\n (function IIFE( global ) {\n     var a = 3;\n     console.log( a ); // 3\n     console.log( global.a ); // 2\n })( window );\n console.log( a ); // 2\n```\n \nIIFE还有另外一种变化：\n\n```js\nvar a = 2; \n (function IIFE( def ) {\n     def( window );\n })(function def( global ) {\n     var a = 3;\n     console.log( a ); // 3\n     console.log( global.a ); // 2\n}); \n```\n函数表达式def定义在第二部分，然后当做参数被传递到第一部分中，参数def被调用，把window当做global参数的值传入进去。\n\n#### 5.块作用域\n\nES3开始，有`try/catch`会有块作用域。\n\nES6中新加了`let`关键字，他会有隐式的块作用域。\n\n```js\nvar foo = true;\n if (foo) {\n     let bar = foo * 2;\n     bar = something( bar );\n     console.log( bar );\n }\n console.log( bar ); // ReferenceError\n```\n\n但是这样隐式的块作用域不方便阅读，最好是写成显式的块作用域：\n\n```js\nvar foo = true;\nif (foo) {\n    { // <-- 显式的块\n         let bar = foo * 2;\n         bar = something( bar );\n         console.log( bar );\n    } \n} \nconsole.log( bar ); // ReferenceError\n\n``` \n\n***`let`声明不会进行提升，就是在`let`声明的代码被运行之前，声明不会存在。***\n\n```js\n console.log( bar ); // ReferenceError!\n let bar = 2; \n\n```\n\n除了`let`，ES6还引入了`const`，这个也是用来创建块作用域变量，而且声明的变量值是固定的（常量），修改值的操作会引起错误。\n\n```js\nvar foo = true;\n if (foo) {\n     var a = 2; \n     const b = 3; //  包含在if中的块作用域常量\n     a = 3; // \n     b=4;// 错误! \n } \n console.log( a ); // 3\n console.log( b ); // ReferenceError!\n\n```\n\n*******\n\n### 4.提升\n\n有这样一段代码：\n\n```js\n{\n   console.log( a );\n   var a = 2 ;\n}\n```\n输出的结果是`undefined`，这就是变量声明的提升。当我们看到`var a = 2`这个变量声明的时候，其实有两步：`var a`和`a = 2;`。第一步在编译阶段进行，第二步赋值步骤会在执行到这句代码的时候在进行。\n\n所以上面的代码其实是这么运行的：\n\n```js\nvar a;\nconsole.log( a );\na = 2;\n```\n\n这个过程就叫做**提升**。\n\n***每个作用域都会进行提升操作，变量的声明都会提升到每个作用域的上方。***\n\n```js\nfoo(); \nfunction foo() {\n    console.log( a ); // undefined\n    var a = 2;\n} \n```\n上面这段代码来说，全局作用域和foo的作用域都会分别做提升，实际代码执行起来是这样的：\n\n```js\nfunction foo() {\n     var a;\n     console.log( a ); // undefined\n     a = 2; \n}\nfoo();\n```\n***函数声明会被提升，函数表达式不会被提升***\n\n```js\nfoo(); // TypeError\n bar(); // ReferenceError\n var foo = function bar() {\n     // ...\n}; \n```\n\n如果是一个函数声明的话，变量`foo`其实会被提升，（所以不会报ReferenceError）但是那时没有赋值，`foo`会是`undefined`，会`undefined`进行函数调用时非法的所以报`TypeError`异常。\n\n***函数优先***\n\n```js\nfoo(); // 1\n var foo;\n function foo() {\n     console.log( 1 );\n }\n foo = function() {\n     console.log( 2 );\n}; \n```\n\n函数声明和变量声明都会被提升，如果一个标识符重复声明为变量和函数，函数会首先被提升。上面的代码其实会被引擎理解成这样：\n\n```js\nfunction foo() {\n     console.log( 1 );\n} \nfoo(); // 1 \n foo = function() {\n     console.log( 2 );\n}; \n```\n\n虽说`var foo`是在函数声明之前，但是函数声明会提升，并且会忽略掉重读的var声明。\n\n**但是如果是重复的函数声明，后面的函数声明是可以覆盖前面的。**\n\n```js\nfoo(); // 3 \n function foo() {\n     console.log( 1 );\n} \n var foo = function() {\n     console.log( 2 );\n}; \n function foo() {\n     console.log( 3 );\n} \n```\n\n\n\n\n\n","slug":"你不知道的JavaScript读书笔记——作用域","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1z1001msq5l7sti4h5y","content":"<p>这几天在看《你不知道的JavaScript》这本书，内容简单易懂而且觉得讲的很有意思，趁着还热乎，把刚看完的总结一下吧。这个是第一部分讲的是作用域。</p>\n<h3 id=\"1-初识作用域\"><a href=\"#1-初识作用域\" class=\"headerlink\" title=\"1. 初识作用域\"></a>1. 初识作用域</h3><p>作用域是一套规则，用于确定在何处以及如何查找变量。编译器有一个术语，比如我们查找变量a的值，引擎会进行LHS和RHS查询。LHS和RHS是什么呢？通俗的讲就是对赋值操作的左侧和右侧进行查询。</p>\n<p>举一个例子，比如对<code>var a=2</code>这个赋值操作来讲，左侧和右侧就是<code>=</code>等于符号的左侧和右侧（并不一定就是<code>=</code>号）。这个<code>a=2</code>的赋值操作其实分成两步来进行:</p>\n<ol>\n<li><code>var a</code>在其作用域中声明新的变量，这个会在执行<code>var a=2</code>之前进行。</li>\n<li>然后会对<code>a = 2</code>进行LHS查询变量a，并对a进行赋值。</li>\n</ol>\n<p>所有的查询都会从当前作用域开始查找，如果没有找到这个变量呢？就会逐级向上查找直到全局作用域，如果还是没有找到查找都会停止。</p>\n<p>不成功的<code>LHS</code>查询（就是没有找到这个变量）就会在全局作用域当中创建一个全局变量（非严格模式下）；不成功的<code>RHS</code>（就是没有找到这个变量的值）就会抛出一个异常。</p>\n<hr>\n<h3 id=\"2-词法作用域\"><a href=\"#2-词法作用域\" class=\"headerlink\" title=\"2. 词法作用域\"></a>2. 词法作用域</h3><p>词法作用域通俗讲，就是我们在编写代码时变量的作用域。我们来考虑下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a , b , c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar( b * <span class=\"number\">3</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo( <span class=\"number\">2</span> ); <span class=\"comment\">// 2, 4 ,12</span></span><br></pre></td></tr></table></figure>\n<p>这段代码会包含三个逐级嵌套的作用域：</p>\n<ol>\n<li>最外层的是全局作用域，其中有一个标识符：foo。</li>\n<li>往里是<code>foo</code>所创建的作用域，其中有三个标识符：a、bar和b。</li>\n<li><code>bar</code>所创建的作用域，其中有一个标识符：c。</li>\n</ol>\n<p>在程序运行<code>console.log( a, b, c )</code>的时候会查找a、b、c这三个变量，会先在当前的作用域开始查找，也就是<code>bar</code>的作用域，如果没有找到呢他就会开始往外查找，直到第一个匹配的标识符的时候，他就会停止了。对<code>a</code>来说就是在<code>foo</code>的作用域找到的，<code>b</code>也是；<code>c</code>就在<code>bar</code>作用域就找到了。</p>\n<p>每一层作用域当中呢，都可以存在同名的变量，但是当你找到第一个匹配的变量的时候，外层作用域这个同名的变量就会被遮蔽，这个叫做<strong>遮蔽效应</strong>。<br>**我们可以通过<code>window.a</code>这种方式来访问到被遮蔽的同名全局变量，但是其他被遮蔽的同名变量就访问不到了。</p>\n<p>文章中还讲到了<code>词法欺骗</code>，但是文章不建议使用它们，我就不叙述了。</p>\n<hr>\n<h3 id=\"3-函数作用域和块作用域\"><a href=\"#3-函数作用域和块作用域\" class=\"headerlink\" title=\"3.函数作用域和块作用域\"></a>3.函数作用域和块作用域</h3><h4 id=\"1-函数中的作用域\"><a href=\"#1-函数中的作用域\" class=\"headerlink\" title=\"1.函数中的作用域\"></a>1.函数中的作用域</h4><p>函数作用域是说：这个函数内部的变量可以在整个函数范围内使用和复用。比如这段代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">     <span class=\"comment\">// ...</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">// ...</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">// ...</span></span><br><span class=\"line\">     <span class=\"keyword\">var</span> c = <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>标识符<code>a</code>、<code>b</code>、<code>c</code>和<code>bar</code>都属于<code>foo</code>这个函数的作用域内部，我们在<code>foo</code>函数的外部是无法访问到他们的。</p>\n<h4 id=\"2-隐藏内部实现\"><a href=\"#2-隐藏内部实现\" class=\"headerlink\" title=\"2.隐藏内部实现\"></a>2.隐藏内部实现</h4><p>利用上面说到的，函数外部是无法访问到内部的变量这个特性可以在设计模块或对象的API的时候使用。</p>\n<p>比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">     b = a + doSomethingElse( a * <span class=\"number\">2</span> );</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( b * <span class=\"number\">3</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomethingElse</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> a - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b;</span><br><span class=\"line\">doSomething( <span class=\"number\">2</span> ); <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n<p>如果这样来写的话，函数内部的变量都是在全局作用域下的，这个可能会有隐患。可以改变一下，变成这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomethingElse</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> a - <span class=\"number\">1</span>; </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> b;</span><br><span class=\"line\">     b = a + doSomethingElse( a * <span class=\"number\">2</span> );</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( b * <span class=\"number\">3</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomething( <span class=\"number\">2</span> ); <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n<p>这样变量都在函数的内部了，外部就没有办法访问到了。这样隐藏内部实现还有好处就是可以避免命名冲突，会造成意外的错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">\t    i = <span class=\"number\">3</span>; <span class=\"comment\">// </span></span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( a + i );</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        bar( i * <span class=\"number\">2</span> ); <span class=\"comment\">// 会出现错误，无限循环</span></span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p>这就是<code>i=3</code>覆盖了for循环中的i，造成了错误。可以改成<code>var i = 3</code>或者用不同的变量代替，来修改这个错误。</p>\n<h4 id=\"3-全局命名空间\"><a href=\"#3-全局命名空间\" class=\"headerlink\" title=\"3.全局命名空间\"></a>3.全局命名空间</h4><p>在加载很多第三方库的时候，为什么不会造成命名冲突，是因为库通常会声明一个对象，而将所有用到的变量，放到这个对象的属性中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyReallyCoolLibrary = &#123;</span><br><span class=\"line\">     awesome: <span class=\"string\">\"stuff\"</span>,</span><br><span class=\"line\">     doSomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// ... </span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     doAnotherThing: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// ...</span></span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-函数作用域\"><a href=\"#4-函数作用域\" class=\"headerlink\" title=\"4.函数作用域\"></a>4.函数作用域</h4><p>我们可以通过隐藏的方式，使外部无法访问到内部的内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// &lt;-- 添加这行</span></span><br><span class=\"line\">     <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// &lt;-- 这行 </span></span><br><span class=\"line\">foo(); <span class=\"comment\">// &lt;-- 这行</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>但是这样<code>foo</code>这个命名本身就污染了他所在的作用域，而且需要显式的调用，我们可以用立即执行函数表达式来解决这个问题。</p>\n<p><strong><em>区分函数表达式和函数声明：看<code>function</code>关键字的位置，如果<code>function</code>是声明的第一个词，那就是函数声明，否则就是函数表达式。</em></strong></p>\n<p>立即执行函数表达式又叫IIFE（Immediately Invoked Function Expression），它有两种形式：<code>(function(){...})()</code>和<code>(function(){...}())</code>，两种形式功能是一样。</p>\n<p>IIFE还可以传递参数进去：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"> (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> global </span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"> &#125;)( <span class=\"built_in\">window</span> );</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>IIFE还有另外一种变化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>; </span><br><span class=\"line\"> (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> def </span>) </span>&#123;</span><br><span class=\"line\">     def( <span class=\"built_in\">window</span> );</span><br><span class=\"line\"> &#125;)(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">def</span>(<span class=\"params\"> global </span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>函数表达式def定义在第二部分，然后当做参数被传递到第一部分中，参数def被调用，把window当做global参数的值传入进去。</p>\n<h4 id=\"5-块作用域\"><a href=\"#5-块作用域\" class=\"headerlink\" title=\"5.块作用域\"></a>5.块作用域</h4><p>ES3开始，有<code>try/catch</code>会有块作用域。</p>\n<p>ES6中新加了<code>let</code>关键字，他会有隐式的块作用域。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"literal\">true</span>;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (foo) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">let</span> bar = foo * <span class=\"number\">2</span>;</span><br><span class=\"line\">     bar = something( bar );</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( bar );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( bar ); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n<p>但是这样隐式的块作用域不方便阅读，最好是写成显式的块作用域：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (foo) &#123;</span><br><span class=\"line\">    &#123; <span class=\"comment\">// &lt;-- 显式的块</span></span><br><span class=\"line\">         <span class=\"keyword\">let</span> bar = foo * <span class=\"number\">2</span>;</span><br><span class=\"line\">         bar = something( bar );</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( bar );</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bar ); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span><br><span class=\"line\"></span><br><span class=\"line\">***`</span><span class=\"keyword\">let</span><span class=\"string\">`声明不会进行提升，就是在`</span><span class=\"keyword\">let</span><span class=\"string\">`声明的代码被运行之前，声明不会存在。***</span><br><span class=\"line\"></span><br><span class=\"line\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( bar ); <span class=\"comment\">// ReferenceError!</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>除了<code>let</code>，ES6还引入了<code>const</code>，这个也是用来创建块作用域变量，而且声明的变量值是固定的（常量），修改值的操作会引起错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"literal\">true</span>;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (foo) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>; </span><br><span class=\"line\">     <span class=\"keyword\">const</span> b = <span class=\"number\">3</span>; <span class=\"comment\">//  包含在if中的块作用域常量</span></span><br><span class=\"line\">     a = <span class=\"number\">3</span>; <span class=\"comment\">// </span></span><br><span class=\"line\">     b=<span class=\"number\">4</span>;<span class=\"comment\">// 错误! </span></span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// ReferenceError!</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"4-提升\"><a href=\"#4-提升\" class=\"headerlink\" title=\"4.提升\"></a>4.提升</h3><p>有这样一段代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">   <span class=\"keyword\">var</span> a = <span class=\"number\">2</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出的结果是<code>undefined</code>，这就是变量声明的提升。当我们看到<code>var a = 2</code>这个变量声明的时候，其实有两步：<code>var a</code>和<code>a = 2;</code>。第一步在编译阶段进行，第二步赋值步骤会在执行到这句代码的时候在进行。</p>\n<p>所以上面的代码其实是这么运行的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>这个过程就叫做<strong>提升</strong>。</p>\n<p><strong><em>每个作用域都会进行提升操作，变量的声明都会提升到每个作用域的上方。</em></strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码来说，全局作用域和foo的作用域都会分别做提升，实际代码执行起来是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">     a = <span class=\"number\">2</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p><strong><em>函数声明会被提升，函数表达式不会被提升</em></strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\"> bar(); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果是一个函数声明的话，变量<code>foo</code>其实会被提升，（所以不会报ReferenceError）但是那时没有赋值，<code>foo</code>会是<code>undefined</code>，会<code>undefined</code>进行函数调用时非法的所以报<code>TypeError</code>异常。</p>\n<p><strong><em>函数优先</em></strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 1</span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">1</span> );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">2</span> );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>函数声明和变量声明都会被提升，如果一个标识符重复声明为变量和函数，函数会首先被提升。上面的代码其实会被引擎理解成这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">foo(); <span class=\"comment\">// 1 </span></span><br><span class=\"line\"> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">2</span> );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>虽说<code>var foo</code>是在函数声明之前，但是函数声明会提升，并且会忽略掉重读的var声明。</p>\n<p><strong>但是如果是重复的函数声明，后面的函数声明是可以覆盖前面的。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 3 </span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">2</span> );</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">3</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>这几天在看《你不知道的JavaScript》这本书，内容简单易懂而且觉得讲的很有意思，趁着还热乎，把刚看完的总结一下吧。这个是第一部分讲的是作用域。</p>\n<h3 id=\"1-初识作用域\"><a href=\"#1-初识作用域\" class=\"headerlink\" title=\"1. 初识作用域\"></a>1. 初识作用域</h3><p>作用域是一套规则，用于确定在何处以及如何查找变量。编译器有一个术语，比如我们查找变量a的值，引擎会进行LHS和RHS查询。LHS和RHS是什么呢？通俗的讲就是对赋值操作的左侧和右侧进行查询。</p>\n<p>举一个例子，比如对<code>var a=2</code>这个赋值操作来讲，左侧和右侧就是<code>=</code>等于符号的左侧和右侧（并不一定就是<code>=</code>号）。这个<code>a=2</code>的赋值操作其实分成两步来进行:</p>\n<ol>\n<li><code>var a</code>在其作用域中声明新的变量，这个会在执行<code>var a=2</code>之前进行。</li>\n<li>然后会对<code>a = 2</code>进行LHS查询变量a，并对a进行赋值。</li>\n</ol>\n<p>所有的查询都会从当前作用域开始查找，如果没有找到这个变量呢？就会逐级向上查找直到全局作用域，如果还是没有找到查找都会停止。</p>\n<p>不成功的<code>LHS</code>查询（就是没有找到这个变量）就会在全局作用域当中创建一个全局变量（非严格模式下）；不成功的<code>RHS</code>（就是没有找到这个变量的值）就会抛出一个异常。</p>\n<hr>\n<h3 id=\"2-词法作用域\"><a href=\"#2-词法作用域\" class=\"headerlink\" title=\"2. 词法作用域\"></a>2. 词法作用域</h3><p>词法作用域通俗讲，就是我们在编写代码时变量的作用域。我们来考虑下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a * <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(a , b , c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar( b * <span class=\"number\">3</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo( <span class=\"number\">2</span> ); <span class=\"comment\">// 2, 4 ,12</span></span><br></pre></td></tr></table></figure>\n<p>这段代码会包含三个逐级嵌套的作用域：</p>\n<ol>\n<li>最外层的是全局作用域，其中有一个标识符：foo。</li>\n<li>往里是<code>foo</code>所创建的作用域，其中有三个标识符：a、bar和b。</li>\n<li><code>bar</code>所创建的作用域，其中有一个标识符：c。</li>\n</ol>\n<p>在程序运行<code>console.log( a, b, c )</code>的时候会查找a、b、c这三个变量，会先在当前的作用域开始查找，也就是<code>bar</code>的作用域，如果没有找到呢他就会开始往外查找，直到第一个匹配的标识符的时候，他就会停止了。对<code>a</code>来说就是在<code>foo</code>的作用域找到的，<code>b</code>也是；<code>c</code>就在<code>bar</code>作用域就找到了。</p>\n<p>每一层作用域当中呢，都可以存在同名的变量，但是当你找到第一个匹配的变量的时候，外层作用域这个同名的变量就会被遮蔽，这个叫做<strong>遮蔽效应</strong>。<br>**我们可以通过<code>window.a</code>这种方式来访问到被遮蔽的同名全局变量，但是其他被遮蔽的同名变量就访问不到了。</p>\n<p>文章中还讲到了<code>词法欺骗</code>，但是文章不建议使用它们，我就不叙述了。</p>\n<hr>\n<h3 id=\"3-函数作用域和块作用域\"><a href=\"#3-函数作用域和块作用域\" class=\"headerlink\" title=\"3.函数作用域和块作用域\"></a>3.函数作用域和块作用域</h3><h4 id=\"1-函数中的作用域\"><a href=\"#1-函数中的作用域\" class=\"headerlink\" title=\"1.函数中的作用域\"></a>1.函数中的作用域</h4><p>函数作用域是说：这个函数内部的变量可以在整个函数范围内使用和复用。比如这段代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">     <span class=\"comment\">// ...</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">// ...</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">// ...</span></span><br><span class=\"line\">     <span class=\"keyword\">var</span> c = <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>标识符<code>a</code>、<code>b</code>、<code>c</code>和<code>bar</code>都属于<code>foo</code>这个函数的作用域内部，我们在<code>foo</code>函数的外部是无法访问到他们的。</p>\n<h4 id=\"2-隐藏内部实现\"><a href=\"#2-隐藏内部实现\" class=\"headerlink\" title=\"2.隐藏内部实现\"></a>2.隐藏内部实现</h4><p>利用上面说到的，函数外部是无法访问到内部的变量这个特性可以在设计模块或对象的API的时候使用。</p>\n<p>比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">     b = a + doSomethingElse( a * <span class=\"number\">2</span> );</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( b * <span class=\"number\">3</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomethingElse</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> a - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b;</span><br><span class=\"line\">doSomething( <span class=\"number\">2</span> ); <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n<p>如果这样来写的话，函数内部的变量都是在全局作用域下的，这个可能会有隐患。可以改变一下，变成这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomethingElse</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> a - <span class=\"number\">1</span>; </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> b;</span><br><span class=\"line\">     b = a + doSomethingElse( a * <span class=\"number\">2</span> );</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( b * <span class=\"number\">3</span> );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomething( <span class=\"number\">2</span> ); <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n<p>这样变量都在函数的内部了，外部就没有办法访问到了。这样隐藏内部实现还有好处就是可以避免命名冲突，会造成意外的错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">\t    i = <span class=\"number\">3</span>; <span class=\"comment\">// </span></span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( a + i );</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        bar( i * <span class=\"number\">2</span> ); <span class=\"comment\">// 会出现错误，无限循环</span></span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p>这就是<code>i=3</code>覆盖了for循环中的i，造成了错误。可以改成<code>var i = 3</code>或者用不同的变量代替，来修改这个错误。</p>\n<h4 id=\"3-全局命名空间\"><a href=\"#3-全局命名空间\" class=\"headerlink\" title=\"3.全局命名空间\"></a>3.全局命名空间</h4><p>在加载很多第三方库的时候，为什么不会造成命名冲突，是因为库通常会声明一个对象，而将所有用到的变量，放到这个对象的属性中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyReallyCoolLibrary = &#123;</span><br><span class=\"line\">     awesome: <span class=\"string\">\"stuff\"</span>,</span><br><span class=\"line\">     doSomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// ... </span></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     doAnotherThing: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// ...</span></span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-函数作用域\"><a href=\"#4-函数作用域\" class=\"headerlink\" title=\"4.函数作用域\"></a>4.函数作用域</h4><p>我们可以通过隐藏的方式，使外部无法访问到内部的内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// &lt;-- 添加这行</span></span><br><span class=\"line\">     <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// &lt;-- 这行 </span></span><br><span class=\"line\">foo(); <span class=\"comment\">// &lt;-- 这行</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>但是这样<code>foo</code>这个命名本身就污染了他所在的作用域，而且需要显式的调用，我们可以用立即执行函数表达式来解决这个问题。</p>\n<p><strong><em>区分函数表达式和函数声明：看<code>function</code>关键字的位置，如果<code>function</code>是声明的第一个词，那就是函数声明，否则就是函数表达式。</em></strong></p>\n<p>立即执行函数表达式又叫IIFE（Immediately Invoked Function Expression），它有两种形式：<code>(function(){...})()</code>和<code>(function(){...}())</code>，两种形式功能是一样。</p>\n<p>IIFE还可以传递参数进去：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"> (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> global </span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\"> &#125;)( <span class=\"built_in\">window</span> );</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>IIFE还有另外一种变化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>; </span><br><span class=\"line\"> (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">IIFE</span>(<span class=\"params\"> def </span>) </span>&#123;</span><br><span class=\"line\">     def( <span class=\"built_in\">window</span> );</span><br><span class=\"line\"> &#125;)(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">def</span>(<span class=\"params\"> global </span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( global.a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>函数表达式def定义在第二部分，然后当做参数被传递到第一部分中，参数def被调用，把window当做global参数的值传入进去。</p>\n<h4 id=\"5-块作用域\"><a href=\"#5-块作用域\" class=\"headerlink\" title=\"5.块作用域\"></a>5.块作用域</h4><p>ES3开始，有<code>try/catch</code>会有块作用域。</p>\n<p>ES6中新加了<code>let</code>关键字，他会有隐式的块作用域。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"literal\">true</span>;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (foo) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">let</span> bar = foo * <span class=\"number\">2</span>;</span><br><span class=\"line\">     bar = something( bar );</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( bar );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( bar ); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n<p>但是这样隐式的块作用域不方便阅读，最好是写成显式的块作用域：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (foo) &#123;</span><br><span class=\"line\">    &#123; <span class=\"comment\">// &lt;-- 显式的块</span></span><br><span class=\"line\">         <span class=\"keyword\">let</span> bar = foo * <span class=\"number\">2</span>;</span><br><span class=\"line\">         bar = something( bar );</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( bar );</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( bar ); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span><br><span class=\"line\"></span><br><span class=\"line\">***`</span><span class=\"keyword\">let</span><span class=\"string\">`声明不会进行提升，就是在`</span><span class=\"keyword\">let</span><span class=\"string\">`声明的代码被运行之前，声明不会存在。***</span><br><span class=\"line\"></span><br><span class=\"line\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( bar ); <span class=\"comment\">// ReferenceError!</span></span><br><span class=\"line\"> <span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>除了<code>let</code>，ES6还引入了<code>const</code>，这个也是用来创建块作用域变量，而且声明的变量值是固定的（常量），修改值的操作会引起错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"literal\">true</span>;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (foo) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>; </span><br><span class=\"line\">     <span class=\"keyword\">const</span> b = <span class=\"number\">3</span>; <span class=\"comment\">//  包含在if中的块作用域常量</span></span><br><span class=\"line\">     a = <span class=\"number\">3</span>; <span class=\"comment\">// </span></span><br><span class=\"line\">     b=<span class=\"number\">4</span>;<span class=\"comment\">// 错误! </span></span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 3</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// ReferenceError!</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"4-提升\"><a href=\"#4-提升\" class=\"headerlink\" title=\"4.提升\"></a>4.提升</h3><p>有这样一段代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">   <span class=\"keyword\">var</span> a = <span class=\"number\">2</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出的结果是<code>undefined</code>，这就是变量声明的提升。当我们看到<code>var a = 2</code>这个变量声明的时候，其实有两步：<code>var a</code>和<code>a = 2;</code>。第一步在编译阶段进行，第二步赋值步骤会在执行到这句代码的时候在进行。</p>\n<p>所以上面的代码其实是这么运行的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>这个过程就叫做<strong>提升</strong>。</p>\n<p><strong><em>每个作用域都会进行提升操作，变量的声明都会提升到每个作用域的上方。</em></strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码来说，全局作用域和foo的作用域都会分别做提升，实际代码执行起来是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> a;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">     a = <span class=\"number\">2</span>; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p><strong><em>函数声明会被提升，函数表达式不会被提升</em></strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// TypeError</span></span><br><span class=\"line\"> bar(); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果是一个函数声明的话，变量<code>foo</code>其实会被提升，（所以不会报ReferenceError）但是那时没有赋值，<code>foo</code>会是<code>undefined</code>，会<code>undefined</code>进行函数调用时非法的所以报<code>TypeError</code>异常。</p>\n<p><strong><em>函数优先</em></strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 1</span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">1</span> );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">2</span> );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>函数声明和变量声明都会被提升，如果一个标识符重复声明为变量和函数，函数会首先被提升。上面的代码其实会被引擎理解成这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">foo(); <span class=\"comment\">// 1 </span></span><br><span class=\"line\"> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">2</span> );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>虽说<code>var foo</code>是在函数声明之前，但是函数声明会提升，并且会忽略掉重读的var声明。</p>\n<p><strong>但是如果是重复的函数声明，后面的函数声明是可以覆盖前面的。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">// 3 </span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">1</span> );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">2</span> );</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"number\">3</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"《你不知道的JavaScript》读书笔记——闭包","date":"2016-03-28T16:00:00.000Z","_content":"\n### 理解闭包\n\n闭包是什么，怎么理解？\n\n闭包就是一个作用域的外部变量保持着对这个作用域的引用，这个引用就叫做闭包。\n\n这么讲有些晦涩，看这个代码：\n\n```js\nfunction foo() {\n     var a = 2;\n     function bar() {\n         console.log( a );\n     }\n     return bar; \n} \nvar baz = foo();\nbaz(); // 2 这就是闭包\n```\n\n因为`baz`本身是`foo`作用域之外的变量，根据作用域的规则，`baz`本身是不可以访问到`foo`作用域内的变量的。\n\n本来在通常的情况下，在函数执行完后，如果函数在后面不再使用的时候，会进行垃圾回收机制，把`foo`函数内的作用域销毁，把不再使用到的内存释放掉。\n\n但是正因为闭包，这个作用域没有被销毁。原因是`foo()`函数执行之后的返回值`bar`，就是`bar`内部的函数即`function bar(){console.log( a );}`，把这个赋值给了`baz`，`baz`在被调用时（`baz()`）因为`baz`中用到了变量`a`，而变量`a`是在`foo`的作用域中，所以`baz`必须得拥有`foo`函数的作用域闭包才能够正常运行，所以`foo`的作用域不会被销毁会一直存在，以便`baz`之后调用的时候能正常运行。\n\n这么说还是很绕，简单讲就是`foo`函数外面的变量`baz`要用到`foo`作用域里面的东西，这就叫`baz`拥有`foo`的闭包。\n\n**再简单讲就是函数调函数。（一个同事说的，一想好像有一些道理）**\n\n***在定时器、时间监听器、Ajax请求、跨窗口通信、或者任何其他的异步（或者同步）任务中，只要是用了回调函数，实际上就是在使用闭包。***\n\n### 循环和闭包\n\n看一个循环的例子：\n\n```js\nfor (var i=1; i<=5; i++) {\n     setTimeout( function timer() {\n         console.log( i );\n     }, i*1000 );\n} \n```\n\n本来这段代码的预期是，分别输出1~5，每秒一次，每次一个。但是实际上他会每秒一个的频率输出五次6。\n\n造成这样的原因，书上讲的是循环中的五个函数是在各个迭代中分别定义的，但是他们都被封闭在一个共享的全局作用域当中，实际只有一个`i`。\n\n解决办法是运用IIFE，并在每次循环中的IIFE内保存`i`的值。\n\n```js\nfor (var i=1; i<=5; i++) {\n     (function() {\n         var j = i;\n         setTimeout( function timer() {\n             console.log( j );\n         }, j*1000 );\n     })(); \n} \n```\n\n再改进一下代码：\n\n```js\nfor (var i=1; i<=5; i++) {\n     (function(j) {\n         setTimeout( function timer() {\n             console.log( j );\n         }, j*1000 );\n     })( i );\n} \n```\n\n如果运用ES6就会更加简单，只要运用`let`声明的块作用域：\n\n```js\nfor (let i=1; i<=5; i++) {\n     setTimeout( function timer() {\n         console.log( i );\n     }, i*1000 );\n} \n```\n\n### 模块\n\n模块也是利用闭包来实现的。\n\n```js\nfunction CoolModule() {\n     var something = \"cool\";\n     var another = [1, 2, 3];\n     function doSomething() {\n         console.log( something );\n     } \n     function doAnother() {\n         console.log( another.join( \" ! \" ) );\n     } \n     return {\n         doSomething: doSomething,\n         doAnother: doAnother\n     }; \n} \nvar foo = CoolModule();\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1 ! 2 ! 3\n```\n\n这样的模式就是最常见的模块的实现方法。返回值是一个包含内部的函数的对象。因为`CoolModule()`是一个函数，必须调用这个外部的函数后才能创建一个包含内部作用域的闭包。并且返回对象含有的是内部函数而不是内部变量的引用，内部变量是隐藏且私有的状态。\n\n\u0010模块也是函数，也可以接受参数：\n\n```js\nfunction CoolModule(id) {\n     function identify() {\n         console.log( id );\n     }\n     return {\n         identify: identify\n     }; \n } \n var foo1 = CoolModule( \"foo 1\" );\n var foo2 = CoolModule( \"foo 2\" );\n foo1.identify(); // \"foo 1\"\n foo2.identify(); // \"foo 2\"\n```\n\nES6为模块添加了语法的支持，ES6可以把文件当做模块来加载，但是要注意ES6的模块没有行内格式，就是每个模块必须在一个单独的文件中。\n\n`bar.js`\n\n```js\n function hello(who) {\n     return \"Let me introduce: \" + who;\n }\n export hello;\n```\n \n`foo.js`\n\n```js\n//仅从bar模块导入hello()\nimport hello from \"bar\"; \n var hungry = \"hippo\";\n function awesome() {\n     console.log(\n         hello( hungry ).toUpperCase()\n     );\n }\n export awesome;\n```\n\n`baz.js`\n\n```js\n//导入完整的foo和bar模块\nmodule foo from \"foo\"; \nmodule bar from \"bar\"; \n console.log(\n     bar.hello( \"rhino\" )\n ); // Let me introduce: rhino\n foo.awesome(); // LET ME INTRODUCE: HIPPO\n```\n\n`import`可以将一个模块中的一个或多个API引入到当前作用域，并分别绑定在一个变量上。`module`会将整个模块的API引入并绑定到一个变量上。`export`会将当前模块的变量或函数导出为公共的API。","source":"_posts/2016-03-29-你不知道的JavaScript读书笔记——闭包.md","raw":"---\nlayout: post\ntitle: 《你不知道的JavaScript》读书笔记——闭包\ndate: 2016-03-29\ntags: ['JavaScript','闭包']\ncategories: JavaScript\t\n---\n\n### 理解闭包\n\n闭包是什么，怎么理解？\n\n闭包就是一个作用域的外部变量保持着对这个作用域的引用，这个引用就叫做闭包。\n\n这么讲有些晦涩，看这个代码：\n\n```js\nfunction foo() {\n     var a = 2;\n     function bar() {\n         console.log( a );\n     }\n     return bar; \n} \nvar baz = foo();\nbaz(); // 2 这就是闭包\n```\n\n因为`baz`本身是`foo`作用域之外的变量，根据作用域的规则，`baz`本身是不可以访问到`foo`作用域内的变量的。\n\n本来在通常的情况下，在函数执行完后，如果函数在后面不再使用的时候，会进行垃圾回收机制，把`foo`函数内的作用域销毁，把不再使用到的内存释放掉。\n\n但是正因为闭包，这个作用域没有被销毁。原因是`foo()`函数执行之后的返回值`bar`，就是`bar`内部的函数即`function bar(){console.log( a );}`，把这个赋值给了`baz`，`baz`在被调用时（`baz()`）因为`baz`中用到了变量`a`，而变量`a`是在`foo`的作用域中，所以`baz`必须得拥有`foo`函数的作用域闭包才能够正常运行，所以`foo`的作用域不会被销毁会一直存在，以便`baz`之后调用的时候能正常运行。\n\n这么说还是很绕，简单讲就是`foo`函数外面的变量`baz`要用到`foo`作用域里面的东西，这就叫`baz`拥有`foo`的闭包。\n\n**再简单讲就是函数调函数。（一个同事说的，一想好像有一些道理）**\n\n***在定时器、时间监听器、Ajax请求、跨窗口通信、或者任何其他的异步（或者同步）任务中，只要是用了回调函数，实际上就是在使用闭包。***\n\n### 循环和闭包\n\n看一个循环的例子：\n\n```js\nfor (var i=1; i<=5; i++) {\n     setTimeout( function timer() {\n         console.log( i );\n     }, i*1000 );\n} \n```\n\n本来这段代码的预期是，分别输出1~5，每秒一次，每次一个。但是实际上他会每秒一个的频率输出五次6。\n\n造成这样的原因，书上讲的是循环中的五个函数是在各个迭代中分别定义的，但是他们都被封闭在一个共享的全局作用域当中，实际只有一个`i`。\n\n解决办法是运用IIFE，并在每次循环中的IIFE内保存`i`的值。\n\n```js\nfor (var i=1; i<=5; i++) {\n     (function() {\n         var j = i;\n         setTimeout( function timer() {\n             console.log( j );\n         }, j*1000 );\n     })(); \n} \n```\n\n再改进一下代码：\n\n```js\nfor (var i=1; i<=5; i++) {\n     (function(j) {\n         setTimeout( function timer() {\n             console.log( j );\n         }, j*1000 );\n     })( i );\n} \n```\n\n如果运用ES6就会更加简单，只要运用`let`声明的块作用域：\n\n```js\nfor (let i=1; i<=5; i++) {\n     setTimeout( function timer() {\n         console.log( i );\n     }, i*1000 );\n} \n```\n\n### 模块\n\n模块也是利用闭包来实现的。\n\n```js\nfunction CoolModule() {\n     var something = \"cool\";\n     var another = [1, 2, 3];\n     function doSomething() {\n         console.log( something );\n     } \n     function doAnother() {\n         console.log( another.join( \" ! \" ) );\n     } \n     return {\n         doSomething: doSomething,\n         doAnother: doAnother\n     }; \n} \nvar foo = CoolModule();\nfoo.doSomething(); // cool\nfoo.doAnother(); // 1 ! 2 ! 3\n```\n\n这样的模式就是最常见的模块的实现方法。返回值是一个包含内部的函数的对象。因为`CoolModule()`是一个函数，必须调用这个外部的函数后才能创建一个包含内部作用域的闭包。并且返回对象含有的是内部函数而不是内部变量的引用，内部变量是隐藏且私有的状态。\n\n\u0010模块也是函数，也可以接受参数：\n\n```js\nfunction CoolModule(id) {\n     function identify() {\n         console.log( id );\n     }\n     return {\n         identify: identify\n     }; \n } \n var foo1 = CoolModule( \"foo 1\" );\n var foo2 = CoolModule( \"foo 2\" );\n foo1.identify(); // \"foo 1\"\n foo2.identify(); // \"foo 2\"\n```\n\nES6为模块添加了语法的支持，ES6可以把文件当做模块来加载，但是要注意ES6的模块没有行内格式，就是每个模块必须在一个单独的文件中。\n\n`bar.js`\n\n```js\n function hello(who) {\n     return \"Let me introduce: \" + who;\n }\n export hello;\n```\n \n`foo.js`\n\n```js\n//仅从bar模块导入hello()\nimport hello from \"bar\"; \n var hungry = \"hippo\";\n function awesome() {\n     console.log(\n         hello( hungry ).toUpperCase()\n     );\n }\n export awesome;\n```\n\n`baz.js`\n\n```js\n//导入完整的foo和bar模块\nmodule foo from \"foo\"; \nmodule bar from \"bar\"; \n console.log(\n     bar.hello( \"rhino\" )\n ); // Let me introduce: rhino\n foo.awesome(); // LET ME INTRODUCE: HIPPO\n```\n\n`import`可以将一个模块中的一个或多个API引入到当前作用域，并分别绑定在一个变量上。`module`会将整个模块的API引入并绑定到一个变量上。`export`会将当前模块的变量或函数导出为公共的API。","slug":"你不知道的JavaScript读书笔记——闭包","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1z7001psq5lbcx40w6f","content":"<h3 id=\"理解闭包\"><a href=\"#理解闭包\" class=\"headerlink\" title=\"理解闭包\"></a>理解闭包</h3><p>闭包是什么，怎么理解？</p>\n<p>闭包就是一个作用域的外部变量保持着对这个作用域的引用，这个引用就叫做闭包。</p>\n<p>这么讲有些晦涩，看这个代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> bar; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = foo();</span><br><span class=\"line\">baz(); <span class=\"comment\">// 2 这就是闭包</span></span><br></pre></td></tr></table></figure>\n<p>因为<code>baz</code>本身是<code>foo</code>作用域之外的变量，根据作用域的规则，<code>baz</code>本身是不可以访问到<code>foo</code>作用域内的变量的。</p>\n<p>本来在通常的情况下，在函数执行完后，如果函数在后面不再使用的时候，会进行垃圾回收机制，把<code>foo</code>函数内的作用域销毁，把不再使用到的内存释放掉。</p>\n<p>但是正因为闭包，这个作用域没有被销毁。原因是<code>foo()</code>函数执行之后的返回值<code>bar</code>，就是<code>bar</code>内部的函数即<code>function bar(){console.log( a );}</code>，把这个赋值给了<code>baz</code>，<code>baz</code>在被调用时（<code>baz()</code>）因为<code>baz</code>中用到了变量<code>a</code>，而变量<code>a</code>是在<code>foo</code>的作用域中，所以<code>baz</code>必须得拥有<code>foo</code>函数的作用域闭包才能够正常运行，所以<code>foo</code>的作用域不会被销毁会一直存在，以便<code>baz</code>之后调用的时候能正常运行。</p>\n<p>这么说还是很绕，简单讲就是<code>foo</code>函数外面的变量<code>baz</code>要用到<code>foo</code>作用域里面的东西，这就叫<code>baz</code>拥有<code>foo</code>的闭包。</p>\n<p><strong>再简单讲就是函数调函数。（一个同事说的，一想好像有一些道理）</strong></p>\n<p><strong><em>在定时器、时间监听器、Ajax请求、跨窗口通信、或者任何其他的异步（或者同步）任务中，只要是用了回调函数，实际上就是在使用闭包。</em></strong></p>\n<h3 id=\"循环和闭包\"><a href=\"#循环和闭包\" class=\"headerlink\" title=\"循环和闭包\"></a>循环和闭包</h3><p>看一个循环的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">     setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">     &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本来这段代码的预期是，分别输出1~5，每秒一次，每次一个。但是实际上他会每秒一个的频率输出五次6。</p>\n<p>造成这样的原因，书上讲的是循环中的五个函数是在各个迭代中分别定义的，但是他们都被封闭在一个共享的全局作用域当中，实际只有一个<code>i</code>。</p>\n<p>解决办法是运用IIFE，并在每次循环中的IIFE内保存<code>i</code>的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">     (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> j = i;</span><br><span class=\"line\">         setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"built_in\">console</span>.log( j );</span><br><span class=\"line\">         &#125;, j*<span class=\"number\">1000</span> );</span><br><span class=\"line\">     &#125;)(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再改进一下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">     (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>) </span>&#123;</span><br><span class=\"line\">         setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"built_in\">console</span>.log( j );</span><br><span class=\"line\">         &#125;, j*<span class=\"number\">1000</span> );</span><br><span class=\"line\">     &#125;)( i );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果运用ES6就会更加简单，只要运用<code>let</code>声明的块作用域：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">     setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">     &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><p>模块也是利用闭包来实现的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">CoolModule</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> something = <span class=\"string\">\"cool\"</span>;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( something );</span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doAnother</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( another.join( <span class=\"string\">\" ! \"</span> ) );</span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">         doSomething: doSomething,</span><br><span class=\"line\">         doAnother: doAnother</span><br><span class=\"line\">     &#125;; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = CoolModule();</span><br><span class=\"line\">foo.doSomething(); <span class=\"comment\">// cool</span></span><br><span class=\"line\">foo.doAnother(); <span class=\"comment\">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>\n<p>这样的模式就是最常见的模块的实现方法。返回值是一个包含内部的函数的对象。因为<code>CoolModule()</code>是一个函数，必须调用这个外部的函数后才能创建一个包含内部作用域的闭包。并且返回对象含有的是内部函数而不是内部变量的引用，内部变量是隐藏且私有的状态。</p>\n<p>\u0010模块也是函数，也可以接受参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">CoolModule</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identify</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( id );</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">         identify: identify</span><br><span class=\"line\">     &#125;; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> foo1 = CoolModule( <span class=\"string\">\"foo 1\"</span> );</span><br><span class=\"line\"> <span class=\"keyword\">var</span> foo2 = CoolModule( <span class=\"string\">\"foo 2\"</span> );</span><br><span class=\"line\"> foo1.identify(); <span class=\"comment\">// \"foo 1\"</span></span><br><span class=\"line\"> foo2.identify(); <span class=\"comment\">// \"foo 2\"</span></span><br></pre></td></tr></table></figure>\n<p>ES6为模块添加了语法的支持，ES6可以把文件当做模块来加载，但是要注意ES6的模块没有行内格式，就是每个模块必须在一个单独的文件中。</p>\n<p><code>bar.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\">who</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Let me introduce: \"</span> + who;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> hello;</span><br></pre></td></tr></table></figure>\n<p><code>foo.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//仅从bar模块导入hello()</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> hello <span class=\"keyword\">from</span> <span class=\"string\">\"bar\"</span>; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> hungry = <span class=\"string\">\"hippo\"</span>;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">awesome</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">         hello( hungry ).toUpperCase()</span><br><span class=\"line\">     );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">export</span> awesome;</span><br></pre></td></tr></table></figure>\n<p><code>baz.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//导入完整的foo和bar模块</span></span><br><span class=\"line\"><span class=\"built_in\">module</span> foo <span class=\"keyword\">from</span> <span class=\"string\">\"foo\"</span>; </span><br><span class=\"line\"><span class=\"built_in\">module</span> bar <span class=\"keyword\">from</span> <span class=\"string\">\"bar\"</span>; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">     bar.hello( <span class=\"string\">\"rhino\"</span> )</span><br><span class=\"line\"> ); <span class=\"comment\">// Let me introduce: rhino</span></span><br><span class=\"line\"> foo.awesome(); <span class=\"comment\">// LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure>\n<p><code>import</code>可以将一个模块中的一个或多个API引入到当前作用域，并分别绑定在一个变量上。<code>module</code>会将整个模块的API引入并绑定到一个变量上。<code>export</code>会将当前模块的变量或函数导出为公共的API。</p>\n","excerpt":"","more":"<h3 id=\"理解闭包\"><a href=\"#理解闭包\" class=\"headerlink\" title=\"理解闭包\"></a>理解闭包</h3><p>闭包是什么，怎么理解？</p>\n<p>闭包就是一个作用域的外部变量保持着对这个作用域的引用，这个引用就叫做闭包。</p>\n<p>这么讲有些晦涩，看这个代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( a );</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> bar; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> baz = foo();</span><br><span class=\"line\">baz(); <span class=\"comment\">// 2 这就是闭包</span></span><br></pre></td></tr></table></figure>\n<p>因为<code>baz</code>本身是<code>foo</code>作用域之外的变量，根据作用域的规则，<code>baz</code>本身是不可以访问到<code>foo</code>作用域内的变量的。</p>\n<p>本来在通常的情况下，在函数执行完后，如果函数在后面不再使用的时候，会进行垃圾回收机制，把<code>foo</code>函数内的作用域销毁，把不再使用到的内存释放掉。</p>\n<p>但是正因为闭包，这个作用域没有被销毁。原因是<code>foo()</code>函数执行之后的返回值<code>bar</code>，就是<code>bar</code>内部的函数即<code>function bar(){console.log( a );}</code>，把这个赋值给了<code>baz</code>，<code>baz</code>在被调用时（<code>baz()</code>）因为<code>baz</code>中用到了变量<code>a</code>，而变量<code>a</code>是在<code>foo</code>的作用域中，所以<code>baz</code>必须得拥有<code>foo</code>函数的作用域闭包才能够正常运行，所以<code>foo</code>的作用域不会被销毁会一直存在，以便<code>baz</code>之后调用的时候能正常运行。</p>\n<p>这么说还是很绕，简单讲就是<code>foo</code>函数外面的变量<code>baz</code>要用到<code>foo</code>作用域里面的东西，这就叫<code>baz</code>拥有<code>foo</code>的闭包。</p>\n<p><strong>再简单讲就是函数调函数。（一个同事说的，一想好像有一些道理）</strong></p>\n<p><strong><em>在定时器、时间监听器、Ajax请求、跨窗口通信、或者任何其他的异步（或者同步）任务中，只要是用了回调函数，实际上就是在使用闭包。</em></strong></p>\n<h3 id=\"循环和闭包\"><a href=\"#循环和闭包\" class=\"headerlink\" title=\"循环和闭包\"></a>循环和闭包</h3><p>看一个循环的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">     setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">     &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本来这段代码的预期是，分别输出1~5，每秒一次，每次一个。但是实际上他会每秒一个的频率输出五次6。</p>\n<p>造成这样的原因，书上讲的是循环中的五个函数是在各个迭代中分别定义的，但是他们都被封闭在一个共享的全局作用域当中，实际只有一个<code>i</code>。</p>\n<p>解决办法是运用IIFE，并在每次循环中的IIFE内保存<code>i</code>的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">     (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> j = i;</span><br><span class=\"line\">         setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"built_in\">console</span>.log( j );</span><br><span class=\"line\">         &#125;, j*<span class=\"number\">1000</span> );</span><br><span class=\"line\">     &#125;)(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再改进一下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">     (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>) </span>&#123;</span><br><span class=\"line\">         setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">             <span class=\"built_in\">console</span>.log( j );</span><br><span class=\"line\">         &#125;, j*<span class=\"number\">1000</span> );</span><br><span class=\"line\">     &#125;)( i );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果运用ES6就会更加简单，只要运用<code>let</code>声明的块作用域：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">     setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( i );</span><br><span class=\"line\">     &#125;, i*<span class=\"number\">1000</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><p>模块也是利用闭包来实现的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">CoolModule</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> something = <span class=\"string\">\"cool\"</span>;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> another = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( something );</span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doAnother</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( another.join( <span class=\"string\">\" ! \"</span> ) );</span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">         doSomething: doSomething,</span><br><span class=\"line\">         doAnother: doAnother</span><br><span class=\"line\">     &#125;; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = CoolModule();</span><br><span class=\"line\">foo.doSomething(); <span class=\"comment\">// cool</span></span><br><span class=\"line\">foo.doAnother(); <span class=\"comment\">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>\n<p>这样的模式就是最常见的模块的实现方法。返回值是一个包含内部的函数的对象。因为<code>CoolModule()</code>是一个函数，必须调用这个外部的函数后才能创建一个包含内部作用域的闭包。并且返回对象含有的是内部函数而不是内部变量的引用，内部变量是隐藏且私有的状态。</p>\n<p>\u0010模块也是函数，也可以接受参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">CoolModule</span>(<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identify</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log( id );</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">         identify: identify</span><br><span class=\"line\">     &#125;; </span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> foo1 = CoolModule( <span class=\"string\">\"foo 1\"</span> );</span><br><span class=\"line\"> <span class=\"keyword\">var</span> foo2 = CoolModule( <span class=\"string\">\"foo 2\"</span> );</span><br><span class=\"line\"> foo1.identify(); <span class=\"comment\">// \"foo 1\"</span></span><br><span class=\"line\"> foo2.identify(); <span class=\"comment\">// \"foo 2\"</span></span><br></pre></td></tr></table></figure>\n<p>ES6为模块添加了语法的支持，ES6可以把文件当做模块来加载，但是要注意ES6的模块没有行内格式，就是每个模块必须在一个单独的文件中。</p>\n<p><code>bar.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\">who</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Let me introduce: \"</span> + who;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> hello;</span><br></pre></td></tr></table></figure>\n<p><code>foo.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//仅从bar模块导入hello()</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> hello <span class=\"keyword\">from</span> <span class=\"string\">\"bar\"</span>; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> hungry = <span class=\"string\">\"hippo\"</span>;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">awesome</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">         hello( hungry ).toUpperCase()</span><br><span class=\"line\">     );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">export</span> awesome;</span><br></pre></td></tr></table></figure>\n<p><code>baz.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//导入完整的foo和bar模块</span></span><br><span class=\"line\"><span class=\"built_in\">module</span> foo <span class=\"keyword\">from</span> <span class=\"string\">\"foo\"</span>; </span><br><span class=\"line\"><span class=\"built_in\">module</span> bar <span class=\"keyword\">from</span> <span class=\"string\">\"bar\"</span>; </span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">     bar.hello( <span class=\"string\">\"rhino\"</span> )</span><br><span class=\"line\"> ); <span class=\"comment\">// Let me introduce: rhino</span></span><br><span class=\"line\"> foo.awesome(); <span class=\"comment\">// LET ME INTRODUCE: HIPPO</span></span><br></pre></td></tr></table></figure>\n<p><code>import</code>可以将一个模块中的一个或多个API引入到当前作用域，并分别绑定在一个变量上。<code>module</code>会将整个模块的API引入并绑定到一个变量上。<code>export</code>会将当前模块的变量或函数导出为公共的API。</p>\n"},{"layout":"post","title":"内网穿透—外网可以访问到本地页面","date":"2016-03-28T16:00:00.000Z","_content":"\n今天在解决跨域问的时候，误打误撞解决了一个原来困扰我的问题。\n\n很多时候会有这样的问题，想要把本地的页面发送给别人看，不可能一个demo页面都去部署到线上去，那该怎么办？\n\n如果是内网问题还好解决，如果用的是webstorm的话，webstorm本身就可以自己在本地起一个服务。在webstorm的偏好设置里面，有一个`debugger`选项，只要把`Built-in server`这个选项勾选，webstorm会自己启动一个服务，只要把网址的`localhost`改成自己机器的ip地址，只要机器是在同一个网内，就可以访问到本地的页面了。\n\n还有一种方式是，利用node在本地起一个服务，方法是安装一个npm包`http-server`，运行`npm install http-server -g`，安装完成之后直接输入命令`$ http-server`，他就会在本地的8080端口去起一个服务，本地所有的文件就都可以访问到了，只要在起的服务的地址后面再加上文件的路径就可以了。\n\n如果是外网呢？我在知乎上看到了一个答案，([这里](https://www.zhihu.com/question/25456655))。\n\n具体做法是这样的，我们需要一个工具`ngrok`，但是好像这个已经被墙了，国内有很多替代的工具，可以自行搜索一下，这里我找到两个：\n\n1. [natapp.cn](http://natapp.cn/)\n2. [Sunny-Ngrok](http://www.ngrok.cc/)\n\n具体的使用方法也很简单，以natapp来举例。只要下载相应操作系统的客户端，然后把它解压，cd进入到解压后的目录中，运行命令`./ngrok -config ngrok.cfg -subdomain myapp 80`。\n\n**这里需要注意`myapp`这个是你要自己定义的域名，80是你要映射到本地的端口，然后访问`http://myapp.ngrok.natapp.cn`就可以和本地联通了。**\n\n现在其实只要配合node在本地起的服务就可以完成外网访问本地页面了，使用`http-server`起一个本地的服务是8080端口，所以我只需要把`ngrok`映射到8080端口就可以了，即运行指令`./ngrok -config ngrok.cfg -subdomain myapp 8080`，这样再访问自定义的域名之后，就可以顺利访问到本地了。\n\n最后，很多选项都可以在`ngrok.cfg`这个文件里修改，并且`ngrok`的用途不仅仅简单地是这一个，他还有很多用途，有兴趣的具体可以去网上了解一下，因为我对`ngrok`的了解也不是很多。\n\n在解决这个问题之后，我本地的页面已经可以跑在微信里了，再配合我原来记录的[手机调试本地页面的跨域问题](http://www.yatessss.com/2016/01/26/Charles%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/)，就可以解决接口跨域的问题了，不过这个解决办法挺笨的，更好的解决办法我还在找，但是还没有找到。\n\n最好还是和后台沟通可以把测试服务器的接口改成所有域名都能够访问，这样还是最方便的。\n\n以上。","source":"_posts/2016-03-29-内网穿透—外网可以访问到本地页面.md","raw":"---\nlayout: post\ntitle: 内网穿透—外网可以访问到本地页面\ndate: 2016-03-29\ntags: ['ngrok','内网穿透']\ncategories: 工作总结\t\n---\n\n今天在解决跨域问的时候，误打误撞解决了一个原来困扰我的问题。\n\n很多时候会有这样的问题，想要把本地的页面发送给别人看，不可能一个demo页面都去部署到线上去，那该怎么办？\n\n如果是内网问题还好解决，如果用的是webstorm的话，webstorm本身就可以自己在本地起一个服务。在webstorm的偏好设置里面，有一个`debugger`选项，只要把`Built-in server`这个选项勾选，webstorm会自己启动一个服务，只要把网址的`localhost`改成自己机器的ip地址，只要机器是在同一个网内，就可以访问到本地的页面了。\n\n还有一种方式是，利用node在本地起一个服务，方法是安装一个npm包`http-server`，运行`npm install http-server -g`，安装完成之后直接输入命令`$ http-server`，他就会在本地的8080端口去起一个服务，本地所有的文件就都可以访问到了，只要在起的服务的地址后面再加上文件的路径就可以了。\n\n如果是外网呢？我在知乎上看到了一个答案，([这里](https://www.zhihu.com/question/25456655))。\n\n具体做法是这样的，我们需要一个工具`ngrok`，但是好像这个已经被墙了，国内有很多替代的工具，可以自行搜索一下，这里我找到两个：\n\n1. [natapp.cn](http://natapp.cn/)\n2. [Sunny-Ngrok](http://www.ngrok.cc/)\n\n具体的使用方法也很简单，以natapp来举例。只要下载相应操作系统的客户端，然后把它解压，cd进入到解压后的目录中，运行命令`./ngrok -config ngrok.cfg -subdomain myapp 80`。\n\n**这里需要注意`myapp`这个是你要自己定义的域名，80是你要映射到本地的端口，然后访问`http://myapp.ngrok.natapp.cn`就可以和本地联通了。**\n\n现在其实只要配合node在本地起的服务就可以完成外网访问本地页面了，使用`http-server`起一个本地的服务是8080端口，所以我只需要把`ngrok`映射到8080端口就可以了，即运行指令`./ngrok -config ngrok.cfg -subdomain myapp 8080`，这样再访问自定义的域名之后，就可以顺利访问到本地了。\n\n最后，很多选项都可以在`ngrok.cfg`这个文件里修改，并且`ngrok`的用途不仅仅简单地是这一个，他还有很多用途，有兴趣的具体可以去网上了解一下，因为我对`ngrok`的了解也不是很多。\n\n在解决这个问题之后，我本地的页面已经可以跑在微信里了，再配合我原来记录的[手机调试本地页面的跨域问题](http://www.yatessss.com/2016/01/26/Charles%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/)，就可以解决接口跨域的问题了，不过这个解决办法挺笨的，更好的解决办法我还在找，但是还没有找到。\n\n最好还是和后台沟通可以把测试服务器的接口改成所有域名都能够访问，这样还是最方便的。\n\n以上。","slug":"内网穿透—外网可以访问到本地页面","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1z9001rsq5l2h0cr1x4","content":"<p>今天在解决跨域问的时候，误打误撞解决了一个原来困扰我的问题。</p>\n<p>很多时候会有这样的问题，想要把本地的页面发送给别人看，不可能一个demo页面都去部署到线上去，那该怎么办？</p>\n<p>如果是内网问题还好解决，如果用的是webstorm的话，webstorm本身就可以自己在本地起一个服务。在webstorm的偏好设置里面，有一个<code>debugger</code>选项，只要把<code>Built-in server</code>这个选项勾选，webstorm会自己启动一个服务，只要把网址的<code>localhost</code>改成自己机器的ip地址，只要机器是在同一个网内，就可以访问到本地的页面了。</p>\n<p>还有一种方式是，利用node在本地起一个服务，方法是安装一个npm包<code>http-server</code>，运行<code>npm install http-server -g</code>，安装完成之后直接输入命令<code>$ http-server</code>，他就会在本地的8080端口去起一个服务，本地所有的文件就都可以访问到了，只要在起的服务的地址后面再加上文件的路径就可以了。</p>\n<p>如果是外网呢？我在知乎上看到了一个答案，(<a href=\"https://www.zhihu.com/question/25456655\" target=\"_blank\" rel=\"external\">这里</a>)。</p>\n<p>具体做法是这样的，我们需要一个工具<code>ngrok</code>，但是好像这个已经被墙了，国内有很多替代的工具，可以自行搜索一下，这里我找到两个：</p>\n<ol>\n<li><a href=\"http://natapp.cn/\" target=\"_blank\" rel=\"external\">natapp.cn</a></li>\n<li><a href=\"http://www.ngrok.cc/\" target=\"_blank\" rel=\"external\">Sunny-Ngrok</a></li>\n</ol>\n<p>具体的使用方法也很简单，以natapp来举例。只要下载相应操作系统的客户端，然后把它解压，cd进入到解压后的目录中，运行命令<code>./ngrok -config ngrok.cfg -subdomain myapp 80</code>。</p>\n<p><strong>这里需要注意<code>myapp</code>这个是你要自己定义的域名，80是你要映射到本地的端口，然后访问<code>http://myapp.ngrok.natapp.cn</code>就可以和本地联通了。</strong></p>\n<p>现在其实只要配合node在本地起的服务就可以完成外网访问本地页面了，使用<code>http-server</code>起一个本地的服务是8080端口，所以我只需要把<code>ngrok</code>映射到8080端口就可以了，即运行指令<code>./ngrok -config ngrok.cfg -subdomain myapp 8080</code>，这样再访问自定义的域名之后，就可以顺利访问到本地了。</p>\n<p>最后，很多选项都可以在<code>ngrok.cfg</code>这个文件里修改，并且<code>ngrok</code>的用途不仅仅简单地是这一个，他还有很多用途，有兴趣的具体可以去网上了解一下，因为我对<code>ngrok</code>的了解也不是很多。</p>\n<p>在解决这个问题之后，我本地的页面已经可以跑在微信里了，再配合我原来记录的<a href=\"http://www.yatessss.com/2016/01/26/Charles%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/\">手机调试本地页面的跨域问题</a>，就可以解决接口跨域的问题了，不过这个解决办法挺笨的，更好的解决办法我还在找，但是还没有找到。</p>\n<p>最好还是和后台沟通可以把测试服务器的接口改成所有域名都能够访问，这样还是最方便的。</p>\n<p>以上。</p>\n","excerpt":"","more":"<p>今天在解决跨域问的时候，误打误撞解决了一个原来困扰我的问题。</p>\n<p>很多时候会有这样的问题，想要把本地的页面发送给别人看，不可能一个demo页面都去部署到线上去，那该怎么办？</p>\n<p>如果是内网问题还好解决，如果用的是webstorm的话，webstorm本身就可以自己在本地起一个服务。在webstorm的偏好设置里面，有一个<code>debugger</code>选项，只要把<code>Built-in server</code>这个选项勾选，webstorm会自己启动一个服务，只要把网址的<code>localhost</code>改成自己机器的ip地址，只要机器是在同一个网内，就可以访问到本地的页面了。</p>\n<p>还有一种方式是，利用node在本地起一个服务，方法是安装一个npm包<code>http-server</code>，运行<code>npm install http-server -g</code>，安装完成之后直接输入命令<code>$ http-server</code>，他就会在本地的8080端口去起一个服务，本地所有的文件就都可以访问到了，只要在起的服务的地址后面再加上文件的路径就可以了。</p>\n<p>如果是外网呢？我在知乎上看到了一个答案，(<a href=\"https://www.zhihu.com/question/25456655\">这里</a>)。</p>\n<p>具体做法是这样的，我们需要一个工具<code>ngrok</code>，但是好像这个已经被墙了，国内有很多替代的工具，可以自行搜索一下，这里我找到两个：</p>\n<ol>\n<li><a href=\"http://natapp.cn/\">natapp.cn</a></li>\n<li><a href=\"http://www.ngrok.cc/\">Sunny-Ngrok</a></li>\n</ol>\n<p>具体的使用方法也很简单，以natapp来举例。只要下载相应操作系统的客户端，然后把它解压，cd进入到解压后的目录中，运行命令<code>./ngrok -config ngrok.cfg -subdomain myapp 80</code>。</p>\n<p><strong>这里需要注意<code>myapp</code>这个是你要自己定义的域名，80是你要映射到本地的端口，然后访问<code>http://myapp.ngrok.natapp.cn</code>就可以和本地联通了。</strong></p>\n<p>现在其实只要配合node在本地起的服务就可以完成外网访问本地页面了，使用<code>http-server</code>起一个本地的服务是8080端口，所以我只需要把<code>ngrok</code>映射到8080端口就可以了，即运行指令<code>./ngrok -config ngrok.cfg -subdomain myapp 8080</code>，这样再访问自定义的域名之后，就可以顺利访问到本地了。</p>\n<p>最后，很多选项都可以在<code>ngrok.cfg</code>这个文件里修改，并且<code>ngrok</code>的用途不仅仅简单地是这一个，他还有很多用途，有兴趣的具体可以去网上了解一下，因为我对<code>ngrok</code>的了解也不是很多。</p>\n<p>在解决这个问题之后，我本地的页面已经可以跑在微信里了，再配合我原来记录的<a href=\"http://www.yatessss.com/2016/01/26/Charles%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/\">手机调试本地页面的跨域问题</a>，就可以解决接口跨域的问题了，不过这个解决办法挺笨的，更好的解决办法我还在找，但是还没有找到。</p>\n<p>最好还是和后台沟通可以把测试服务器的接口改成所有域名都能够访问，这样还是最方便的。</p>\n<p>以上。</p>\n"},{"layout":"post","title":"微信JSSDK坑啊坑","date":"2016-03-29T16:00:00.000Z","_content":"\n### update：\n\n今天又提了一个bug：就是这个页面分享之后，点击分享的链接不能获取到地理位置。\n\n于是我首先看了一下，这个问题是不是可以复现，在我的手机上也确实是复现了，那说明这确实是一个bug。\n\n然后我把分享后的这个地址复制了出来，在微信web开发者工具中打开查看，发现是JSSDK注册失败，报错：`config:invalid signature`，所以手机不能调微信获取地理位置的接口。\n\n查看了一下，是微信分享后会在本来的url后面带两个参数`?from=groupmessage&isappinstalled=0`。\n\n注册微信JSSDK是这样一个流程，前端首先先去访问公司的一个后台接口带一个?url=''的参数，后台会根据我的参数去访问微信提供的接口，拿到timestamp，nonceStr，signature等参数并发送给前端，前端再去注册。\n\n所以我认为可能是因为我请求后台接口时的url直接是取得是`location.href`，带了微信分享后的那两个参数，所以后台处理的时候出现了错误，造成注册JSSDK时的签名无效。所以我把`location.href`改成了`location.origin + location.pathname`这样就把`？号`后的参数都去掉了，我想这样应该就保持了分享前后url的一致性，不会影响JSSDK的注册吧。结果其实没有效果。\n\n然后，又想我保持了url参数的一致性都没有作用，那是不是后台在处理的时候并不是取的我后面的这个参数，而是从请求头中拿了`referer`这个属性呢？\n\n**注：`referer`是请求头当中的一个字段，它可以告诉服务器我是从哪个url过来的。这个字段一般是用来防止盗链外链用的。有兴趣的同学可以搜索一下，我也是搜索得来的。**\n\n但是后台同学说他拿的就是我url后面的参数。\n\n那问题到底在哪里呢？其实很蠢因为我url没有进行encodeURI编码，所以造成了错误，所以以后一定要记得向后台传递url的时候**一定要进行encodeURI编码！！！一定要进行encodeURI编码！！！一定要进行encodeURI编码！！！**\n\n虽说绕了一些弯路，但是也了解了一些原来没涉及到的知识，比如`location`中的一些方法（改天单独学习总结下），请求头当中的一些字段（也要系统的学习一下）。\n\n------\n\n最近一段时间的工作不是很忙，给一个微信的项目加一些需求，主要就是通过微信JSSDK的获取地理位置的接口，拿到经纬度，完成一些功能。\n\n主要遇到了三个以后需要注意的地方吧，这里先描述一下：\n\n1. 微信中AppId的作用。\n2. 微信禁止不安全的https链接。\n3. 跨域携带cookie\n\n### 微信中AppId的作用\n\n大家知道，开发手机页面的时候，调试时意见很麻烦的事情。因为在移动端你并不能想浏览器一样打开开发者工具，当报一些错误的时候，手机是无法查看的，所以一般我们就是在chrome的开发者工具中来模拟手机，比如屏幕大小、触摸事件等等。如果是一般的移动端页面，这样调试是可以的，但是如果JS中回去调`open.weixin.qq`授权登录的接口的话，在浏览器模拟的时候，就会显示`请在微信中打开`类似的字样。\n\n所以我们如果是开发微信中页面的时候，一般会有两种办法：\n\n1. 先把`open.weixin.qq`授权登录的接口去掉，这样可以跳过微信验证的步骤，现在本地来开发页面。\n2. 通过使用微信官方的**微信web开发者工具**来开发页面。\n\n其实两种方法是配合来使用的，在页面功能还没有做完的时候，我们可以在本地的浏览器中先开发功能，因为浏览器中有一些插件可以来跨域，携带cookie等等方便开发，但是在浏览器中并不能调用JSSDK的方法。功能开发完毕要跑通整个流程的时候，就可以在web开发者工具中调试，因为web开发者工具中可以调用微信的JSSDK的方法和授权登录等等，但是在web开发者工具中只能运行公众号后台绑定的安全域名下的页面，所以需要我们上到测试环境下去跑。\n\n而我遇到的第一个问题就是：在公众号后台已经添加了我为开发者，但是我在web开发者工具中还是无法打开后台绑定的安全域名下的页面。起初我还以为是不是公众号没有绑定这个域名呢？导致我无法打开页面，后来到公众号后台查看并不是这样，经过排查是因为，后台接口用的appid和公众号的appid不匹配造成的。那appid的作用是什么呢？\n\nappid其实就是起到一个标识的作用，有了appid微信就会知道你是哪一个公众账号，知道了是哪一个公众号，他就会在后台查看你这个公众号下有哪些安全域名，公众号开通了哪些功能，有哪些权限以及一系列的信息。\n\n比如：如果你打开的网址和你发出的appid对应的公众号绑定的安全域名不匹配时，微信会禁止你去打开这个链接；如果你要调试页面，微信会到后台去找你所用的微信号是不是在appid对应的公众号下的开发者名单中有没有你，如果没有微信也会禁止你去调试这个页面；公众号后台也会有很多功能，微信通过appid也能来查询你有没有开通这个功能。\n\n所以，因为后台接口用的是另一个appid，微信认为开打的是另一个公众号的页面，而这个公众号的开发者名单中并没有我，所以我没有办法去调试。\n\n*****\n\n### 微信禁止不安全的https链接\n\n经过第一个问题之后，我可以在web开发者工具中调试我的页面了，我又遇到了另一个奇怪的问题：我在开发者工具中整个页面功能没有问题，但是在微信当中打开，就会出现错误。当时，特别困惑因为在开发者工具中并没有报任何错误，而在微信中你无法看到错误信息，所以到底是哪个位置出现了错误你也不清楚。\n\n经过了上网查询，自己排查，知道了原因是这样的。\n\n因为后台接口走的是https，后台的https证书只对应线上的那个域名，而在测试环境中因为接口域名和证书并不对应，所以微信认为这个链接是不安全的，而微信会禁止不安全的https链接。而在web开发者工具中是可以访问这样不安全的https的连接的，所以就会出现上述的问题。\n\n所以，在今后遇到这样web开发者工具和微信行为不一致的时候，我们可以先查看一下是不是我们有https的接口是不安全的。\n\n*****\n\n### withCredentials跨域请求\n\n我们首先应该知道这个知识：默认情况下，ajxa跨域请求是不会发送用户认证凭据的（cookie、HTTP认证及客户端SSL证明等）。\n\n有什么方法可以解决这个问题呢？可以通过设置ajax的`withCredentials`属性为`true`来指定某个请求是可以发送用户认证凭据。不过要注意：支持withCredentials属性的浏览器有Firefox 3.5+、Safari 4+和Chrome。IE10及更早版本都不支持。\n\n如果设置这个属性的话，请求头中就会带上cookie，而后台要接受这个凭据的话，在服务端的响应头必须添加`Access-Control-Allow-Credentials: true`，并且**服务端需指定一个域名（Access-Control-Allow-Origin:www.xxxxxx.com），而不能使用泛型（Access-Control-Allow-Origin: * ）**这样我们就可以跨域发送cookie了。\n\n如果是原生的话大概是这样：\n\n```js\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', 'http://www.xxx.com/api');\nxhr.withCredentials = true;\nxhr.onload = onLoadHandler;\nxhr.send();\n```\n\n如果使用类库的话（如zepto）：\n\n```js\n$.ajax({\n \turl: url,\n \ttype: 'get',\n \tdata:  data,\n \tdataType: 'json',\n \txhrFields: {\n   \t\twithCredentials: true\n \t},\n```\n\n`zepto`的`ajax`中有这样一个参数：`xhrFields` (默认： none): 一个对象包含的属性被逐字复制到XMLHttpRequest的实例。\n\n大概就是这么多吧，如果想起来在添加。\n\n最后在吐槽一下吧，生活不如意之事十之八九\n\n总感觉生活总在你比较满意的时候给你一记当头棒喝，本来最近还活的好好的，经过几个月的努力学习算是顺利的转行，也在一直学习成长，对自己最近的表现也比较满意。而上帝可能觉得你近一阶段有些骄傲和浮躁了，需要给你提醒一下，所以最近遇到了一个小挫折，也让自己知道了一些不足，就像盖楼，基础往往决定你能不能盖一座高楼，而技术决定你能盖多高，基础确实是一个必要条件，而我现在就处在半瓶水响叮当的阶段，对一些基础只是知其然不知其所以然，往往会用、知道，但是没有深究原理。这就对出现的一些问题在解决起来，可能会毫无头绪，依靠网络未尝不是一个办法，但往往不是最好的办法，如果了解原理你可能对出现问题的原因追根溯源，但是你如果只找到这个问题的解决办法，下次出现因为这个原理出现的其他问题你依然会没有头绪。\n\n再有，听清问题，想好之后再去回答，说的每句话应该是绝对经过思考的  尤其在不熟悉的人之间。\n\n小品里说过嘛，车轱辘往前转，人要往前看，夯实基础，拥抱新技术，是我未来一年的目标，不卑不亢，不喜不悲，希望下次再战。\n\n以上。","source":"_posts/2016-03-30-微信JSSDK坑啊坑.md","raw":"---\nlayout: post\ntitle: 微信JSSDK坑啊坑\ndate: 2016-03-30\ntags: ['微信JSSDK','跨域','appid','referer']\ncategories: 工作总结\t\n---\n\n### update：\n\n今天又提了一个bug：就是这个页面分享之后，点击分享的链接不能获取到地理位置。\n\n于是我首先看了一下，这个问题是不是可以复现，在我的手机上也确实是复现了，那说明这确实是一个bug。\n\n然后我把分享后的这个地址复制了出来，在微信web开发者工具中打开查看，发现是JSSDK注册失败，报错：`config:invalid signature`，所以手机不能调微信获取地理位置的接口。\n\n查看了一下，是微信分享后会在本来的url后面带两个参数`?from=groupmessage&isappinstalled=0`。\n\n注册微信JSSDK是这样一个流程，前端首先先去访问公司的一个后台接口带一个?url=''的参数，后台会根据我的参数去访问微信提供的接口，拿到timestamp，nonceStr，signature等参数并发送给前端，前端再去注册。\n\n所以我认为可能是因为我请求后台接口时的url直接是取得是`location.href`，带了微信分享后的那两个参数，所以后台处理的时候出现了错误，造成注册JSSDK时的签名无效。所以我把`location.href`改成了`location.origin + location.pathname`这样就把`？号`后的参数都去掉了，我想这样应该就保持了分享前后url的一致性，不会影响JSSDK的注册吧。结果其实没有效果。\n\n然后，又想我保持了url参数的一致性都没有作用，那是不是后台在处理的时候并不是取的我后面的这个参数，而是从请求头中拿了`referer`这个属性呢？\n\n**注：`referer`是请求头当中的一个字段，它可以告诉服务器我是从哪个url过来的。这个字段一般是用来防止盗链外链用的。有兴趣的同学可以搜索一下，我也是搜索得来的。**\n\n但是后台同学说他拿的就是我url后面的参数。\n\n那问题到底在哪里呢？其实很蠢因为我url没有进行encodeURI编码，所以造成了错误，所以以后一定要记得向后台传递url的时候**一定要进行encodeURI编码！！！一定要进行encodeURI编码！！！一定要进行encodeURI编码！！！**\n\n虽说绕了一些弯路，但是也了解了一些原来没涉及到的知识，比如`location`中的一些方法（改天单独学习总结下），请求头当中的一些字段（也要系统的学习一下）。\n\n------\n\n最近一段时间的工作不是很忙，给一个微信的项目加一些需求，主要就是通过微信JSSDK的获取地理位置的接口，拿到经纬度，完成一些功能。\n\n主要遇到了三个以后需要注意的地方吧，这里先描述一下：\n\n1. 微信中AppId的作用。\n2. 微信禁止不安全的https链接。\n3. 跨域携带cookie\n\n### 微信中AppId的作用\n\n大家知道，开发手机页面的时候，调试时意见很麻烦的事情。因为在移动端你并不能想浏览器一样打开开发者工具，当报一些错误的时候，手机是无法查看的，所以一般我们就是在chrome的开发者工具中来模拟手机，比如屏幕大小、触摸事件等等。如果是一般的移动端页面，这样调试是可以的，但是如果JS中回去调`open.weixin.qq`授权登录的接口的话，在浏览器模拟的时候，就会显示`请在微信中打开`类似的字样。\n\n所以我们如果是开发微信中页面的时候，一般会有两种办法：\n\n1. 先把`open.weixin.qq`授权登录的接口去掉，这样可以跳过微信验证的步骤，现在本地来开发页面。\n2. 通过使用微信官方的**微信web开发者工具**来开发页面。\n\n其实两种方法是配合来使用的，在页面功能还没有做完的时候，我们可以在本地的浏览器中先开发功能，因为浏览器中有一些插件可以来跨域，携带cookie等等方便开发，但是在浏览器中并不能调用JSSDK的方法。功能开发完毕要跑通整个流程的时候，就可以在web开发者工具中调试，因为web开发者工具中可以调用微信的JSSDK的方法和授权登录等等，但是在web开发者工具中只能运行公众号后台绑定的安全域名下的页面，所以需要我们上到测试环境下去跑。\n\n而我遇到的第一个问题就是：在公众号后台已经添加了我为开发者，但是我在web开发者工具中还是无法打开后台绑定的安全域名下的页面。起初我还以为是不是公众号没有绑定这个域名呢？导致我无法打开页面，后来到公众号后台查看并不是这样，经过排查是因为，后台接口用的appid和公众号的appid不匹配造成的。那appid的作用是什么呢？\n\nappid其实就是起到一个标识的作用，有了appid微信就会知道你是哪一个公众账号，知道了是哪一个公众号，他就会在后台查看你这个公众号下有哪些安全域名，公众号开通了哪些功能，有哪些权限以及一系列的信息。\n\n比如：如果你打开的网址和你发出的appid对应的公众号绑定的安全域名不匹配时，微信会禁止你去打开这个链接；如果你要调试页面，微信会到后台去找你所用的微信号是不是在appid对应的公众号下的开发者名单中有没有你，如果没有微信也会禁止你去调试这个页面；公众号后台也会有很多功能，微信通过appid也能来查询你有没有开通这个功能。\n\n所以，因为后台接口用的是另一个appid，微信认为开打的是另一个公众号的页面，而这个公众号的开发者名单中并没有我，所以我没有办法去调试。\n\n*****\n\n### 微信禁止不安全的https链接\n\n经过第一个问题之后，我可以在web开发者工具中调试我的页面了，我又遇到了另一个奇怪的问题：我在开发者工具中整个页面功能没有问题，但是在微信当中打开，就会出现错误。当时，特别困惑因为在开发者工具中并没有报任何错误，而在微信中你无法看到错误信息，所以到底是哪个位置出现了错误你也不清楚。\n\n经过了上网查询，自己排查，知道了原因是这样的。\n\n因为后台接口走的是https，后台的https证书只对应线上的那个域名，而在测试环境中因为接口域名和证书并不对应，所以微信认为这个链接是不安全的，而微信会禁止不安全的https链接。而在web开发者工具中是可以访问这样不安全的https的连接的，所以就会出现上述的问题。\n\n所以，在今后遇到这样web开发者工具和微信行为不一致的时候，我们可以先查看一下是不是我们有https的接口是不安全的。\n\n*****\n\n### withCredentials跨域请求\n\n我们首先应该知道这个知识：默认情况下，ajxa跨域请求是不会发送用户认证凭据的（cookie、HTTP认证及客户端SSL证明等）。\n\n有什么方法可以解决这个问题呢？可以通过设置ajax的`withCredentials`属性为`true`来指定某个请求是可以发送用户认证凭据。不过要注意：支持withCredentials属性的浏览器有Firefox 3.5+、Safari 4+和Chrome。IE10及更早版本都不支持。\n\n如果设置这个属性的话，请求头中就会带上cookie，而后台要接受这个凭据的话，在服务端的响应头必须添加`Access-Control-Allow-Credentials: true`，并且**服务端需指定一个域名（Access-Control-Allow-Origin:www.xxxxxx.com），而不能使用泛型（Access-Control-Allow-Origin: * ）**这样我们就可以跨域发送cookie了。\n\n如果是原生的话大概是这样：\n\n```js\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', 'http://www.xxx.com/api');\nxhr.withCredentials = true;\nxhr.onload = onLoadHandler;\nxhr.send();\n```\n\n如果使用类库的话（如zepto）：\n\n```js\n$.ajax({\n \turl: url,\n \ttype: 'get',\n \tdata:  data,\n \tdataType: 'json',\n \txhrFields: {\n   \t\twithCredentials: true\n \t},\n```\n\n`zepto`的`ajax`中有这样一个参数：`xhrFields` (默认： none): 一个对象包含的属性被逐字复制到XMLHttpRequest的实例。\n\n大概就是这么多吧，如果想起来在添加。\n\n最后在吐槽一下吧，生活不如意之事十之八九\n\n总感觉生活总在你比较满意的时候给你一记当头棒喝，本来最近还活的好好的，经过几个月的努力学习算是顺利的转行，也在一直学习成长，对自己最近的表现也比较满意。而上帝可能觉得你近一阶段有些骄傲和浮躁了，需要给你提醒一下，所以最近遇到了一个小挫折，也让自己知道了一些不足，就像盖楼，基础往往决定你能不能盖一座高楼，而技术决定你能盖多高，基础确实是一个必要条件，而我现在就处在半瓶水响叮当的阶段，对一些基础只是知其然不知其所以然，往往会用、知道，但是没有深究原理。这就对出现的一些问题在解决起来，可能会毫无头绪，依靠网络未尝不是一个办法，但往往不是最好的办法，如果了解原理你可能对出现问题的原因追根溯源，但是你如果只找到这个问题的解决办法，下次出现因为这个原理出现的其他问题你依然会没有头绪。\n\n再有，听清问题，想好之后再去回答，说的每句话应该是绝对经过思考的  尤其在不熟悉的人之间。\n\n小品里说过嘛，车轱辘往前转，人要往前看，夯实基础，拥抱新技术，是我未来一年的目标，不卑不亢，不喜不悲，希望下次再战。\n\n以上。","slug":"微信JSSDK坑啊坑","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1zb001tsq5lxy3hjpwb","content":"<h3 id=\"update：\"><a href=\"#update：\" class=\"headerlink\" title=\"update：\"></a>update：</h3><p>今天又提了一个bug：就是这个页面分享之后，点击分享的链接不能获取到地理位置。</p>\n<p>于是我首先看了一下，这个问题是不是可以复现，在我的手机上也确实是复现了，那说明这确实是一个bug。</p>\n<p>然后我把分享后的这个地址复制了出来，在微信web开发者工具中打开查看，发现是JSSDK注册失败，报错：<code>config:invalid signature</code>，所以手机不能调微信获取地理位置的接口。</p>\n<p>查看了一下，是微信分享后会在本来的url后面带两个参数<code>?from=groupmessage&amp;isappinstalled=0</code>。</p>\n<p>注册微信JSSDK是这样一个流程，前端首先先去访问公司的一个后台接口带一个?url=’’的参数，后台会根据我的参数去访问微信提供的接口，拿到timestamp，nonceStr，signature等参数并发送给前端，前端再去注册。</p>\n<p>所以我认为可能是因为我请求后台接口时的url直接是取得是<code>location.href</code>，带了微信分享后的那两个参数，所以后台处理的时候出现了错误，造成注册JSSDK时的签名无效。所以我把<code>location.href</code>改成了<code>location.origin + location.pathname</code>这样就把<code>？号</code>后的参数都去掉了，我想这样应该就保持了分享前后url的一致性，不会影响JSSDK的注册吧。结果其实没有效果。</p>\n<p>然后，又想我保持了url参数的一致性都没有作用，那是不是后台在处理的时候并不是取的我后面的这个参数，而是从请求头中拿了<code>referer</code>这个属性呢？</p>\n<p><strong>注：<code>referer</code>是请求头当中的一个字段，它可以告诉服务器我是从哪个url过来的。这个字段一般是用来防止盗链外链用的。有兴趣的同学可以搜索一下，我也是搜索得来的。</strong></p>\n<p>但是后台同学说他拿的就是我url后面的参数。</p>\n<p>那问题到底在哪里呢？其实很蠢因为我url没有进行encodeURI编码，所以造成了错误，所以以后一定要记得向后台传递url的时候<strong>一定要进行encodeURI编码！！！一定要进行encodeURI编码！！！一定要进行encodeURI编码！！！</strong></p>\n<p>虽说绕了一些弯路，但是也了解了一些原来没涉及到的知识，比如<code>location</code>中的一些方法（改天单独学习总结下），请求头当中的一些字段（也要系统的学习一下）。</p>\n<hr>\n<p>最近一段时间的工作不是很忙，给一个微信的项目加一些需求，主要就是通过微信JSSDK的获取地理位置的接口，拿到经纬度，完成一些功能。</p>\n<p>主要遇到了三个以后需要注意的地方吧，这里先描述一下：</p>\n<ol>\n<li>微信中AppId的作用。</li>\n<li>微信禁止不安全的https链接。</li>\n<li>跨域携带cookie</li>\n</ol>\n<h3 id=\"微信中AppId的作用\"><a href=\"#微信中AppId的作用\" class=\"headerlink\" title=\"微信中AppId的作用\"></a>微信中AppId的作用</h3><p>大家知道，开发手机页面的时候，调试时意见很麻烦的事情。因为在移动端你并不能想浏览器一样打开开发者工具，当报一些错误的时候，手机是无法查看的，所以一般我们就是在chrome的开发者工具中来模拟手机，比如屏幕大小、触摸事件等等。如果是一般的移动端页面，这样调试是可以的，但是如果JS中回去调<code>open.weixin.qq</code>授权登录的接口的话，在浏览器模拟的时候，就会显示<code>请在微信中打开</code>类似的字样。</p>\n<p>所以我们如果是开发微信中页面的时候，一般会有两种办法：</p>\n<ol>\n<li>先把<code>open.weixin.qq</code>授权登录的接口去掉，这样可以跳过微信验证的步骤，现在本地来开发页面。</li>\n<li>通过使用微信官方的<strong>微信web开发者工具</strong>来开发页面。</li>\n</ol>\n<p>其实两种方法是配合来使用的，在页面功能还没有做完的时候，我们可以在本地的浏览器中先开发功能，因为浏览器中有一些插件可以来跨域，携带cookie等等方便开发，但是在浏览器中并不能调用JSSDK的方法。功能开发完毕要跑通整个流程的时候，就可以在web开发者工具中调试，因为web开发者工具中可以调用微信的JSSDK的方法和授权登录等等，但是在web开发者工具中只能运行公众号后台绑定的安全域名下的页面，所以需要我们上到测试环境下去跑。</p>\n<p>而我遇到的第一个问题就是：在公众号后台已经添加了我为开发者，但是我在web开发者工具中还是无法打开后台绑定的安全域名下的页面。起初我还以为是不是公众号没有绑定这个域名呢？导致我无法打开页面，后来到公众号后台查看并不是这样，经过排查是因为，后台接口用的appid和公众号的appid不匹配造成的。那appid的作用是什么呢？</p>\n<p>appid其实就是起到一个标识的作用，有了appid微信就会知道你是哪一个公众账号，知道了是哪一个公众号，他就会在后台查看你这个公众号下有哪些安全域名，公众号开通了哪些功能，有哪些权限以及一系列的信息。</p>\n<p>比如：如果你打开的网址和你发出的appid对应的公众号绑定的安全域名不匹配时，微信会禁止你去打开这个链接；如果你要调试页面，微信会到后台去找你所用的微信号是不是在appid对应的公众号下的开发者名单中有没有你，如果没有微信也会禁止你去调试这个页面；公众号后台也会有很多功能，微信通过appid也能来查询你有没有开通这个功能。</p>\n<p>所以，因为后台接口用的是另一个appid，微信认为开打的是另一个公众号的页面，而这个公众号的开发者名单中并没有我，所以我没有办法去调试。</p>\n<hr>\n<h3 id=\"微信禁止不安全的https链接\"><a href=\"#微信禁止不安全的https链接\" class=\"headerlink\" title=\"微信禁止不安全的https链接\"></a>微信禁止不安全的https链接</h3><p>经过第一个问题之后，我可以在web开发者工具中调试我的页面了，我又遇到了另一个奇怪的问题：我在开发者工具中整个页面功能没有问题，但是在微信当中打开，就会出现错误。当时，特别困惑因为在开发者工具中并没有报任何错误，而在微信中你无法看到错误信息，所以到底是哪个位置出现了错误你也不清楚。</p>\n<p>经过了上网查询，自己排查，知道了原因是这样的。</p>\n<p>因为后台接口走的是https，后台的https证书只对应线上的那个域名，而在测试环境中因为接口域名和证书并不对应，所以微信认为这个链接是不安全的，而微信会禁止不安全的https链接。而在web开发者工具中是可以访问这样不安全的https的连接的，所以就会出现上述的问题。</p>\n<p>所以，在今后遇到这样web开发者工具和微信行为不一致的时候，我们可以先查看一下是不是我们有https的接口是不安全的。</p>\n<hr>\n<h3 id=\"withCredentials跨域请求\"><a href=\"#withCredentials跨域请求\" class=\"headerlink\" title=\"withCredentials跨域请求\"></a>withCredentials跨域请求</h3><p>我们首先应该知道这个知识：默认情况下，ajxa跨域请求是不会发送用户认证凭据的（cookie、HTTP认证及客户端SSL证明等）。</p>\n<p>有什么方法可以解决这个问题呢？可以通过设置ajax的<code>withCredentials</code>属性为<code>true</code>来指定某个请求是可以发送用户认证凭据。不过要注意：支持withCredentials属性的浏览器有Firefox 3.5+、Safari 4+和Chrome。IE10及更早版本都不支持。</p>\n<p>如果设置这个属性的话，请求头中就会带上cookie，而后台要接受这个凭据的话，在服务端的响应头必须添加<code>Access-Control-Allow-Credentials: true</code>，并且<strong>服务端需指定一个域名（Access-Control-Allow-Origin:www.xxxxxx.com），而不能使用泛型（Access-Control-Allow-Origin: * ）</strong>这样我们就可以跨域发送cookie了。</p>\n<p>如果是原生的话大概是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">'GET'</span>, <span class=\"string\">'http://www.xxx.com/api'</span>);</span><br><span class=\"line\">xhr.withCredentials = <span class=\"literal\">true</span>;</span><br><span class=\"line\">xhr.onload = onLoadHandler;</span><br><span class=\"line\">xhr.send();</span><br></pre></td></tr></table></figure>\n<p>如果使用类库的话（如zepto）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\"> \turl: url,</span><br><span class=\"line\"> \ttype: <span class=\"string\">'get'</span>,</span><br><span class=\"line\"> \tdata:  data,</span><br><span class=\"line\"> \tdataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\"> \txhrFields: &#123;</span><br><span class=\"line\">   \t\twithCredentials: <span class=\"literal\">true</span></span><br><span class=\"line\"> \t&#125;,</span><br></pre></td></tr></table></figure>\n<p><code>zepto</code>的<code>ajax</code>中有这样一个参数：<code>xhrFields</code> (默认： none): 一个对象包含的属性被逐字复制到XMLHttpRequest的实例。</p>\n<p>大概就是这么多吧，如果想起来在添加。</p>\n<p>最后在吐槽一下吧，生活不如意之事十之八九</p>\n<p>总感觉生活总在你比较满意的时候给你一记当头棒喝，本来最近还活的好好的，经过几个月的努力学习算是顺利的转行，也在一直学习成长，对自己最近的表现也比较满意。而上帝可能觉得你近一阶段有些骄傲和浮躁了，需要给你提醒一下，所以最近遇到了一个小挫折，也让自己知道了一些不足，就像盖楼，基础往往决定你能不能盖一座高楼，而技术决定你能盖多高，基础确实是一个必要条件，而我现在就处在半瓶水响叮当的阶段，对一些基础只是知其然不知其所以然，往往会用、知道，但是没有深究原理。这就对出现的一些问题在解决起来，可能会毫无头绪，依靠网络未尝不是一个办法，但往往不是最好的办法，如果了解原理你可能对出现问题的原因追根溯源，但是你如果只找到这个问题的解决办法，下次出现因为这个原理出现的其他问题你依然会没有头绪。</p>\n<p>再有，听清问题，想好之后再去回答，说的每句话应该是绝对经过思考的  尤其在不熟悉的人之间。</p>\n<p>小品里说过嘛，车轱辘往前转，人要往前看，夯实基础，拥抱新技术，是我未来一年的目标，不卑不亢，不喜不悲，希望下次再战。</p>\n<p>以上。</p>\n","excerpt":"","more":"<h3 id=\"update：\"><a href=\"#update：\" class=\"headerlink\" title=\"update：\"></a>update：</h3><p>今天又提了一个bug：就是这个页面分享之后，点击分享的链接不能获取到地理位置。</p>\n<p>于是我首先看了一下，这个问题是不是可以复现，在我的手机上也确实是复现了，那说明这确实是一个bug。</p>\n<p>然后我把分享后的这个地址复制了出来，在微信web开发者工具中打开查看，发现是JSSDK注册失败，报错：<code>config:invalid signature</code>，所以手机不能调微信获取地理位置的接口。</p>\n<p>查看了一下，是微信分享后会在本来的url后面带两个参数<code>?from=groupmessage&amp;isappinstalled=0</code>。</p>\n<p>注册微信JSSDK是这样一个流程，前端首先先去访问公司的一个后台接口带一个?url=’’的参数，后台会根据我的参数去访问微信提供的接口，拿到timestamp，nonceStr，signature等参数并发送给前端，前端再去注册。</p>\n<p>所以我认为可能是因为我请求后台接口时的url直接是取得是<code>location.href</code>，带了微信分享后的那两个参数，所以后台处理的时候出现了错误，造成注册JSSDK时的签名无效。所以我把<code>location.href</code>改成了<code>location.origin + location.pathname</code>这样就把<code>？号</code>后的参数都去掉了，我想这样应该就保持了分享前后url的一致性，不会影响JSSDK的注册吧。结果其实没有效果。</p>\n<p>然后，又想我保持了url参数的一致性都没有作用，那是不是后台在处理的时候并不是取的我后面的这个参数，而是从请求头中拿了<code>referer</code>这个属性呢？</p>\n<p><strong>注：<code>referer</code>是请求头当中的一个字段，它可以告诉服务器我是从哪个url过来的。这个字段一般是用来防止盗链外链用的。有兴趣的同学可以搜索一下，我也是搜索得来的。</strong></p>\n<p>但是后台同学说他拿的就是我url后面的参数。</p>\n<p>那问题到底在哪里呢？其实很蠢因为我url没有进行encodeURI编码，所以造成了错误，所以以后一定要记得向后台传递url的时候<strong>一定要进行encodeURI编码！！！一定要进行encodeURI编码！！！一定要进行encodeURI编码！！！</strong></p>\n<p>虽说绕了一些弯路，但是也了解了一些原来没涉及到的知识，比如<code>location</code>中的一些方法（改天单独学习总结下），请求头当中的一些字段（也要系统的学习一下）。</p>\n<hr>\n<p>最近一段时间的工作不是很忙，给一个微信的项目加一些需求，主要就是通过微信JSSDK的获取地理位置的接口，拿到经纬度，完成一些功能。</p>\n<p>主要遇到了三个以后需要注意的地方吧，这里先描述一下：</p>\n<ol>\n<li>微信中AppId的作用。</li>\n<li>微信禁止不安全的https链接。</li>\n<li>跨域携带cookie</li>\n</ol>\n<h3 id=\"微信中AppId的作用\"><a href=\"#微信中AppId的作用\" class=\"headerlink\" title=\"微信中AppId的作用\"></a>微信中AppId的作用</h3><p>大家知道，开发手机页面的时候，调试时意见很麻烦的事情。因为在移动端你并不能想浏览器一样打开开发者工具，当报一些错误的时候，手机是无法查看的，所以一般我们就是在chrome的开发者工具中来模拟手机，比如屏幕大小、触摸事件等等。如果是一般的移动端页面，这样调试是可以的，但是如果JS中回去调<code>open.weixin.qq</code>授权登录的接口的话，在浏览器模拟的时候，就会显示<code>请在微信中打开</code>类似的字样。</p>\n<p>所以我们如果是开发微信中页面的时候，一般会有两种办法：</p>\n<ol>\n<li>先把<code>open.weixin.qq</code>授权登录的接口去掉，这样可以跳过微信验证的步骤，现在本地来开发页面。</li>\n<li>通过使用微信官方的<strong>微信web开发者工具</strong>来开发页面。</li>\n</ol>\n<p>其实两种方法是配合来使用的，在页面功能还没有做完的时候，我们可以在本地的浏览器中先开发功能，因为浏览器中有一些插件可以来跨域，携带cookie等等方便开发，但是在浏览器中并不能调用JSSDK的方法。功能开发完毕要跑通整个流程的时候，就可以在web开发者工具中调试，因为web开发者工具中可以调用微信的JSSDK的方法和授权登录等等，但是在web开发者工具中只能运行公众号后台绑定的安全域名下的页面，所以需要我们上到测试环境下去跑。</p>\n<p>而我遇到的第一个问题就是：在公众号后台已经添加了我为开发者，但是我在web开发者工具中还是无法打开后台绑定的安全域名下的页面。起初我还以为是不是公众号没有绑定这个域名呢？导致我无法打开页面，后来到公众号后台查看并不是这样，经过排查是因为，后台接口用的appid和公众号的appid不匹配造成的。那appid的作用是什么呢？</p>\n<p>appid其实就是起到一个标识的作用，有了appid微信就会知道你是哪一个公众账号，知道了是哪一个公众号，他就会在后台查看你这个公众号下有哪些安全域名，公众号开通了哪些功能，有哪些权限以及一系列的信息。</p>\n<p>比如：如果你打开的网址和你发出的appid对应的公众号绑定的安全域名不匹配时，微信会禁止你去打开这个链接；如果你要调试页面，微信会到后台去找你所用的微信号是不是在appid对应的公众号下的开发者名单中有没有你，如果没有微信也会禁止你去调试这个页面；公众号后台也会有很多功能，微信通过appid也能来查询你有没有开通这个功能。</p>\n<p>所以，因为后台接口用的是另一个appid，微信认为开打的是另一个公众号的页面，而这个公众号的开发者名单中并没有我，所以我没有办法去调试。</p>\n<hr>\n<h3 id=\"微信禁止不安全的https链接\"><a href=\"#微信禁止不安全的https链接\" class=\"headerlink\" title=\"微信禁止不安全的https链接\"></a>微信禁止不安全的https链接</h3><p>经过第一个问题之后，我可以在web开发者工具中调试我的页面了，我又遇到了另一个奇怪的问题：我在开发者工具中整个页面功能没有问题，但是在微信当中打开，就会出现错误。当时，特别困惑因为在开发者工具中并没有报任何错误，而在微信中你无法看到错误信息，所以到底是哪个位置出现了错误你也不清楚。</p>\n<p>经过了上网查询，自己排查，知道了原因是这样的。</p>\n<p>因为后台接口走的是https，后台的https证书只对应线上的那个域名，而在测试环境中因为接口域名和证书并不对应，所以微信认为这个链接是不安全的，而微信会禁止不安全的https链接。而在web开发者工具中是可以访问这样不安全的https的连接的，所以就会出现上述的问题。</p>\n<p>所以，在今后遇到这样web开发者工具和微信行为不一致的时候，我们可以先查看一下是不是我们有https的接口是不安全的。</p>\n<hr>\n<h3 id=\"withCredentials跨域请求\"><a href=\"#withCredentials跨域请求\" class=\"headerlink\" title=\"withCredentials跨域请求\"></a>withCredentials跨域请求</h3><p>我们首先应该知道这个知识：默认情况下，ajxa跨域请求是不会发送用户认证凭据的（cookie、HTTP认证及客户端SSL证明等）。</p>\n<p>有什么方法可以解决这个问题呢？可以通过设置ajax的<code>withCredentials</code>属性为<code>true</code>来指定某个请求是可以发送用户认证凭据。不过要注意：支持withCredentials属性的浏览器有Firefox 3.5+、Safari 4+和Chrome。IE10及更早版本都不支持。</p>\n<p>如果设置这个属性的话，请求头中就会带上cookie，而后台要接受这个凭据的话，在服务端的响应头必须添加<code>Access-Control-Allow-Credentials: true</code>，并且<strong>服务端需指定一个域名（Access-Control-Allow-Origin:www.xxxxxx.com），而不能使用泛型（Access-Control-Allow-Origin: * ）</strong>这样我们就可以跨域发送cookie了。</p>\n<p>如果是原生的话大概是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">'GET'</span>, <span class=\"string\">'http://www.xxx.com/api'</span>);</span><br><span class=\"line\">xhr.withCredentials = <span class=\"literal\">true</span>;</span><br><span class=\"line\">xhr.onload = onLoadHandler;</span><br><span class=\"line\">xhr.send();</span><br></pre></td></tr></table></figure>\n<p>如果使用类库的话（如zepto）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\"> \turl: url,</span><br><span class=\"line\"> \ttype: <span class=\"string\">'get'</span>,</span><br><span class=\"line\"> \tdata:  data,</span><br><span class=\"line\"> \tdataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\"> \txhrFields: &#123;</span><br><span class=\"line\">   \t\twithCredentials: <span class=\"literal\">true</span></span><br><span class=\"line\"> \t&#125;,</span><br></pre></td></tr></table></figure>\n<p><code>zepto</code>的<code>ajax</code>中有这样一个参数：<code>xhrFields</code> (默认： none): 一个对象包含的属性被逐字复制到XMLHttpRequest的实例。</p>\n<p>大概就是这么多吧，如果想起来在添加。</p>\n<p>最后在吐槽一下吧，生活不如意之事十之八九</p>\n<p>总感觉生活总在你比较满意的时候给你一记当头棒喝，本来最近还活的好好的，经过几个月的努力学习算是顺利的转行，也在一直学习成长，对自己最近的表现也比较满意。而上帝可能觉得你近一阶段有些骄傲和浮躁了，需要给你提醒一下，所以最近遇到了一个小挫折，也让自己知道了一些不足，就像盖楼，基础往往决定你能不能盖一座高楼，而技术决定你能盖多高，基础确实是一个必要条件，而我现在就处在半瓶水响叮当的阶段，对一些基础只是知其然不知其所以然，往往会用、知道，但是没有深究原理。这就对出现的一些问题在解决起来，可能会毫无头绪，依靠网络未尝不是一个办法，但往往不是最好的办法，如果了解原理你可能对出现问题的原因追根溯源，但是你如果只找到这个问题的解决办法，下次出现因为这个原理出现的其他问题你依然会没有头绪。</p>\n<p>再有，听清问题，想好之后再去回答，说的每句话应该是绝对经过思考的  尤其在不熟悉的人之间。</p>\n<p>小品里说过嘛，车轱辘往前转，人要往前看，夯实基础，拥抱新技术，是我未来一年的目标，不卑不亢，不喜不悲，希望下次再战。</p>\n<p>以上。</p>\n"},{"layout":"post","title":"《你不知道的JavaScript》读书笔记——this","date":"2016-03-30T16:00:00.000Z","_content":"\n### 对this的误解\n\n学习`this`之前，应该知道两句话。\n\n首先要先消除对`this`的误解，明白第一句话：***`this`既不指向函数自身也不指向函数的词法作用域。***这句话很重要，现在看一下证明这句话的例子。\n\n***既不指向函数自身***\n\n看下面的代码：\n\n```js\nfunction foo(num) {\n    console.log( \"foo: \" + num );\n    // 记录foo被调用的次数\n    this.count++;\n}\nfoo.count = 0;\nvar i; \nfor (i=0; i<10; i++){\n    if( i > 5 ){\n        foo( i );\n    }\n}\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n// foo􏱦被调用了几次？\nconsole.log( foo.count ); // 0 -- WTF? \n```\n\n在`foo.count = 0`执行的时候，确实是向函数`foo`添加了一个属性`count`，但是`this.count`中的`this`并不是指向`foo`函数本身。\n\n***也不指向函数的词法作用域***\n\n看下面代码：\n\n```js\nfunction foo() {\n     var a = 2;\n     this.bar();\n }\n function bar() {\n     console.log( this.a );\n }\n foo(); // ReferenceError: a is not defined\n```\n\n是不是觉得应该输出2？但是`this`并不指向`foo`的词法作用域，实际上`this`在任何情况都不指向函数的词法作用域，使用`this`不可能在词法作用域查询到什么。\n\n*****\n\n### this指向什么\n\n第二句重要的话：***this实际上是在函数被调用时发生的绑定，它指向什么全完取决于函数被调用的位置。***\n\n***它指向什么全完取决于函数被调用的位置。***\n\n首先就是要找到函数被调用的位置，找位置要分析调用栈（执行当前函数的位置），我们要找的调用位置就是当前执行函数的前一个调用的位置。说着绕看代码就很明了了：\n\n```js\nfunction baz(){\n    //当前的调用栈是：baz\n    //因此，当前的调用位置是全局作用域\n    \n    console.log('baz');\n    bar(); //<--bar的调用位置\n}\nfunction bar(){\n    //当前的调用栈是：baz -> bar\n    //因此，当前的调用位置在baz中\n    \n    console.log('bar');\n    foo(); //<--foo的调用位置\n}\nfunction foo(){\n    //当前的调用栈是：baz -> bar ->foo\n    //因此，当前的调用位置在bar中\n    \n    console.log('foo'); \n}\nbaz(); //<--baz的调用位置\n```\n\n看完这个应该就会明白了，this指向的位置，就是在调用的位置。如果`this`在`foo`函数中，`foo`函数的调用位置是`bar`，那`foo`函数中的`this`就指向`bar`。\n\n***this实际上是在函数被调用时发生的绑定***\n\n找到了指向的位置，就要找this绑定在哪个对象上。`this`绑定会有四条规则，每一条的优先级是不同的。\n\n四条规则分别是：默认绑定、隐式绑定、显式绑定、new绑定。\n\n优先级是这样的：\n\n1. 是否在new中调用？如果是，this就绑定的是新创建的对象。\n2. 是否通过call、apply、bind调用（显式绑定）？如果是，this绑定的就是指定的对象。\n3. 是否在某个上下文对象中调用（隐式绑定）？如果是，this绑定的是那个上下文对象。\n4. 都不是的话，就是默认绑定。在严格模式下绑定到`undefined`，否则就是全局对象上。\n\n下面介绍四中绑定：\n\n#### 默认绑定\n\n看下面这个代码：\n\n```js\nfunction foo() {\n     console.log( this.a );\n }\nvar a = 2;\nfoo(); // 2\n```\n\n我们应该已经知道了，这个里的`this`会指向全局作用域。但原因是什么？是因为`foo()`是直接使用，没有在别的函数或对象内部被调用，所以就是默认绑定，默认绑定的`this`就会指向全局作用域。\n\n但是如果在严格模式中，全局对象无法使用默认绑定，`this`就会绑定到`undefined`：\n\n```js\nfunction foo() {\n    \"use strict\";\n    console.log( this.a );\n}\nvar a = 2;\nfoo(); // TypeError: this is undefined\n```\n\n#### 隐式绑定\n\n如果`this`所在的函数被某个对象拥有或者包含，函数在运行时就会有这个对象的上下文，隐式绑定规则就会把函数中的`this`（隐式）绑定到这个上下文对象上。如果是一个链式调用呢，就只会关心最后一次调用时的上下文。\n\n看下面代码：\n\n```js\nfunction foo() {\n     console.log( this.a );\n} \nvar obj2 = {\n    a: 42,\n    foo: foo \n}; \nvar obj1 = {\n    a: 2,\n    obj2: obj2 \n}; \nobj1.obj2.foo(); // 42\n```\n像这样的链式调用呢，`this`最后在`obj2`中被引用，所以`this.a`其实就是`obj2.a`，就是42。\n\n***隐式丢失***\n\n```js\nfunction foo() {\n     console.log( this.a );\n} \nvar obj = {\n    a: 2,\n    foo: foo \n}; \nvar bar = obj.foo; // 􏰃􏰄函数别名\nvar a = \"oops, global\"; //a是全局对象的属性\nbar(); // \"oops, global\" \n```\n\n因为`bar()`是一个不带任何修饰的函数调用，所以应用了默认绑定。\n\n还有一个更常见的问题，在传入回调函数的时候：\n\n```js\nfunction foo() {\n     console.log( this.a );\n }\n function doFoo(fn) {\n     // fn是参数，其实引用的是foo\n     fn(); // <-- 调用位置\n} \n var obj = {\n     a: 2,\nfoo: foo }; \nvar a = \"oops, global\"; // a是全局对象属性\ndoFoo( obj.foo ); // \"oops, global\" \n```\n参数传递其实就是一种隐式赋值，所以我们传入的函数时也会被隐式赋值，隐式赋值会在全局作用域创建一个变量，所以结果就和上个例子一样。\n\n语言的一些内置函数的本质其实也是传递参数，所以也会隐式赋值，就是出现绑定的丢失。\n\n比如`setTimeout`函数：\n\n```js\nfunction foo() {\n     console.log( this.a );\n} \nvar obj = {\n    a: 2,\n    foo: foo \n}; \nvar a = \"oops, global\"; // a是全局对象属性\nsetTimeout( obj.foo, 100 ); // \"oops, global\" \n```\n\nJavaScript内部`setTimeout`的实现，会传递参数：\n\n```js\n//类似实现\nfunction setTimeout(fn,delay) {\n    fn(); \n} \n```\n\n#### 显式绑定\n\nJavaScript提供了`call()`和`apply()`方法，可以直接指定this的绑定对象，称之为显式绑定。就像下面这样：\n\n```js\nfunction foo() {\n    console.log( this.a );\n} \nvar obj = { \n    a:2 \n};\nfoo.call( obj ); // 2\n```\n这样通过`foo.call()`，可以把`this`绑定到`obj`上面。\n\n如果在`call()`中传入一个基本类型来当做`this`的绑定对象，那基本类型会调用基本包装类，把它变成对象的形式。\n\n但显示绑定还是不能解决绑定丢失的问题，显式绑定的一个变种可以解决这个问题。办法就是在显式绑定的外面再加一个包裹函数，负责接收参数并返回值，这种方法叫***硬绑定***。\n\n下面是例子：\n\n```js\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n} \nvar obj = { \n    a:2 \n}; \nvar bar = function() {\n    return foo.apply( obj, arguments );\n}; \nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\nES5提供了一个内置的硬绑定的方法：`bind()`，用法如下：\n\n```js\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n} \nvar obj = {\n    a:2 \n};\nvar bar = foo.bind( obj );\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n#### new绑定\n\n使用new来构造函数调用，会发生new绑定。会自动执行下面的操作：\n\n1. 创建一个全新的对象。\n2. 这个新对象会被执行[[Prototype]]连接。\n3. 这个新对象会绑定到函数调用的this。\n4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。\n\n参考代码：\n\n```js\nfunction foo(a) {\n     this.a = a;\n }\n var bar = new foo(2);\n console.log( bar.a ); // 2\n```\n\n`this`的内容大概就这么多，关于这本书对象和原型这部分，书上讲了很多理论知识，并且知识点很多很杂，我的理解也不是很深刻，总结无非是把书上东西搬上来而已，不如换一个方式。慕课网上Bosn老师有一系列课程对对象原型有了很好的解释，不妨去看一下。[链接在这里](http://www.imooc.com/learn/277)\n\n","source":"_posts/2016-03-31-你不知道的JavaScript读书笔记——this.md","raw":"---\nlayout: post\ntitle: 《你不知道的JavaScript》读书笔记——this\ndate: 2016-03-31\ntags: ['JavaScript','this']\ncategories: JavaScript\t\n---\n\n### 对this的误解\n\n学习`this`之前，应该知道两句话。\n\n首先要先消除对`this`的误解，明白第一句话：***`this`既不指向函数自身也不指向函数的词法作用域。***这句话很重要，现在看一下证明这句话的例子。\n\n***既不指向函数自身***\n\n看下面的代码：\n\n```js\nfunction foo(num) {\n    console.log( \"foo: \" + num );\n    // 记录foo被调用的次数\n    this.count++;\n}\nfoo.count = 0;\nvar i; \nfor (i=0; i<10; i++){\n    if( i > 5 ){\n        foo( i );\n    }\n}\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n// foo􏱦被调用了几次？\nconsole.log( foo.count ); // 0 -- WTF? \n```\n\n在`foo.count = 0`执行的时候，确实是向函数`foo`添加了一个属性`count`，但是`this.count`中的`this`并不是指向`foo`函数本身。\n\n***也不指向函数的词法作用域***\n\n看下面代码：\n\n```js\nfunction foo() {\n     var a = 2;\n     this.bar();\n }\n function bar() {\n     console.log( this.a );\n }\n foo(); // ReferenceError: a is not defined\n```\n\n是不是觉得应该输出2？但是`this`并不指向`foo`的词法作用域，实际上`this`在任何情况都不指向函数的词法作用域，使用`this`不可能在词法作用域查询到什么。\n\n*****\n\n### this指向什么\n\n第二句重要的话：***this实际上是在函数被调用时发生的绑定，它指向什么全完取决于函数被调用的位置。***\n\n***它指向什么全完取决于函数被调用的位置。***\n\n首先就是要找到函数被调用的位置，找位置要分析调用栈（执行当前函数的位置），我们要找的调用位置就是当前执行函数的前一个调用的位置。说着绕看代码就很明了了：\n\n```js\nfunction baz(){\n    //当前的调用栈是：baz\n    //因此，当前的调用位置是全局作用域\n    \n    console.log('baz');\n    bar(); //<--bar的调用位置\n}\nfunction bar(){\n    //当前的调用栈是：baz -> bar\n    //因此，当前的调用位置在baz中\n    \n    console.log('bar');\n    foo(); //<--foo的调用位置\n}\nfunction foo(){\n    //当前的调用栈是：baz -> bar ->foo\n    //因此，当前的调用位置在bar中\n    \n    console.log('foo'); \n}\nbaz(); //<--baz的调用位置\n```\n\n看完这个应该就会明白了，this指向的位置，就是在调用的位置。如果`this`在`foo`函数中，`foo`函数的调用位置是`bar`，那`foo`函数中的`this`就指向`bar`。\n\n***this实际上是在函数被调用时发生的绑定***\n\n找到了指向的位置，就要找this绑定在哪个对象上。`this`绑定会有四条规则，每一条的优先级是不同的。\n\n四条规则分别是：默认绑定、隐式绑定、显式绑定、new绑定。\n\n优先级是这样的：\n\n1. 是否在new中调用？如果是，this就绑定的是新创建的对象。\n2. 是否通过call、apply、bind调用（显式绑定）？如果是，this绑定的就是指定的对象。\n3. 是否在某个上下文对象中调用（隐式绑定）？如果是，this绑定的是那个上下文对象。\n4. 都不是的话，就是默认绑定。在严格模式下绑定到`undefined`，否则就是全局对象上。\n\n下面介绍四中绑定：\n\n#### 默认绑定\n\n看下面这个代码：\n\n```js\nfunction foo() {\n     console.log( this.a );\n }\nvar a = 2;\nfoo(); // 2\n```\n\n我们应该已经知道了，这个里的`this`会指向全局作用域。但原因是什么？是因为`foo()`是直接使用，没有在别的函数或对象内部被调用，所以就是默认绑定，默认绑定的`this`就会指向全局作用域。\n\n但是如果在严格模式中，全局对象无法使用默认绑定，`this`就会绑定到`undefined`：\n\n```js\nfunction foo() {\n    \"use strict\";\n    console.log( this.a );\n}\nvar a = 2;\nfoo(); // TypeError: this is undefined\n```\n\n#### 隐式绑定\n\n如果`this`所在的函数被某个对象拥有或者包含，函数在运行时就会有这个对象的上下文，隐式绑定规则就会把函数中的`this`（隐式）绑定到这个上下文对象上。如果是一个链式调用呢，就只会关心最后一次调用时的上下文。\n\n看下面代码：\n\n```js\nfunction foo() {\n     console.log( this.a );\n} \nvar obj2 = {\n    a: 42,\n    foo: foo \n}; \nvar obj1 = {\n    a: 2,\n    obj2: obj2 \n}; \nobj1.obj2.foo(); // 42\n```\n像这样的链式调用呢，`this`最后在`obj2`中被引用，所以`this.a`其实就是`obj2.a`，就是42。\n\n***隐式丢失***\n\n```js\nfunction foo() {\n     console.log( this.a );\n} \nvar obj = {\n    a: 2,\n    foo: foo \n}; \nvar bar = obj.foo; // 􏰃􏰄函数别名\nvar a = \"oops, global\"; //a是全局对象的属性\nbar(); // \"oops, global\" \n```\n\n因为`bar()`是一个不带任何修饰的函数调用，所以应用了默认绑定。\n\n还有一个更常见的问题，在传入回调函数的时候：\n\n```js\nfunction foo() {\n     console.log( this.a );\n }\n function doFoo(fn) {\n     // fn是参数，其实引用的是foo\n     fn(); // <-- 调用位置\n} \n var obj = {\n     a: 2,\nfoo: foo }; \nvar a = \"oops, global\"; // a是全局对象属性\ndoFoo( obj.foo ); // \"oops, global\" \n```\n参数传递其实就是一种隐式赋值，所以我们传入的函数时也会被隐式赋值，隐式赋值会在全局作用域创建一个变量，所以结果就和上个例子一样。\n\n语言的一些内置函数的本质其实也是传递参数，所以也会隐式赋值，就是出现绑定的丢失。\n\n比如`setTimeout`函数：\n\n```js\nfunction foo() {\n     console.log( this.a );\n} \nvar obj = {\n    a: 2,\n    foo: foo \n}; \nvar a = \"oops, global\"; // a是全局对象属性\nsetTimeout( obj.foo, 100 ); // \"oops, global\" \n```\n\nJavaScript内部`setTimeout`的实现，会传递参数：\n\n```js\n//类似实现\nfunction setTimeout(fn,delay) {\n    fn(); \n} \n```\n\n#### 显式绑定\n\nJavaScript提供了`call()`和`apply()`方法，可以直接指定this的绑定对象，称之为显式绑定。就像下面这样：\n\n```js\nfunction foo() {\n    console.log( this.a );\n} \nvar obj = { \n    a:2 \n};\nfoo.call( obj ); // 2\n```\n这样通过`foo.call()`，可以把`this`绑定到`obj`上面。\n\n如果在`call()`中传入一个基本类型来当做`this`的绑定对象，那基本类型会调用基本包装类，把它变成对象的形式。\n\n但显示绑定还是不能解决绑定丢失的问题，显式绑定的一个变种可以解决这个问题。办法就是在显式绑定的外面再加一个包裹函数，负责接收参数并返回值，这种方法叫***硬绑定***。\n\n下面是例子：\n\n```js\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n} \nvar obj = { \n    a:2 \n}; \nvar bar = function() {\n    return foo.apply( obj, arguments );\n}; \nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\nES5提供了一个内置的硬绑定的方法：`bind()`，用法如下：\n\n```js\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n} \nvar obj = {\n    a:2 \n};\nvar bar = foo.bind( obj );\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n#### new绑定\n\n使用new来构造函数调用，会发生new绑定。会自动执行下面的操作：\n\n1. 创建一个全新的对象。\n2. 这个新对象会被执行[[Prototype]]连接。\n3. 这个新对象会绑定到函数调用的this。\n4. 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。\n\n参考代码：\n\n```js\nfunction foo(a) {\n     this.a = a;\n }\n var bar = new foo(2);\n console.log( bar.a ); // 2\n```\n\n`this`的内容大概就这么多，关于这本书对象和原型这部分，书上讲了很多理论知识，并且知识点很多很杂，我的理解也不是很深刻，总结无非是把书上东西搬上来而已，不如换一个方式。慕课网上Bosn老师有一系列课程对对象原型有了很好的解释，不妨去看一下。[链接在这里](http://www.imooc.com/learn/277)\n\n","slug":"你不知道的JavaScript读书笔记——this","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1zd001xsq5l93c5pgj0","content":"<h3 id=\"对this的误解\"><a href=\"#对this的误解\" class=\"headerlink\" title=\"对this的误解\"></a>对this的误解</h3><p>学习<code>this</code>之前，应该知道两句话。</p>\n<p>首先要先消除对<code>this</code>的误解，明白第一句话：<strong><em><code>this</code>既不指向函数自身也不指向函数的词法作用域。</em></strong>这句话很重要，现在看一下证明这句话的例子。</p>\n<p><strong><em>既不指向函数自身</em></strong></p>\n<p>看下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"foo: \"</span> + num );</span><br><span class=\"line\">    <span class=\"comment\">// 记录foo被调用的次数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.count++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> i; </span><br><span class=\"line\"><span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( i &gt; <span class=\"number\">5</span> )&#123;</span><br><span class=\"line\">        foo( i );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// foo: 6</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 7</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 8</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 9</span></span><br><span class=\"line\"><span class=\"comment\">// foo􏱦被调用了几次？</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( foo.count ); <span class=\"comment\">// 0 -- WTF?</span></span><br></pre></td></tr></table></figure>\n<p>在<code>foo.count = 0</code>执行的时候，确实是向函数<code>foo</code>添加了一个属性<code>count</code>，但是<code>this.count</code>中的<code>this</code>并不是指向<code>foo</code>函数本身。</p>\n<p><strong><em>也不指向函数的词法作用域</em></strong></p>\n<p>看下面代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.bar();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> foo(); <span class=\"comment\">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>\n<p>是不是觉得应该输出2？但是<code>this</code>并不指向<code>foo</code>的词法作用域，实际上<code>this</code>在任何情况都不指向函数的词法作用域，使用<code>this</code>不可能在词法作用域查询到什么。</p>\n<hr>\n<h3 id=\"this指向什么\"><a href=\"#this指向什么\" class=\"headerlink\" title=\"this指向什么\"></a>this指向什么</h3><p>第二句重要的话：<strong><em>this实际上是在函数被调用时发生的绑定，它指向什么全完取决于函数被调用的位置。</em></strong></p>\n<p><strong><em>它指向什么全完取决于函数被调用的位置。</em></strong></p>\n<p>首先就是要找到函数被调用的位置，找位置要分析调用栈（执行当前函数的位置），我们要找的调用位置就是当前执行函数的前一个调用的位置。说着绕看代码就很明了了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前的调用栈是：baz</span></span><br><span class=\"line\">    <span class=\"comment\">//因此，当前的调用位置是全局作用域</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'baz'</span>);</span><br><span class=\"line\">    bar(); <span class=\"comment\">//&lt;--bar的调用位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前的调用栈是：baz -&gt; bar</span></span><br><span class=\"line\">    <span class=\"comment\">//因此，当前的调用位置在baz中</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'bar'</span>);</span><br><span class=\"line\">    foo(); <span class=\"comment\">//&lt;--foo的调用位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前的调用栈是：baz -&gt; bar -&gt;foo</span></span><br><span class=\"line\">    <span class=\"comment\">//因此，当前的调用位置在bar中</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">baz(); <span class=\"comment\">//&lt;--baz的调用位置</span></span><br></pre></td></tr></table></figure>\n<p>看完这个应该就会明白了，this指向的位置，就是在调用的位置。如果<code>this</code>在<code>foo</code>函数中，<code>foo</code>函数的调用位置是<code>bar</code>，那<code>foo</code>函数中的<code>this</code>就指向<code>bar</code>。</p>\n<p><strong><em>this实际上是在函数被调用时发生的绑定</em></strong></p>\n<p>找到了指向的位置，就要找this绑定在哪个对象上。<code>this</code>绑定会有四条规则，每一条的优先级是不同的。</p>\n<p>四条规则分别是：默认绑定、隐式绑定、显式绑定、new绑定。</p>\n<p>优先级是这样的：</p>\n<ol>\n<li>是否在new中调用？如果是，this就绑定的是新创建的对象。</li>\n<li>是否通过call、apply、bind调用（显式绑定）？如果是，this绑定的就是指定的对象。</li>\n<li>是否在某个上下文对象中调用（隐式绑定）？如果是，this绑定的是那个上下文对象。</li>\n<li>都不是的话，就是默认绑定。在严格模式下绑定到<code>undefined</code>，否则就是全局对象上。</li>\n</ol>\n<p>下面介绍四中绑定：</p>\n<h4 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h4><p>看下面这个代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>我们应该已经知道了，这个里的<code>this</code>会指向全局作用域。但原因是什么？是因为<code>foo()</code>是直接使用，没有在别的函数或对象内部被调用，所以就是默认绑定，默认绑定的<code>this</code>就会指向全局作用域。</p>\n<p>但是如果在严格模式中，全局对象无法使用默认绑定，<code>this</code>就会绑定到<code>undefined</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    \"use strict\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo(); <span class=\"comment\">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h4><p>如果<code>this</code>所在的函数被某个对象拥有或者包含，函数在运行时就会有这个对象的上下文，隐式绑定规则就会把函数中的<code>this</code>（隐式）绑定到这个上下文对象上。如果是一个链式调用呢，就只会关心最后一次调用时的上下文。</p>\n<p>看下面代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">42</span>,</span><br><span class=\"line\">    foo: foo </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    obj2: obj2 </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">obj1.obj2.foo(); <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<p>像这样的链式调用呢，<code>this</code>最后在<code>obj2</code>中被引用，所以<code>this.a</code>其实就是<code>obj2.a</code>，就是42。</p>\n<p><strong><em>隐式丢失</em></strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo; <span class=\"comment\">// 􏰃􏰄函数别名</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">//a是全局对象的属性</span></span><br><span class=\"line\">bar(); <span class=\"comment\">// \"oops, global\"</span></span><br></pre></td></tr></table></figure>\n<p>因为<code>bar()</code>是一个不带任何修饰的函数调用，所以应用了默认绑定。</p>\n<p>还有一个更常见的问题，在传入回调函数的时候：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// fn是参数，其实引用的是foo</span></span><br><span class=\"line\">     fn(); <span class=\"comment\">// &lt;-- 调用位置</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">     a: <span class=\"number\">2</span>,</span><br><span class=\"line\">foo: foo &#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">// a是全局对象属性</span></span><br><span class=\"line\">doFoo( obj.foo ); <span class=\"comment\">// \"oops, global\"</span></span><br></pre></td></tr></table></figure>\n<p>参数传递其实就是一种隐式赋值，所以我们传入的函数时也会被隐式赋值，隐式赋值会在全局作用域创建一个变量，所以结果就和上个例子一样。</p>\n<p>语言的一些内置函数的本质其实也是传递参数，所以也会隐式赋值，就是出现绑定的丢失。</p>\n<p>比如<code>setTimeout</code>函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">// a是全局对象属性</span></span><br><span class=\"line\">setTimeout( obj.foo, <span class=\"number\">100</span> ); <span class=\"comment\">// \"oops, global\"</span></span><br></pre></td></tr></table></figure>\n<p>JavaScript内部<code>setTimeout</code>的实现，会传递参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类似实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setTimeout</span>(<span class=\"params\">fn,delay</span>) </span>&#123;</span><br><span class=\"line\">    fn(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h4><p>JavaScript提供了<code>call()</code>和<code>apply()</code>方法，可以直接指定this的绑定对象，称之为显式绑定。就像下面这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; </span><br><span class=\"line\">    a:<span class=\"number\">2</span> </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call( obj ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>这样通过<code>foo.call()</code>，可以把<code>this</code>绑定到<code>obj</code>上面。</p>\n<p>如果在<code>call()</code>中传入一个基本类型来当做<code>this</code>的绑定对象，那基本类型会调用基本包装类，把它变成对象的形式。</p>\n<p>但显示绑定还是不能解决绑定丢失的问题，显式绑定的一个变种可以解决这个问题。办法就是在显式绑定的外面再加一个包裹函数，负责接收参数并返回值，这种方法叫<strong><em>硬绑定</em></strong>。</p>\n<p>下面是例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; </span><br><span class=\"line\">    a:<span class=\"number\">2</span> </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>ES5提供了一个内置的硬绑定的方法：<code>bind()</code>，用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span> </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( obj );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h4><p>使用new来构造函数调用，会发生new绑定。会自动执行下面的操作：</p>\n<ol>\n<li>创建一个全新的对象。</li>\n<li>这个新对象会被执行[[Prototype]]连接。</li>\n<li>这个新对象会绑定到函数调用的this。</li>\n<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( bar.a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><code>this</code>的内容大概就这么多，关于这本书对象和原型这部分，书上讲了很多理论知识，并且知识点很多很杂，我的理解也不是很深刻，总结无非是把书上东西搬上来而已，不如换一个方式。慕课网上Bosn老师有一系列课程对对象原型有了很好的解释，不妨去看一下。<a href=\"http://www.imooc.com/learn/277\" target=\"_blank\" rel=\"external\">链接在这里</a></p>\n","excerpt":"","more":"<h3 id=\"对this的误解\"><a href=\"#对this的误解\" class=\"headerlink\" title=\"对this的误解\"></a>对this的误解</h3><p>学习<code>this</code>之前，应该知道两句话。</p>\n<p>首先要先消除对<code>this</code>的误解，明白第一句话：<strong><em><code>this</code>既不指向函数自身也不指向函数的词法作用域。</em></strong>这句话很重要，现在看一下证明这句话的例子。</p>\n<p><strong><em>既不指向函数自身</em></strong></p>\n<p>看下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"string\">\"foo: \"</span> + num );</span><br><span class=\"line\">    <span class=\"comment\">// 记录foo被调用的次数</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.count++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> i; </span><br><span class=\"line\"><span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( i &gt; <span class=\"number\">5</span> )&#123;</span><br><span class=\"line\">        foo( i );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// foo: 6</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 7</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 8</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 9</span></span><br><span class=\"line\"><span class=\"comment\">// foo􏱦被调用了几次？</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( foo.count ); <span class=\"comment\">// 0 -- WTF?</span></span><br></pre></td></tr></table></figure>\n<p>在<code>foo.count = 0</code>执行的时候，确实是向函数<code>foo</code>添加了一个属性<code>count</code>，但是<code>this.count</code>中的<code>this</code>并不是指向<code>foo</code>函数本身。</p>\n<p><strong><em>也不指向函数的词法作用域</em></strong></p>\n<p>看下面代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.bar();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> foo(); <span class=\"comment\">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>\n<p>是不是觉得应该输出2？但是<code>this</code>并不指向<code>foo</code>的词法作用域，实际上<code>this</code>在任何情况都不指向函数的词法作用域，使用<code>this</code>不可能在词法作用域查询到什么。</p>\n<hr>\n<h3 id=\"this指向什么\"><a href=\"#this指向什么\" class=\"headerlink\" title=\"this指向什么\"></a>this指向什么</h3><p>第二句重要的话：<strong><em>this实际上是在函数被调用时发生的绑定，它指向什么全完取决于函数被调用的位置。</em></strong></p>\n<p><strong><em>它指向什么全完取决于函数被调用的位置。</em></strong></p>\n<p>首先就是要找到函数被调用的位置，找位置要分析调用栈（执行当前函数的位置），我们要找的调用位置就是当前执行函数的前一个调用的位置。说着绕看代码就很明了了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前的调用栈是：baz</span></span><br><span class=\"line\">    <span class=\"comment\">//因此，当前的调用位置是全局作用域</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'baz'</span>);</span><br><span class=\"line\">    bar(); <span class=\"comment\">//&lt;--bar的调用位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前的调用栈是：baz -&gt; bar</span></span><br><span class=\"line\">    <span class=\"comment\">//因此，当前的调用位置在baz中</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'bar'</span>);</span><br><span class=\"line\">    foo(); <span class=\"comment\">//&lt;--foo的调用位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当前的调用栈是：baz -&gt; bar -&gt;foo</span></span><br><span class=\"line\">    <span class=\"comment\">//因此，当前的调用位置在bar中</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo'</span>); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">baz(); <span class=\"comment\">//&lt;--baz的调用位置</span></span><br></pre></td></tr></table></figure>\n<p>看完这个应该就会明白了，this指向的位置，就是在调用的位置。如果<code>this</code>在<code>foo</code>函数中，<code>foo</code>函数的调用位置是<code>bar</code>，那<code>foo</code>函数中的<code>this</code>就指向<code>bar</code>。</p>\n<p><strong><em>this实际上是在函数被调用时发生的绑定</em></strong></p>\n<p>找到了指向的位置，就要找this绑定在哪个对象上。<code>this</code>绑定会有四条规则，每一条的优先级是不同的。</p>\n<p>四条规则分别是：默认绑定、隐式绑定、显式绑定、new绑定。</p>\n<p>优先级是这样的：</p>\n<ol>\n<li>是否在new中调用？如果是，this就绑定的是新创建的对象。</li>\n<li>是否通过call、apply、bind调用（显式绑定）？如果是，this绑定的就是指定的对象。</li>\n<li>是否在某个上下文对象中调用（隐式绑定）？如果是，this绑定的是那个上下文对象。</li>\n<li>都不是的话，就是默认绑定。在严格模式下绑定到<code>undefined</code>，否则就是全局对象上。</li>\n</ol>\n<p>下面介绍四中绑定：</p>\n<h4 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h4><p>看下面这个代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo(); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>我们应该已经知道了，这个里的<code>this</code>会指向全局作用域。但原因是什么？是因为<code>foo()</code>是直接使用，没有在别的函数或对象内部被调用，所以就是默认绑定，默认绑定的<code>this</code>就会指向全局作用域。</p>\n<p>但是如果在严格模式中，全局对象无法使用默认绑定，<code>this</code>就会绑定到<code>undefined</code>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    \"use strict\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo(); <span class=\"comment\">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h4><p>如果<code>this</code>所在的函数被某个对象拥有或者包含，函数在运行时就会有这个对象的上下文，隐式绑定规则就会把函数中的<code>this</code>（隐式）绑定到这个上下文对象上。如果是一个链式调用呢，就只会关心最后一次调用时的上下文。</p>\n<p>看下面代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">42</span>,</span><br><span class=\"line\">    foo: foo </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    obj2: obj2 </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">obj1.obj2.foo(); <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<p>像这样的链式调用呢，<code>this</code>最后在<code>obj2</code>中被引用，所以<code>this.a</code>其实就是<code>obj2.a</code>，就是42。</p>\n<p><strong><em>隐式丢失</em></strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = obj.foo; <span class=\"comment\">// 􏰃􏰄函数别名</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">//a是全局对象的属性</span></span><br><span class=\"line\">bar(); <span class=\"comment\">// \"oops, global\"</span></span><br></pre></td></tr></table></figure>\n<p>因为<code>bar()</code>是一个不带任何修饰的函数调用，所以应用了默认绑定。</p>\n<p>还有一个更常见的问题，在传入回调函数的时候：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// fn是参数，其实引用的是foo</span></span><br><span class=\"line\">     fn(); <span class=\"comment\">// &lt;-- 调用位置</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"> <span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">     a: <span class=\"number\">2</span>,</span><br><span class=\"line\">foo: foo &#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">// a是全局对象属性</span></span><br><span class=\"line\">doFoo( obj.foo ); <span class=\"comment\">// \"oops, global\"</span></span><br></pre></td></tr></table></figure>\n<p>参数传递其实就是一种隐式赋值，所以我们传入的函数时也会被隐式赋值，隐式赋值会在全局作用域创建一个变量，所以结果就和上个例子一样。</p>\n<p>语言的一些内置函数的本质其实也是传递参数，所以也会隐式赋值，就是出现绑定的丢失。</p>\n<p>比如<code>setTimeout</code>函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a: <span class=\"number\">2</span>,</span><br><span class=\"line\">    foo: foo </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"oops, global\"</span>; <span class=\"comment\">// a是全局对象属性</span></span><br><span class=\"line\">setTimeout( obj.foo, <span class=\"number\">100</span> ); <span class=\"comment\">// \"oops, global\"</span></span><br></pre></td></tr></table></figure>\n<p>JavaScript内部<code>setTimeout</code>的实现，会传递参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//类似实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setTimeout</span>(<span class=\"params\">fn,delay</span>) </span>&#123;</span><br><span class=\"line\">    fn(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"显式绑定\"><a href=\"#显式绑定\" class=\"headerlink\" title=\"显式绑定\"></a>显式绑定</h4><p>JavaScript提供了<code>call()</code>和<code>apply()</code>方法，可以直接指定this的绑定对象，称之为显式绑定。就像下面这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; </span><br><span class=\"line\">    a:<span class=\"number\">2</span> </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">foo.call( obj ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>这样通过<code>foo.call()</code>，可以把<code>this</code>绑定到<code>obj</code>上面。</p>\n<p>如果在<code>call()</code>中传入一个基本类型来当做<code>this</code>的绑定对象，那基本类型会调用基本包装类，把它变成对象的形式。</p>\n<p>但显示绑定还是不能解决绑定丢失的问题，显式绑定的一个变种可以解决这个问题。办法就是在显式绑定的外面再加一个包裹函数，负责接收参数并返回值，这种方法叫<strong><em>硬绑定</em></strong>。</p>\n<p>下面是例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; </span><br><span class=\"line\">    a:<span class=\"number\">2</span> </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>ES5提供了一个内置的硬绑定的方法：<code>bind()</code>，用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    a:<span class=\"number\">2</span> </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( obj );</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h4><p>使用new来构造函数调用，会发生new绑定。会自动执行下面的操作：</p>\n<ol>\n<li>创建一个全新的对象。</li>\n<li>这个新对象会被执行[[Prototype]]连接。</li>\n<li>这个新对象会绑定到函数调用的this。</li>\n<li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<p>参考代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.a = a;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> bar = <span class=\"keyword\">new</span> foo(<span class=\"number\">2</span>);</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log( bar.a ); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><code>this</code>的内容大概就这么多，关于这本书对象和原型这部分，书上讲了很多理论知识，并且知识点很多很杂，我的理解也不是很深刻，总结无非是把书上东西搬上来而已，不如换一个方式。慕课网上Bosn老师有一系列课程对对象原型有了很好的解释，不妨去看一下。<a href=\"http://www.imooc.com/learn/277\">链接在这里</a></p>\n"},{"layout":"post","title":"WebStorage","date":"2016-04-14T16:00:00.000Z","_content":"\n接着上周那个获取地理位置的功能继续说，上周JSSDK注册是成功了，但是又发现了另一个bug，如果一个未登陆过的用户从分享链接登录会报错误，state参数过长，登录失败。\n\n这个bug出现的原因是在后台，因为后台代替前端去调微信授权的接口，取到code后再去种session到前端的这个页面，后台会携带一些参数在state这个字段中，但微信state字段最大支持128字节，超出这个最大限制后就会报错了。\n\n*我不太清楚在state字段中带参数的原因，但是听他们讨论大概是因为需要跨域去传递一些东西，所以要在state字段中传递参数。\n\n后来就改变了注册的方式，原来是后台去代替前端去调微信授权的接口，现在改为：\n1. 首先如果我检测到没有session的话，我会去调微信授权的接口，回调域写我本身，这样通过授权后跳回到页面url后面会带一个code的参数。\n2. 拿着url后code这个参数，再去请求后台的接口，后台接收两个参数：一个code和回调的url。\n3. 把code和回调的url（还是我页面本身）传到后台，后台就会在应答头中把session给我带回到页面中。\n\n****\n\n### Storage\n\n由前端来处理的时候，可能会用到一样东西就是本地储存，为什么会用到？因为我们在调两个接口的时候回调的url都是同一个（即最初页面的url，而不是携带code参数的url），而如果页面重新加载后js会重新执行，并不能缓存一些参数，如果你使用`location.href`来取url的话，不能保证这个url是一致的，当然也可以通过js处理来把后面不需要的参数去掉，但是那么做显然会繁琐一些。\n\n如果用到本地存储的话，我们可以把要用到的url存储在本地，当页面再次加载是从Storage中读取那个想要的url就可以了。\n\n我是这么做的：\n\n```js\n  var code = util.getQuery(location.href).code;\n\n  if(util.Cookie.get('sessionid') == ''){\n    if(!code){\n      localStorage.redirect_uri = encodeURIComponent(location.href);\n      location.href = 'https://o2.qfpay.com/trade/wechat/v1/get_weixin_code?appid=wxeb6e671f5571abce&redirect_uri='+localStorage.redirect_uri+'&response_type=code&scope=snsapi_userinfo&state=STATE#wechat_redirect' ;\n    }else{\n      location.href = config.host + 'wx_callback?redirect_url=' + localStorage.redirect_uri + '&code=' + code;\n    }\n  }\n```\n\n首先我会判断url中有没有code，如果没有那说明这个url是没有经过微信授权的那个url，我就会把这个url写到localStorage中。如果有code，我就把code连同要回调的url传到后台接口去。\n\n主要是介绍一下localStorage和sessionStorage：（参考犀牛书）\n\nlocalStorage和sessionStorage都是用来存储数据的属性，两者的区别在于存储的有效期和作用域的不同：数据可以存储多长时间以及谁拥有数据的访问权。\n\n#### 有效期\n\nlocalStorage存储的数据是永久性的，除非刻意的去删除存储的数据（浏览器的清除功能等），否则数据一直保留永不过期。\n\nsessionStorage存储的数据是暂时性的，如果当前窗口或者标签页被永久关闭了，通过当前页sessionStorage存储的数据就会被删除掉。（现在浏览器有恢复最近关闭的标签页的功能，所以sessionStorage得有效期可能会长一些）。\n\n#### 作用域\n\nlocalStorage的作用域是同文档源，文档源由协议、主机名和端口确定的，三个当中任意一个不同都不属于同文档源。\n\n```js\nhttp://www.example.com  //协议：http；主机名：www.example\n```\n\n同源的文档间可以共享localStorage数据，并且可以互相读写，反之则不可以。但是注意localStorage的作用域也受浏览器的限制，不同浏览器只能访问本浏览器localStorage存储的数据。\n\nsessionStorage除了遵循上面的同源策略之外，作用域还被限制在窗口的标签页中。两个不同的标签页各自拥有各自的sessionStorage数据不能共享，就算两个标签页渲染的是同一个页面运行同一个脚本也不可以。\n\n如果一个标签页包含两个`<iframe>`的话，如果它们所包含的文档是同源的，两者的sessionStorage是可以共享的。\n\n*****\n\nlocalStorage和sessionStorage目前只支持存储字符串类型的数据。存储其他类的话需要自己进行编码和解码。\n\n```js\n//读写数字\nlocalStorage.x = 10;\nvar x = parseInt(localStorage.x);\n\n//读写日期\nlocalStorage.lastRead = (new Date()).toUTCString();\nvar lastRead = new Date(Date.parse(localStorage.lastRead));\n\n//读写JSON\nlocalStorage.data = JSON.stringify(data);\nvar data = JSON.parse(localStorage.data);\n```\n\nlocalStorage和sessionStorage除了可以通过设置属性和查询属性来读写之外，也有正式的API。\n\n```js\nlocalStorage.setItem(\"key\",\"value\");//以“key”为名称存储一个值“value”\nlocalStorage.getItem(\"key\");//获取名称为“key”的值\n\n//枚举localStorage的方法：\nfor(var i=0;i<localStorage.length;i++){\n     var name = localStorage.key(i)​;\n     var value = localStorage.getItem(name);​\n}\n\n//删除localStorage中存储信息的方法：\nlocalStorage.removeItem(\"key\");//删除名称为“key”的信息。\nlocalStorage.clear();​//清空localStorage中所有信息\n```\n","source":"_posts/2016-04-15-WebStorage.md","raw":"---\nlayout: post\ntitle: WebStorage\ndate: 2016-04-15\ntags: ['WebStorage','页面储存']\ncategories: 工作总结\t\n---\n\n接着上周那个获取地理位置的功能继续说，上周JSSDK注册是成功了，但是又发现了另一个bug，如果一个未登陆过的用户从分享链接登录会报错误，state参数过长，登录失败。\n\n这个bug出现的原因是在后台，因为后台代替前端去调微信授权的接口，取到code后再去种session到前端的这个页面，后台会携带一些参数在state这个字段中，但微信state字段最大支持128字节，超出这个最大限制后就会报错了。\n\n*我不太清楚在state字段中带参数的原因，但是听他们讨论大概是因为需要跨域去传递一些东西，所以要在state字段中传递参数。\n\n后来就改变了注册的方式，原来是后台去代替前端去调微信授权的接口，现在改为：\n1. 首先如果我检测到没有session的话，我会去调微信授权的接口，回调域写我本身，这样通过授权后跳回到页面url后面会带一个code的参数。\n2. 拿着url后code这个参数，再去请求后台的接口，后台接收两个参数：一个code和回调的url。\n3. 把code和回调的url（还是我页面本身）传到后台，后台就会在应答头中把session给我带回到页面中。\n\n****\n\n### Storage\n\n由前端来处理的时候，可能会用到一样东西就是本地储存，为什么会用到？因为我们在调两个接口的时候回调的url都是同一个（即最初页面的url，而不是携带code参数的url），而如果页面重新加载后js会重新执行，并不能缓存一些参数，如果你使用`location.href`来取url的话，不能保证这个url是一致的，当然也可以通过js处理来把后面不需要的参数去掉，但是那么做显然会繁琐一些。\n\n如果用到本地存储的话，我们可以把要用到的url存储在本地，当页面再次加载是从Storage中读取那个想要的url就可以了。\n\n我是这么做的：\n\n```js\n  var code = util.getQuery(location.href).code;\n\n  if(util.Cookie.get('sessionid') == ''){\n    if(!code){\n      localStorage.redirect_uri = encodeURIComponent(location.href);\n      location.href = 'https://o2.qfpay.com/trade/wechat/v1/get_weixin_code?appid=wxeb6e671f5571abce&redirect_uri='+localStorage.redirect_uri+'&response_type=code&scope=snsapi_userinfo&state=STATE#wechat_redirect' ;\n    }else{\n      location.href = config.host + 'wx_callback?redirect_url=' + localStorage.redirect_uri + '&code=' + code;\n    }\n  }\n```\n\n首先我会判断url中有没有code，如果没有那说明这个url是没有经过微信授权的那个url，我就会把这个url写到localStorage中。如果有code，我就把code连同要回调的url传到后台接口去。\n\n主要是介绍一下localStorage和sessionStorage：（参考犀牛书）\n\nlocalStorage和sessionStorage都是用来存储数据的属性，两者的区别在于存储的有效期和作用域的不同：数据可以存储多长时间以及谁拥有数据的访问权。\n\n#### 有效期\n\nlocalStorage存储的数据是永久性的，除非刻意的去删除存储的数据（浏览器的清除功能等），否则数据一直保留永不过期。\n\nsessionStorage存储的数据是暂时性的，如果当前窗口或者标签页被永久关闭了，通过当前页sessionStorage存储的数据就会被删除掉。（现在浏览器有恢复最近关闭的标签页的功能，所以sessionStorage得有效期可能会长一些）。\n\n#### 作用域\n\nlocalStorage的作用域是同文档源，文档源由协议、主机名和端口确定的，三个当中任意一个不同都不属于同文档源。\n\n```js\nhttp://www.example.com  //协议：http；主机名：www.example\n```\n\n同源的文档间可以共享localStorage数据，并且可以互相读写，反之则不可以。但是注意localStorage的作用域也受浏览器的限制，不同浏览器只能访问本浏览器localStorage存储的数据。\n\nsessionStorage除了遵循上面的同源策略之外，作用域还被限制在窗口的标签页中。两个不同的标签页各自拥有各自的sessionStorage数据不能共享，就算两个标签页渲染的是同一个页面运行同一个脚本也不可以。\n\n如果一个标签页包含两个`<iframe>`的话，如果它们所包含的文档是同源的，两者的sessionStorage是可以共享的。\n\n*****\n\nlocalStorage和sessionStorage目前只支持存储字符串类型的数据。存储其他类的话需要自己进行编码和解码。\n\n```js\n//读写数字\nlocalStorage.x = 10;\nvar x = parseInt(localStorage.x);\n\n//读写日期\nlocalStorage.lastRead = (new Date()).toUTCString();\nvar lastRead = new Date(Date.parse(localStorage.lastRead));\n\n//读写JSON\nlocalStorage.data = JSON.stringify(data);\nvar data = JSON.parse(localStorage.data);\n```\n\nlocalStorage和sessionStorage除了可以通过设置属性和查询属性来读写之外，也有正式的API。\n\n```js\nlocalStorage.setItem(\"key\",\"value\");//以“key”为名称存储一个值“value”\nlocalStorage.getItem(\"key\");//获取名称为“key”的值\n\n//枚举localStorage的方法：\nfor(var i=0;i<localStorage.length;i++){\n     var name = localStorage.key(i)​;\n     var value = localStorage.getItem(name);​\n}\n\n//删除localStorage中存储信息的方法：\nlocalStorage.removeItem(\"key\");//删除名称为“key”的信息。\nlocalStorage.clear();​//清空localStorage中所有信息\n```\n","slug":"WebStorage","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1ze0020sq5lngchajun","content":"<p>接着上周那个获取地理位置的功能继续说，上周JSSDK注册是成功了，但是又发现了另一个bug，如果一个未登陆过的用户从分享链接登录会报错误，state参数过长，登录失败。</p>\n<p>这个bug出现的原因是在后台，因为后台代替前端去调微信授权的接口，取到code后再去种session到前端的这个页面，后台会携带一些参数在state这个字段中，但微信state字段最大支持128字节，超出这个最大限制后就会报错了。</p>\n<p>*我不太清楚在state字段中带参数的原因，但是听他们讨论大概是因为需要跨域去传递一些东西，所以要在state字段中传递参数。</p>\n<p>后来就改变了注册的方式，原来是后台去代替前端去调微信授权的接口，现在改为：</p>\n<ol>\n<li>首先如果我检测到没有session的话，我会去调微信授权的接口，回调域写我本身，这样通过授权后跳回到页面url后面会带一个code的参数。</li>\n<li>拿着url后code这个参数，再去请求后台的接口，后台接收两个参数：一个code和回调的url。</li>\n<li>把code和回调的url（还是我页面本身）传到后台，后台就会在应答头中把session给我带回到页面中。</li>\n</ol>\n<hr>\n<h3 id=\"Storage\"><a href=\"#Storage\" class=\"headerlink\" title=\"Storage\"></a>Storage</h3><p>由前端来处理的时候，可能会用到一样东西就是本地储存，为什么会用到？因为我们在调两个接口的时候回调的url都是同一个（即最初页面的url，而不是携带code参数的url），而如果页面重新加载后js会重新执行，并不能缓存一些参数，如果你使用<code>location.href</code>来取url的话，不能保证这个url是一致的，当然也可以通过js处理来把后面不需要的参数去掉，但是那么做显然会繁琐一些。</p>\n<p>如果用到本地存储的话，我们可以把要用到的url存储在本地，当页面再次加载是从Storage中读取那个想要的url就可以了。</p>\n<p>我是这么做的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> code = util.getQuery(location.href).code;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(util.Cookie.get(<span class=\"string\">'sessionid'</span>) == <span class=\"string\">''</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!code)&#123;</span><br><span class=\"line\">    localStorage.redirect_uri = <span class=\"built_in\">encodeURIComponent</span>(location.href);</span><br><span class=\"line\">    location.href = <span class=\"string\">'https://o2.qfpay.com/trade/wechat/v1/get_weixin_code?appid=wxeb6e671f5571abce&amp;redirect_uri='</span>+localStorage.redirect_uri+<span class=\"string\">'&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect'</span> ;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    location.href = config.host + <span class=\"string\">'wx_callback?redirect_url='</span> + localStorage.redirect_uri + <span class=\"string\">'&amp;code='</span> + code;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我会判断url中有没有code，如果没有那说明这个url是没有经过微信授权的那个url，我就会把这个url写到localStorage中。如果有code，我就把code连同要回调的url传到后台接口去。</p>\n<p>主要是介绍一下localStorage和sessionStorage：（参考犀牛书）</p>\n<p>localStorage和sessionStorage都是用来存储数据的属性，两者的区别在于存储的有效期和作用域的不同：数据可以存储多长时间以及谁拥有数据的访问权。</p>\n<h4 id=\"有效期\"><a href=\"#有效期\" class=\"headerlink\" title=\"有效期\"></a>有效期</h4><p>localStorage存储的数据是永久性的，除非刻意的去删除存储的数据（浏览器的清除功能等），否则数据一直保留永不过期。</p>\n<p>sessionStorage存储的数据是暂时性的，如果当前窗口或者标签页被永久关闭了，通过当前页sessionStorage存储的数据就会被删除掉。（现在浏览器有恢复最近关闭的标签页的功能，所以sessionStorage得有效期可能会长一些）。</p>\n<h4 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h4><p>localStorage的作用域是同文档源，文档源由协议、主机名和端口确定的，三个当中任意一个不同都不属于同文档源。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http:<span class=\"comment\">//www.example.com  //协议：http；主机名：www.example</span></span><br></pre></td></tr></table></figure>\n<p>同源的文档间可以共享localStorage数据，并且可以互相读写，反之则不可以。但是注意localStorage的作用域也受浏览器的限制，不同浏览器只能访问本浏览器localStorage存储的数据。</p>\n<p>sessionStorage除了遵循上面的同源策略之外，作用域还被限制在窗口的标签页中。两个不同的标签页各自拥有各自的sessionStorage数据不能共享，就算两个标签页渲染的是同一个页面运行同一个脚本也不可以。</p>\n<p>如果一个标签页包含两个<code>&lt;iframe&gt;</code>的话，如果它们所包含的文档是同源的，两者的sessionStorage是可以共享的。</p>\n<hr>\n<p>localStorage和sessionStorage目前只支持存储字符串类型的数据。存储其他类的话需要自己进行编码和解码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//读写数字</span></span><br><span class=\"line\">localStorage.x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"built_in\">parseInt</span>(localStorage.x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读写日期</span></span><br><span class=\"line\">localStorage.lastRead = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).toUTCString();</span><br><span class=\"line\"><span class=\"keyword\">var</span> lastRead = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"built_in\">Date</span>.parse(localStorage.lastRead));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读写JSON</span></span><br><span class=\"line\">localStorage.data = <span class=\"built_in\">JSON</span>.stringify(data);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(localStorage.data);</span><br></pre></td></tr></table></figure>\n<p>localStorage和sessionStorage除了可以通过设置属性和查询属性来读写之外，也有正式的API。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.setItem(<span class=\"string\">\"key\"</span>,<span class=\"string\">\"value\"</span>);<span class=\"comment\">//以“key”为名称存储一个值“value”</span></span><br><span class=\"line\">localStorage.getItem(<span class=\"string\">\"key\"</span>);<span class=\"comment\">//获取名称为“key”的值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//枚举localStorage的方法：</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;localStorage.length;i++)&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> name = localStorage.key(i)​;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> value = localStorage.getItem(name);​</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//删除localStorage中存储信息的方法：</span></span><br><span class=\"line\">localStorage.removeItem(<span class=\"string\">\"key\"</span>);<span class=\"comment\">//删除名称为“key”的信息。</span></span><br><span class=\"line\">localStorage.clear();​<span class=\"comment\">//清空localStorage中所有信息</span></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>接着上周那个获取地理位置的功能继续说，上周JSSDK注册是成功了，但是又发现了另一个bug，如果一个未登陆过的用户从分享链接登录会报错误，state参数过长，登录失败。</p>\n<p>这个bug出现的原因是在后台，因为后台代替前端去调微信授权的接口，取到code后再去种session到前端的这个页面，后台会携带一些参数在state这个字段中，但微信state字段最大支持128字节，超出这个最大限制后就会报错了。</p>\n<p>*我不太清楚在state字段中带参数的原因，但是听他们讨论大概是因为需要跨域去传递一些东西，所以要在state字段中传递参数。</p>\n<p>后来就改变了注册的方式，原来是后台去代替前端去调微信授权的接口，现在改为：</p>\n<ol>\n<li>首先如果我检测到没有session的话，我会去调微信授权的接口，回调域写我本身，这样通过授权后跳回到页面url后面会带一个code的参数。</li>\n<li>拿着url后code这个参数，再去请求后台的接口，后台接收两个参数：一个code和回调的url。</li>\n<li>把code和回调的url（还是我页面本身）传到后台，后台就会在应答头中把session给我带回到页面中。</li>\n</ol>\n<hr>\n<h3 id=\"Storage\"><a href=\"#Storage\" class=\"headerlink\" title=\"Storage\"></a>Storage</h3><p>由前端来处理的时候，可能会用到一样东西就是本地储存，为什么会用到？因为我们在调两个接口的时候回调的url都是同一个（即最初页面的url，而不是携带code参数的url），而如果页面重新加载后js会重新执行，并不能缓存一些参数，如果你使用<code>location.href</code>来取url的话，不能保证这个url是一致的，当然也可以通过js处理来把后面不需要的参数去掉，但是那么做显然会繁琐一些。</p>\n<p>如果用到本地存储的话，我们可以把要用到的url存储在本地，当页面再次加载是从Storage中读取那个想要的url就可以了。</p>\n<p>我是这么做的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> code = util.getQuery(location.href).code;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(util.Cookie.get(<span class=\"string\">'sessionid'</span>) == <span class=\"string\">''</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!code)&#123;</span><br><span class=\"line\">    localStorage.redirect_uri = <span class=\"built_in\">encodeURIComponent</span>(location.href);</span><br><span class=\"line\">    location.href = <span class=\"string\">'https://o2.qfpay.com/trade/wechat/v1/get_weixin_code?appid=wxeb6e671f5571abce&amp;redirect_uri='</span>+localStorage.redirect_uri+<span class=\"string\">'&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect'</span> ;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    location.href = config.host + <span class=\"string\">'wx_callback?redirect_url='</span> + localStorage.redirect_uri + <span class=\"string\">'&amp;code='</span> + code;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我会判断url中有没有code，如果没有那说明这个url是没有经过微信授权的那个url，我就会把这个url写到localStorage中。如果有code，我就把code连同要回调的url传到后台接口去。</p>\n<p>主要是介绍一下localStorage和sessionStorage：（参考犀牛书）</p>\n<p>localStorage和sessionStorage都是用来存储数据的属性，两者的区别在于存储的有效期和作用域的不同：数据可以存储多长时间以及谁拥有数据的访问权。</p>\n<h4 id=\"有效期\"><a href=\"#有效期\" class=\"headerlink\" title=\"有效期\"></a>有效期</h4><p>localStorage存储的数据是永久性的，除非刻意的去删除存储的数据（浏览器的清除功能等），否则数据一直保留永不过期。</p>\n<p>sessionStorage存储的数据是暂时性的，如果当前窗口或者标签页被永久关闭了，通过当前页sessionStorage存储的数据就会被删除掉。（现在浏览器有恢复最近关闭的标签页的功能，所以sessionStorage得有效期可能会长一些）。</p>\n<h4 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h4><p>localStorage的作用域是同文档源，文档源由协议、主机名和端口确定的，三个当中任意一个不同都不属于同文档源。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http:<span class=\"comment\">//www.example.com  //协议：http；主机名：www.example</span></span><br></pre></td></tr></table></figure>\n<p>同源的文档间可以共享localStorage数据，并且可以互相读写，反之则不可以。但是注意localStorage的作用域也受浏览器的限制，不同浏览器只能访问本浏览器localStorage存储的数据。</p>\n<p>sessionStorage除了遵循上面的同源策略之外，作用域还被限制在窗口的标签页中。两个不同的标签页各自拥有各自的sessionStorage数据不能共享，就算两个标签页渲染的是同一个页面运行同一个脚本也不可以。</p>\n<p>如果一个标签页包含两个<code>&lt;iframe&gt;</code>的话，如果它们所包含的文档是同源的，两者的sessionStorage是可以共享的。</p>\n<hr>\n<p>localStorage和sessionStorage目前只支持存储字符串类型的数据。存储其他类的话需要自己进行编码和解码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//读写数字</span></span><br><span class=\"line\">localStorage.x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"built_in\">parseInt</span>(localStorage.x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读写日期</span></span><br><span class=\"line\">localStorage.lastRead = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).toUTCString();</span><br><span class=\"line\"><span class=\"keyword\">var</span> lastRead = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"built_in\">Date</span>.parse(localStorage.lastRead));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读写JSON</span></span><br><span class=\"line\">localStorage.data = <span class=\"built_in\">JSON</span>.stringify(data);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(localStorage.data);</span><br></pre></td></tr></table></figure>\n<p>localStorage和sessionStorage除了可以通过设置属性和查询属性来读写之外，也有正式的API。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage.setItem(<span class=\"string\">\"key\"</span>,<span class=\"string\">\"value\"</span>);<span class=\"comment\">//以“key”为名称存储一个值“value”</span></span><br><span class=\"line\">localStorage.getItem(<span class=\"string\">\"key\"</span>);<span class=\"comment\">//获取名称为“key”的值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//枚举localStorage的方法：</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;localStorage.length;i++)&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> name = localStorage.key(i)​;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> value = localStorage.getItem(name);​</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//删除localStorage中存储信息的方法：</span></span><br><span class=\"line\">localStorage.removeItem(<span class=\"string\">\"key\"</span>);<span class=\"comment\">//删除名称为“key”的信息。</span></span><br><span class=\"line\">localStorage.clear();​<span class=\"comment\">//清空localStorage中所有信息</span></span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"《JavaScript高级程序设计》读书笔记","date":"2016-04-17T16:00:00.000Z","_content":"\n最近在复习《JavaScript高级程序设计》，然后记一些自己原来不懂的地方吧，不会整个总结，就是按知识点一个一个把新学到的列出来。\n\n1. JavaScript = ECMAScript + DOM + BOM\n\n2. 在html中可以用`<noscript>`的标签，在这个标签内写的html内容，会在浏览器不支持脚本或者浏览器禁用脚本的时候显示出来。\n\n3.  JavaScript的变量是区分大小写的。\n\n4. isFinite()函数可以确定一个数值是不是有穷的即在不在浏览器支持的最大值和最小值之间，如果是就会返回`true`。\n\n5. Number()􏰟parseInt()􏰠和parseFloat()，第一个可以把任何类型转换为数值，另外两个可以把字符串转换为数值。\n\n6. 转换为字符串有两种方式：toString()和String()。toString()方法可带参数表示输出数值的基数，但不能转换undefined和null；String()方法的规则是：有toString()方法调用toString()，如果是undefined和null则返回相应字符串。\n\n7. 每个创建的对象实例都有下列方法和属性：constructor，hasOwnProperty，isPrototypeOf，propertyIsEnumerable，toLocaleString()，toString()，valueOf()。\n\n8. 复制基本类型的变量值得时候会复制出一个副本（互相不会影响），而复制一个对象类型的时候会添加一个指针而已（修改一个会影响另一个）。\n\n9. 确定一个值是那种基本类型用`typeof`，确定值是哪一种引用类型用`instanceof`。\n\n10. 通过`[]`来访问对象属性的时候，`[]`中可以是变量，也可以是非字母非数字的属性名。\n\n11. arguments.callee是一个指向正在执行函数的指针，在递归当中可以应用。（在严格模式中这个不可以用，可以用一个命名函数表达式，`var a = (function b (){})`）在函数中调用`b`这个函数名。\n\n12. 使用`var`定义在全局的变量其实是window下的一个属性，他的Configurable属性设为了false（不可配置的），所以不能用delete删除掉。\n13. 每个框架有自己的window，top对象指向对外层框架，也就是浏览器窗口。\n14. BOM中window.moveBy、window.moveTo、window.resizeTo、window.resizeBy这些方法在浏览器默认是禁用的，且只作用于最外层窗口对象。\n15. 浏览器有三种提示框alert()（只有确认键）、confirm()（有确认和取消键）和prompt()（除了确认取消还有输入框）。\n16. 一个页面的两个框架如果是不同子域将无法通信，可以将document.domain设置为同一个主域名，他们之间就可以互相通信了。（有限制，只可以从紧绷`p2p.wrox.com`向松散`wrox.com`改变，反之不可）。\n17. ","source":"_posts/2016-04-18-《JavaScript高级程序设计》读书笔记.md","raw":"---\nlayout: post\ntitle: 《JavaScript高级程序设计》读书笔记\ndate: 2016-04-18\ntags: ['JavaScript']\ncategories: JavaScript\t\n---\n\n最近在复习《JavaScript高级程序设计》，然后记一些自己原来不懂的地方吧，不会整个总结，就是按知识点一个一个把新学到的列出来。\n\n1. JavaScript = ECMAScript + DOM + BOM\n\n2. 在html中可以用`<noscript>`的标签，在这个标签内写的html内容，会在浏览器不支持脚本或者浏览器禁用脚本的时候显示出来。\n\n3.  JavaScript的变量是区分大小写的。\n\n4. isFinite()函数可以确定一个数值是不是有穷的即在不在浏览器支持的最大值和最小值之间，如果是就会返回`true`。\n\n5. Number()􏰟parseInt()􏰠和parseFloat()，第一个可以把任何类型转换为数值，另外两个可以把字符串转换为数值。\n\n6. 转换为字符串有两种方式：toString()和String()。toString()方法可带参数表示输出数值的基数，但不能转换undefined和null；String()方法的规则是：有toString()方法调用toString()，如果是undefined和null则返回相应字符串。\n\n7. 每个创建的对象实例都有下列方法和属性：constructor，hasOwnProperty，isPrototypeOf，propertyIsEnumerable，toLocaleString()，toString()，valueOf()。\n\n8. 复制基本类型的变量值得时候会复制出一个副本（互相不会影响），而复制一个对象类型的时候会添加一个指针而已（修改一个会影响另一个）。\n\n9. 确定一个值是那种基本类型用`typeof`，确定值是哪一种引用类型用`instanceof`。\n\n10. 通过`[]`来访问对象属性的时候，`[]`中可以是变量，也可以是非字母非数字的属性名。\n\n11. arguments.callee是一个指向正在执行函数的指针，在递归当中可以应用。（在严格模式中这个不可以用，可以用一个命名函数表达式，`var a = (function b (){})`）在函数中调用`b`这个函数名。\n\n12. 使用`var`定义在全局的变量其实是window下的一个属性，他的Configurable属性设为了false（不可配置的），所以不能用delete删除掉。\n13. 每个框架有自己的window，top对象指向对外层框架，也就是浏览器窗口。\n14. BOM中window.moveBy、window.moveTo、window.resizeTo、window.resizeBy这些方法在浏览器默认是禁用的，且只作用于最外层窗口对象。\n15. 浏览器有三种提示框alert()（只有确认键）、confirm()（有确认和取消键）和prompt()（除了确认取消还有输入框）。\n16. 一个页面的两个框架如果是不同子域将无法通信，可以将document.domain设置为同一个主域名，他们之间就可以互相通信了。（有限制，只可以从紧绷`p2p.wrox.com`向松散`wrox.com`改变，反之不可）。\n17. ","slug":"《JavaScript高级程序设计》读书笔记","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1zg0023sq5l1lipac0n","content":"<p>最近在复习《JavaScript高级程序设计》，然后记一些自己原来不懂的地方吧，不会整个总结，就是按知识点一个一个把新学到的列出来。</p>\n<ol>\n<li><p>JavaScript = ECMAScript + DOM + BOM</p>\n</li>\n<li><p>在html中可以用<code>&lt;noscript&gt;</code>的标签，在这个标签内写的html内容，会在浏览器不支持脚本或者浏览器禁用脚本的时候显示出来。</p>\n</li>\n<li><p>JavaScript的变量是区分大小写的。</p>\n</li>\n<li><p>isFinite()函数可以确定一个数值是不是有穷的即在不在浏览器支持的最大值和最小值之间，如果是就会返回<code>true</code>。</p>\n</li>\n<li><p>Number()􏰟parseInt()􏰠和parseFloat()，第一个可以把任何类型转换为数值，另外两个可以把字符串转换为数值。</p>\n</li>\n<li><p>转换为字符串有两种方式：toString()和String()。toString()方法可带参数表示输出数值的基数，但不能转换undefined和null；String()方法的规则是：有toString()方法调用toString()，如果是undefined和null则返回相应字符串。</p>\n</li>\n<li><p>每个创建的对象实例都有下列方法和属性：constructor，hasOwnProperty，isPrototypeOf，propertyIsEnumerable，toLocaleString()，toString()，valueOf()。</p>\n</li>\n<li><p>复制基本类型的变量值得时候会复制出一个副本（互相不会影响），而复制一个对象类型的时候会添加一个指针而已（修改一个会影响另一个）。</p>\n</li>\n<li><p>确定一个值是那种基本类型用<code>typeof</code>，确定值是哪一种引用类型用<code>instanceof</code>。</p>\n</li>\n<li><p>通过<code>[]</code>来访问对象属性的时候，<code>[]</code>中可以是变量，也可以是非字母非数字的属性名。</p>\n</li>\n<li><p>arguments.callee是一个指向正在执行函数的指针，在递归当中可以应用。（在严格模式中这个不可以用，可以用一个命名函数表达式，<code>var a = (function b (){})</code>）在函数中调用<code>b</code>这个函数名。</p>\n</li>\n<li><p>使用<code>var</code>定义在全局的变量其实是window下的一个属性，他的Configurable属性设为了false（不可配置的），所以不能用delete删除掉。</p>\n</li>\n<li>每个框架有自己的window，top对象指向对外层框架，也就是浏览器窗口。</li>\n<li>BOM中window.moveBy、window.moveTo、window.resizeTo、window.resizeBy这些方法在浏览器默认是禁用的，且只作用于最外层窗口对象。</li>\n<li>浏览器有三种提示框alert()（只有确认键）、confirm()（有确认和取消键）和prompt()（除了确认取消还有输入框）。</li>\n<li>一个页面的两个框架如果是不同子域将无法通信，可以将document.domain设置为同一个主域名，他们之间就可以互相通信了。（有限制，只可以从紧绷<code>p2p.wrox.com</code>向松散<code>wrox.com</code>改变，反之不可）。</li>\n<li></li>\n</ol>\n","excerpt":"","more":"<p>最近在复习《JavaScript高级程序设计》，然后记一些自己原来不懂的地方吧，不会整个总结，就是按知识点一个一个把新学到的列出来。</p>\n<ol>\n<li><p>JavaScript = ECMAScript + DOM + BOM</p>\n</li>\n<li><p>在html中可以用<code>&lt;noscript&gt;</code>的标签，在这个标签内写的html内容，会在浏览器不支持脚本或者浏览器禁用脚本的时候显示出来。</p>\n</li>\n<li><p>JavaScript的变量是区分大小写的。</p>\n</li>\n<li><p>isFinite()函数可以确定一个数值是不是有穷的即在不在浏览器支持的最大值和最小值之间，如果是就会返回<code>true</code>。</p>\n</li>\n<li><p>Number()􏰟parseInt()􏰠和parseFloat()，第一个可以把任何类型转换为数值，另外两个可以把字符串转换为数值。</p>\n</li>\n<li><p>转换为字符串有两种方式：toString()和String()。toString()方法可带参数表示输出数值的基数，但不能转换undefined和null；String()方法的规则是：有toString()方法调用toString()，如果是undefined和null则返回相应字符串。</p>\n</li>\n<li><p>每个创建的对象实例都有下列方法和属性：constructor，hasOwnProperty，isPrototypeOf，propertyIsEnumerable，toLocaleString()，toString()，valueOf()。</p>\n</li>\n<li><p>复制基本类型的变量值得时候会复制出一个副本（互相不会影响），而复制一个对象类型的时候会添加一个指针而已（修改一个会影响另一个）。</p>\n</li>\n<li><p>确定一个值是那种基本类型用<code>typeof</code>，确定值是哪一种引用类型用<code>instanceof</code>。</p>\n</li>\n<li><p>通过<code>[]</code>来访问对象属性的时候，<code>[]</code>中可以是变量，也可以是非字母非数字的属性名。</p>\n</li>\n<li><p>arguments.callee是一个指向正在执行函数的指针，在递归当中可以应用。（在严格模式中这个不可以用，可以用一个命名函数表达式，<code>var a = (function b (){})</code>）在函数中调用<code>b</code>这个函数名。</p>\n</li>\n<li><p>使用<code>var</code>定义在全局的变量其实是window下的一个属性，他的Configurable属性设为了false（不可配置的），所以不能用delete删除掉。</p>\n</li>\n<li>每个框架有自己的window，top对象指向对外层框架，也就是浏览器窗口。</li>\n<li>BOM中window.moveBy、window.moveTo、window.resizeTo、window.resizeBy这些方法在浏览器默认是禁用的，且只作用于最外层窗口对象。</li>\n<li>浏览器有三种提示框alert()（只有确认键）、confirm()（有确认和取消键）和prompt()（除了确认取消还有输入框）。</li>\n<li>一个页面的两个框架如果是不同子域将无法通信，可以将document.domain设置为同一个主域名，他们之间就可以互相通信了。（有限制，只可以从紧绷<code>p2p.wrox.com</code>向松散<code>wrox.com</code>改变，反之不可）。</li>\n<li></li>\n</ol>\n"},{"layout":"post","title":"重排reflow与重绘repaint","date":"2016-04-28T16:00:00.000Z","_content":"\n### 重绘与重排\n\n最近看了一本书《高性能JavaScript》，里面有很多有用的代码片段，后面我准备把一些摘抄记录下来。\n\n今天主要想说说重绘与重排，这个也是《高性能JavaScript》中讲的一部分，我来总结一下吧。\n\n首先先要了解一下浏览器渲染页面的过程，当浏览器下载完页面所需要的html、css、js和图片等后就会开始解析并生成两个内部的数据结构：DOM树和渲染树。\nDOM树是表示页面的结构，渲染树是表示DOM节点如何显示。\n\nDOM树不必多说，渲染树会结合DOM树和DOM节点对应的CSS样式去理解页面上每个元素的样式（比如内外边距，边框，位置等），去构建一个渲染树。渲染树完成后浏览器就开始绘制（paint）页面元素。\n\n关于这部分可以看这个链接[渲染树构建、布局及绘制\n](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn)\n\n当DOM树的结构和CSS产生变化影响到页面布局或元素的几何属性的时候，浏览器会重新构建渲染树，重新构建渲染树的过程就叫做`重排（reflow）`，重排完成后，浏览器会重新绘制受到影响的部分到屏幕中，这个过程叫做`重绘（repaint）`。\n\n并不是所有的变化都会影响到页面布局和元素的几何属性（即发生重排），下面的情况会发生重排：\n\n* 添加和删除可见的DOM元素。\n* 元素位置改变。\n* 元素尺寸改变（内外边距，边框厚度，宽高等）。\n* 内容改变（文本改变，图片尺寸改变）。\n* 浏览器窗口尺寸变化。\n* 页面渲染器初始化。\n\n不改变页面布局和元素几何属性的变化（比如背景色变化），只会发生一次重绘，并不会发生重排。\n\n### 减少重绘与重排\n\n因为重绘和重排需要大量计算，会影响页面的响应速度，所以我们应该尽量减少和避免重绘和重排。\n\n#### 改变样式\n\n看下面这段代码：\n\n```js\nvar el = document.getElementById('mydiv');\nel.style.borderLeft = '1px'; \nel.style.borderRight = '2px';\nel.style.padding = '5px';\n```\n\n这样添加样式，每一次都会改变元素的几何属性，在一些旧版浏览器中可能会引起三次重排（现代浏览器会做优化处理，发生一次重排），所以可以优化一下代码，合并样式一次性修改：\n\n```js\nvar el = document.getElementById('mydiv');\n//替换样式\nel.style.cssText = 'border-left: 1px; border-right: 2px; padding: 5px;';\n\n//保留原有样式\nel.style.cssText += '; border-left: 1px;';\n\n```\n这样修改只会引起一次重排，更为高效。还有一种做法就是为想要修改的部分添加一个`class`使用css一次性修改。\n\n#### 批量修改DOM\n\n如果我们需要对DOM进行一系列操作的时候，可以通过下面的做法来减少重绘和重排：\n\n1. 使元素脱离文档流。\n2. 对其进行操作。\n3. 把元素带回文档中。\n\n这样如果我们在第二步进行多次操作时，也只会在第一步和第三步触发两次重排。\n\n有三种基本方法可以使DOM脱离文档流:\n\n1. 隐藏元素，修改，重新显示。\n2. 使用文档片断（document fragment），在当前DOM外构建一个子树，再把它插入文档中。\n3. 把原始元素拷贝到脱离文档的节点中，修改后在把原始元素替换掉。\n\n用代码来说明三种方法：\n\n比如现在我们有一个`ul`列表，我们用一个方法`appendDataElement()`往列表中添加`li`。\n\n```js\n//要操作的列表\nvar ul = document.getElementById('mylist');\n//向列表中添加li，data是li中的内容\nappendDataToElement(ul, data);\n```\n\n如果我们不使用任何方法的话，每插入一个`li`就会触发一次重排，这样是很影响性能的。所以我们可以使用上面的三种方法。\n\n方法一：\n\n```js\nvar ul = document.getElementById('mylist');\nul.style.display = 'none'; \nappendDataToElement(ul, data);\nul.style.display = 'block';\n```\n\n方法二：\n\n```js\nvar fragment = document.createDocumentFragment();\nappendDataToElement(fragment, data);\ndocument.getElementById('mylist').appendChild(fragment);\n```\n\n方法三：\n\n```js\nvar old = document.getElementById('mylist'); \nvar clone = old.cloneNode(true);\nappendDataToElement(clone, data);\nold.parentNode.replaceChild(clone, old); \n\n```\n\n文章中是推荐我们使用第二种方法，因为这种方法本来设计的初衷就是为了解决这类任务的（更新和移动节点）。而且这种方法只触发一次重拍，只访问一次DOM节点。\n\n\n既然说到了重绘和重排，顺便就说一下动画，在动画中我们可以尽量使用`transform`和`opacity`，因为他们会不会触发重绘。具体可以看看这两篇文章：\n\n1. [CSS动画之硬件加速](http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html)\n2. [CSS动画的性能优化](http://zencode.in/14.CSS%E5%8A%A8%E7%94%BB%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html)","source":"_posts/2016-04-29-重排reflow与重绘repaint.md","raw":"---\nlayout: post\ntitle: 重排reflow与重绘repaint\ndate: 2016-04-29\ntags: ['JavaScript']\ncategories: JavaScript\t\n---\n\n### 重绘与重排\n\n最近看了一本书《高性能JavaScript》，里面有很多有用的代码片段，后面我准备把一些摘抄记录下来。\n\n今天主要想说说重绘与重排，这个也是《高性能JavaScript》中讲的一部分，我来总结一下吧。\n\n首先先要了解一下浏览器渲染页面的过程，当浏览器下载完页面所需要的html、css、js和图片等后就会开始解析并生成两个内部的数据结构：DOM树和渲染树。\nDOM树是表示页面的结构，渲染树是表示DOM节点如何显示。\n\nDOM树不必多说，渲染树会结合DOM树和DOM节点对应的CSS样式去理解页面上每个元素的样式（比如内外边距，边框，位置等），去构建一个渲染树。渲染树完成后浏览器就开始绘制（paint）页面元素。\n\n关于这部分可以看这个链接[渲染树构建、布局及绘制\n](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn)\n\n当DOM树的结构和CSS产生变化影响到页面布局或元素的几何属性的时候，浏览器会重新构建渲染树，重新构建渲染树的过程就叫做`重排（reflow）`，重排完成后，浏览器会重新绘制受到影响的部分到屏幕中，这个过程叫做`重绘（repaint）`。\n\n并不是所有的变化都会影响到页面布局和元素的几何属性（即发生重排），下面的情况会发生重排：\n\n* 添加和删除可见的DOM元素。\n* 元素位置改变。\n* 元素尺寸改变（内外边距，边框厚度，宽高等）。\n* 内容改变（文本改变，图片尺寸改变）。\n* 浏览器窗口尺寸变化。\n* 页面渲染器初始化。\n\n不改变页面布局和元素几何属性的变化（比如背景色变化），只会发生一次重绘，并不会发生重排。\n\n### 减少重绘与重排\n\n因为重绘和重排需要大量计算，会影响页面的响应速度，所以我们应该尽量减少和避免重绘和重排。\n\n#### 改变样式\n\n看下面这段代码：\n\n```js\nvar el = document.getElementById('mydiv');\nel.style.borderLeft = '1px'; \nel.style.borderRight = '2px';\nel.style.padding = '5px';\n```\n\n这样添加样式，每一次都会改变元素的几何属性，在一些旧版浏览器中可能会引起三次重排（现代浏览器会做优化处理，发生一次重排），所以可以优化一下代码，合并样式一次性修改：\n\n```js\nvar el = document.getElementById('mydiv');\n//替换样式\nel.style.cssText = 'border-left: 1px; border-right: 2px; padding: 5px;';\n\n//保留原有样式\nel.style.cssText += '; border-left: 1px;';\n\n```\n这样修改只会引起一次重排，更为高效。还有一种做法就是为想要修改的部分添加一个`class`使用css一次性修改。\n\n#### 批量修改DOM\n\n如果我们需要对DOM进行一系列操作的时候，可以通过下面的做法来减少重绘和重排：\n\n1. 使元素脱离文档流。\n2. 对其进行操作。\n3. 把元素带回文档中。\n\n这样如果我们在第二步进行多次操作时，也只会在第一步和第三步触发两次重排。\n\n有三种基本方法可以使DOM脱离文档流:\n\n1. 隐藏元素，修改，重新显示。\n2. 使用文档片断（document fragment），在当前DOM外构建一个子树，再把它插入文档中。\n3. 把原始元素拷贝到脱离文档的节点中，修改后在把原始元素替换掉。\n\n用代码来说明三种方法：\n\n比如现在我们有一个`ul`列表，我们用一个方法`appendDataElement()`往列表中添加`li`。\n\n```js\n//要操作的列表\nvar ul = document.getElementById('mylist');\n//向列表中添加li，data是li中的内容\nappendDataToElement(ul, data);\n```\n\n如果我们不使用任何方法的话，每插入一个`li`就会触发一次重排，这样是很影响性能的。所以我们可以使用上面的三种方法。\n\n方法一：\n\n```js\nvar ul = document.getElementById('mylist');\nul.style.display = 'none'; \nappendDataToElement(ul, data);\nul.style.display = 'block';\n```\n\n方法二：\n\n```js\nvar fragment = document.createDocumentFragment();\nappendDataToElement(fragment, data);\ndocument.getElementById('mylist').appendChild(fragment);\n```\n\n方法三：\n\n```js\nvar old = document.getElementById('mylist'); \nvar clone = old.cloneNode(true);\nappendDataToElement(clone, data);\nold.parentNode.replaceChild(clone, old); \n\n```\n\n文章中是推荐我们使用第二种方法，因为这种方法本来设计的初衷就是为了解决这类任务的（更新和移动节点）。而且这种方法只触发一次重拍，只访问一次DOM节点。\n\n\n既然说到了重绘和重排，顺便就说一下动画，在动画中我们可以尽量使用`transform`和`opacity`，因为他们会不会触发重绘。具体可以看看这两篇文章：\n\n1. [CSS动画之硬件加速](http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html)\n2. [CSS动画的性能优化](http://zencode.in/14.CSS%E5%8A%A8%E7%94%BB%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html)","slug":"重排reflow与重绘repaint","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1zj0025sq5l8r18eofv","content":"<h3 id=\"重绘与重排\"><a href=\"#重绘与重排\" class=\"headerlink\" title=\"重绘与重排\"></a>重绘与重排</h3><p>最近看了一本书《高性能JavaScript》，里面有很多有用的代码片段，后面我准备把一些摘抄记录下来。</p>\n<p>今天主要想说说重绘与重排，这个也是《高性能JavaScript》中讲的一部分，我来总结一下吧。</p>\n<p>首先先要了解一下浏览器渲染页面的过程，当浏览器下载完页面所需要的html、css、js和图片等后就会开始解析并生成两个内部的数据结构：DOM树和渲染树。<br>DOM树是表示页面的结构，渲染树是表示DOM节点如何显示。</p>\n<p>DOM树不必多说，渲染树会结合DOM树和DOM节点对应的CSS样式去理解页面上每个元素的样式（比如内外边距，边框，位置等），去构建一个渲染树。渲染树完成后浏览器就开始绘制（paint）页面元素。</p>\n<p>关于这部分可以看这个链接<a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn\" target=\"_blank\" rel=\"external\">渲染树构建、布局及绘制\n</a></p>\n<p>当DOM树的结构和CSS产生变化影响到页面布局或元素的几何属性的时候，浏览器会重新构建渲染树，重新构建渲染树的过程就叫做<code>重排（reflow）</code>，重排完成后，浏览器会重新绘制受到影响的部分到屏幕中，这个过程叫做<code>重绘（repaint）</code>。</p>\n<p>并不是所有的变化都会影响到页面布局和元素的几何属性（即发生重排），下面的情况会发生重排：</p>\n<ul>\n<li>添加和删除可见的DOM元素。</li>\n<li>元素位置改变。</li>\n<li>元素尺寸改变（内外边距，边框厚度，宽高等）。</li>\n<li>内容改变（文本改变，图片尺寸改变）。</li>\n<li>浏览器窗口尺寸变化。</li>\n<li>页面渲染器初始化。</li>\n</ul>\n<p>不改变页面布局和元素几何属性的变化（比如背景色变化），只会发生一次重绘，并不会发生重排。</p>\n<h3 id=\"减少重绘与重排\"><a href=\"#减少重绘与重排\" class=\"headerlink\" title=\"减少重绘与重排\"></a>减少重绘与重排</h3><p>因为重绘和重排需要大量计算，会影响页面的响应速度，所以我们应该尽量减少和避免重绘和重排。</p>\n<h4 id=\"改变样式\"><a href=\"#改变样式\" class=\"headerlink\" title=\"改变样式\"></a>改变样式</h4><p>看下面这段代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> el = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mydiv'</span>);</span><br><span class=\"line\">el.style.borderLeft = <span class=\"string\">'1px'</span>; </span><br><span class=\"line\">el.style.borderRight = <span class=\"string\">'2px'</span>;</span><br><span class=\"line\">el.style.padding = <span class=\"string\">'5px'</span>;</span><br></pre></td></tr></table></figure>\n<p>这样添加样式，每一次都会改变元素的几何属性，在一些旧版浏览器中可能会引起三次重排（现代浏览器会做优化处理，发生一次重排），所以可以优化一下代码，合并样式一次性修改：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> el = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mydiv'</span>);</span><br><span class=\"line\"><span class=\"comment\">//替换样式</span></span><br><span class=\"line\">el.style.cssText = <span class=\"string\">'border-left: 1px; border-right: 2px; padding: 5px;'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//保留原有样式</span></span><br><span class=\"line\">el.style.cssText += <span class=\"string\">'; border-left: 1px;'</span>;</span><br></pre></td></tr></table></figure>\n<p>这样修改只会引起一次重排，更为高效。还有一种做法就是为想要修改的部分添加一个<code>class</code>使用css一次性修改。</p>\n<h4 id=\"批量修改DOM\"><a href=\"#批量修改DOM\" class=\"headerlink\" title=\"批量修改DOM\"></a>批量修改DOM</h4><p>如果我们需要对DOM进行一系列操作的时候，可以通过下面的做法来减少重绘和重排：</p>\n<ol>\n<li>使元素脱离文档流。</li>\n<li>对其进行操作。</li>\n<li>把元素带回文档中。</li>\n</ol>\n<p>这样如果我们在第二步进行多次操作时，也只会在第一步和第三步触发两次重排。</p>\n<p>有三种基本方法可以使DOM脱离文档流:</p>\n<ol>\n<li>隐藏元素，修改，重新显示。</li>\n<li>使用文档片断（document fragment），在当前DOM外构建一个子树，再把它插入文档中。</li>\n<li>把原始元素拷贝到脱离文档的节点中，修改后在把原始元素替换掉。</li>\n</ol>\n<p>用代码来说明三种方法：</p>\n<p>比如现在我们有一个<code>ul</code>列表，我们用一个方法<code>appendDataElement()</code>往列表中添加<code>li</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//要操作的列表</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mylist'</span>);</span><br><span class=\"line\"><span class=\"comment\">//向列表中添加li，data是li中的内容</span></span><br><span class=\"line\">appendDataToElement(ul, data);</span><br></pre></td></tr></table></figure>\n<p>如果我们不使用任何方法的话，每插入一个<code>li</code>就会触发一次重排，这样是很影响性能的。所以我们可以使用上面的三种方法。</p>\n<p>方法一：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mylist'</span>);</span><br><span class=\"line\">ul.style.display = <span class=\"string\">'none'</span>; </span><br><span class=\"line\">appendDataToElement(ul, data);</span><br><span class=\"line\">ul.style.display = <span class=\"string\">'block'</span>;</span><br></pre></td></tr></table></figure>\n<p>方法二：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();</span><br><span class=\"line\">appendDataToElement(fragment, data);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mylist'</span>).appendChild(fragment);</span><br></pre></td></tr></table></figure>\n<p>方法三：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> old = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mylist'</span>); </span><br><span class=\"line\"><span class=\"keyword\">var</span> clone = old.cloneNode(<span class=\"literal\">true</span>);</span><br><span class=\"line\">appendDataToElement(clone, data);</span><br><span class=\"line\">old.parentNode.replaceChild(clone, old);</span><br></pre></td></tr></table></figure>\n<p>文章中是推荐我们使用第二种方法，因为这种方法本来设计的初衷就是为了解决这类任务的（更新和移动节点）。而且这种方法只触发一次重拍，只访问一次DOM节点。</p>\n<p>既然说到了重绘和重排，顺便就说一下动画，在动画中我们可以尽量使用<code>transform</code>和<code>opacity</code>，因为他们会不会触发重绘。具体可以看看这两篇文章：</p>\n<ol>\n<li><a href=\"http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html\" target=\"_blank\" rel=\"external\">CSS动画之硬件加速</a></li>\n<li><a href=\"http://zencode.in/14.CSS%E5%8A%A8%E7%94%BB%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html\" target=\"_blank\" rel=\"external\">CSS动画的性能优化</a></li>\n</ol>\n","excerpt":"","more":"<h3 id=\"重绘与重排\"><a href=\"#重绘与重排\" class=\"headerlink\" title=\"重绘与重排\"></a>重绘与重排</h3><p>最近看了一本书《高性能JavaScript》，里面有很多有用的代码片段，后面我准备把一些摘抄记录下来。</p>\n<p>今天主要想说说重绘与重排，这个也是《高性能JavaScript》中讲的一部分，我来总结一下吧。</p>\n<p>首先先要了解一下浏览器渲染页面的过程，当浏览器下载完页面所需要的html、css、js和图片等后就会开始解析并生成两个内部的数据结构：DOM树和渲染树。<br>DOM树是表示页面的结构，渲染树是表示DOM节点如何显示。</p>\n<p>DOM树不必多说，渲染树会结合DOM树和DOM节点对应的CSS样式去理解页面上每个元素的样式（比如内外边距，边框，位置等），去构建一个渲染树。渲染树完成后浏览器就开始绘制（paint）页面元素。</p>\n<p>关于这部分可以看这个链接<a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn\">渲染树构建、布局及绘制\n</a></p>\n<p>当DOM树的结构和CSS产生变化影响到页面布局或元素的几何属性的时候，浏览器会重新构建渲染树，重新构建渲染树的过程就叫做<code>重排（reflow）</code>，重排完成后，浏览器会重新绘制受到影响的部分到屏幕中，这个过程叫做<code>重绘（repaint）</code>。</p>\n<p>并不是所有的变化都会影响到页面布局和元素的几何属性（即发生重排），下面的情况会发生重排：</p>\n<ul>\n<li>添加和删除可见的DOM元素。</li>\n<li>元素位置改变。</li>\n<li>元素尺寸改变（内外边距，边框厚度，宽高等）。</li>\n<li>内容改变（文本改变，图片尺寸改变）。</li>\n<li>浏览器窗口尺寸变化。</li>\n<li>页面渲染器初始化。</li>\n</ul>\n<p>不改变页面布局和元素几何属性的变化（比如背景色变化），只会发生一次重绘，并不会发生重排。</p>\n<h3 id=\"减少重绘与重排\"><a href=\"#减少重绘与重排\" class=\"headerlink\" title=\"减少重绘与重排\"></a>减少重绘与重排</h3><p>因为重绘和重排需要大量计算，会影响页面的响应速度，所以我们应该尽量减少和避免重绘和重排。</p>\n<h4 id=\"改变样式\"><a href=\"#改变样式\" class=\"headerlink\" title=\"改变样式\"></a>改变样式</h4><p>看下面这段代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> el = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mydiv'</span>);</span><br><span class=\"line\">el.style.borderLeft = <span class=\"string\">'1px'</span>; </span><br><span class=\"line\">el.style.borderRight = <span class=\"string\">'2px'</span>;</span><br><span class=\"line\">el.style.padding = <span class=\"string\">'5px'</span>;</span><br></pre></td></tr></table></figure>\n<p>这样添加样式，每一次都会改变元素的几何属性，在一些旧版浏览器中可能会引起三次重排（现代浏览器会做优化处理，发生一次重排），所以可以优化一下代码，合并样式一次性修改：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> el = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mydiv'</span>);</span><br><span class=\"line\"><span class=\"comment\">//替换样式</span></span><br><span class=\"line\">el.style.cssText = <span class=\"string\">'border-left: 1px; border-right: 2px; padding: 5px;'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//保留原有样式</span></span><br><span class=\"line\">el.style.cssText += <span class=\"string\">'; border-left: 1px;'</span>;</span><br></pre></td></tr></table></figure>\n<p>这样修改只会引起一次重排，更为高效。还有一种做法就是为想要修改的部分添加一个<code>class</code>使用css一次性修改。</p>\n<h4 id=\"批量修改DOM\"><a href=\"#批量修改DOM\" class=\"headerlink\" title=\"批量修改DOM\"></a>批量修改DOM</h4><p>如果我们需要对DOM进行一系列操作的时候，可以通过下面的做法来减少重绘和重排：</p>\n<ol>\n<li>使元素脱离文档流。</li>\n<li>对其进行操作。</li>\n<li>把元素带回文档中。</li>\n</ol>\n<p>这样如果我们在第二步进行多次操作时，也只会在第一步和第三步触发两次重排。</p>\n<p>有三种基本方法可以使DOM脱离文档流:</p>\n<ol>\n<li>隐藏元素，修改，重新显示。</li>\n<li>使用文档片断（document fragment），在当前DOM外构建一个子树，再把它插入文档中。</li>\n<li>把原始元素拷贝到脱离文档的节点中，修改后在把原始元素替换掉。</li>\n</ol>\n<p>用代码来说明三种方法：</p>\n<p>比如现在我们有一个<code>ul</code>列表，我们用一个方法<code>appendDataElement()</code>往列表中添加<code>li</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//要操作的列表</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mylist'</span>);</span><br><span class=\"line\"><span class=\"comment\">//向列表中添加li，data是li中的内容</span></span><br><span class=\"line\">appendDataToElement(ul, data);</span><br></pre></td></tr></table></figure>\n<p>如果我们不使用任何方法的话，每插入一个<code>li</code>就会触发一次重排，这样是很影响性能的。所以我们可以使用上面的三种方法。</p>\n<p>方法一：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ul = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mylist'</span>);</span><br><span class=\"line\">ul.style.display = <span class=\"string\">'none'</span>; </span><br><span class=\"line\">appendDataToElement(ul, data);</span><br><span class=\"line\">ul.style.display = <span class=\"string\">'block'</span>;</span><br></pre></td></tr></table></figure>\n<p>方法二：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();</span><br><span class=\"line\">appendDataToElement(fragment, data);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mylist'</span>).appendChild(fragment);</span><br></pre></td></tr></table></figure>\n<p>方法三：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> old = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'mylist'</span>); </span><br><span class=\"line\"><span class=\"keyword\">var</span> clone = old.cloneNode(<span class=\"literal\">true</span>);</span><br><span class=\"line\">appendDataToElement(clone, data);</span><br><span class=\"line\">old.parentNode.replaceChild(clone, old);</span><br></pre></td></tr></table></figure>\n<p>文章中是推荐我们使用第二种方法，因为这种方法本来设计的初衷就是为了解决这类任务的（更新和移动节点）。而且这种方法只触发一次重拍，只访问一次DOM节点。</p>\n<p>既然说到了重绘和重排，顺便就说一下动画，在动画中我们可以尽量使用<code>transform</code>和<code>opacity</code>，因为他们会不会触发重绘。具体可以看看这两篇文章：</p>\n<ol>\n<li><a href=\"http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html\">CSS动画之硬件加速</a></li>\n<li><a href=\"http://zencode.in/14.CSS%E5%8A%A8%E7%94%BB%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html\">CSS动画的性能优化</a></li>\n</ol>\n"},{"layout":"post","title":"vue初体验","date":"2016-05-05T16:00:00.000Z","_content":"\n最近QA提了一个问题，我原来做的[到账记录的页面](http://www.yatessss.com/2016/02/19/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93.html)从列表页点进详情页之后返回列表页的时候不能返回到之前进去的位置。当时写这个页面的时候也遇到了一些问题，具体可以看这里[到账记录的页面](http://www.yatessss.com/2016/02/19/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93.html)。\n\n因为当时做到账记录这个页面时是两个页面，列表页是通过接口的数据生成的，页面并不会缓存，进入详情页返回列表页时数据要重新请求，所以不能回到当时的位置。正好最近公司准备开始使用vue，所以我就用vue重构了这个页面，vue自带路由，因为是单页面所以列表页也可以保存起来。\n\n用了一次vue就会觉得他很方便，用vue就不需要再使用模板来渲染页面了，他自带过滤器功能在渲染模板的时候就可以过滤字符串，自带路由功能。\n\n先给出两个文档的地址，一个是[vue的文档](http://vuejs.org.cn/guide/)，另一个是[vue的官方路由组件的文档](http://vuejs.github.io/vue-router/zh-cn/basic.html)。这里写的非常的详细，在这里可以找到所有的答案。\n\n说说过程中的经验。\n\n### vue在编写组件的时候，也支持使用模板。\n\n在html中可以像用模板语言那样，写一个`script`标签，定义一个`id`，在这个标签内写相应的组件的html。\n\n```html\n<script id=\"list-template\" type=\"text/x-template\">\n.....\n</script>\n```\n然后在js的组件内引用这个模板就可以了。\n\n```js\nvar List = Vue.extend({\n\ttemplate: '#list-template'\n})\n```\n\n### 传递参数\n\n整个到账做成了一个页面，就会包含列表和详情两个组件。原来是两个页面的时候是使用url来传递参数（比如详情页要使用列表页的单号来请求后台接口），现在传递参数会有两种方法：\n\n1. 因为路由需要一个根组件，可以在根组件上定义一个变量，点击列表组件的时候把单号传到根组件的变量中，在详情组件中取根组件的这个变量，得到单号。\n2. 就是用sessionStorage，在点击列表时绑定一个事件，把单号存到sessionStorage中。\n\n我是选择用第二种办法，因为他过程更方便，容易理解。在组件中都会有生命周期（可以看路由组件的文档），在组件创建的时候就从sessionStorage中取单号就可以了。\n\n需求中的列表返回到进入时的位置其实也是用sessionStorage实现的。\n\n### 下拉加载\n\n使用的下拉加载和原来的页面没有区别，都是给window绑定一个监听事件，监听滚动条的高度判断是否到页面的底部，然后去加载列表。\n\n但是在单页面中，需要注意如果监听事件一直存在的话，进入详情页后下拉到底部还是会加载列表，所以在列表页的`deactivate`的生命周期中需要把监听事件去掉，在`activate`的时候再继续去监听。\n\n### 页面加载慢\n\n在进入详情页后，如果后台返回数据过多，页面渲染会很受影响，在性能比较差的手机上可能会导致卡死或者app崩溃。这是因为后台一次性返回的数据太多，当反应这个问题后，后台由于其他业务的关系不能添加分页的功能，但是由前端自己也可以实现分布加载数据的功能（当然这是在万不得已的情况下，其实最好还是做分页）。\n\n首先后台返回了一个很长的数组，我们需要的是把他缓存起来，首次渲染时只渲染一部分，在页面到达底部的时候再去加载。因为是单页面，不存在刷新的问题，所以把数据缓存在js的一个变量当中就可以了。\n\n```js\n/*\n *detaillist: [], //整个列表缓存\n *load_list : [], //初次加载的列表\n *page_count: 30, // 分页大小\n *this_page: 0,   // 当前页\n*/\npushData: function() {\n\tvar _this = this;\n\tvar len = _this.detaillist.length;\n\tfor(var i = 0; i < _this.page_count && (_this.load_list.length < len) ; i++){\n\t\t_this.load_list.push(_this.detaillist[_this.page_count * _this.this_page + i]);\n\t};\n\t_this.this_page++\n}\n```\n\n这个是详情页到底部时所执行的方法。有一点需要注意，就是在详情组件每次`activate`的生命周期的时候，需要把数据都重置，因为如果没有重置数据的话，变量里保存的还是原来的数组，渲染页面时数据就不对了。重置可以先一个函数来实现。\n\n```js\ninit : function(){\n\tthis.$set('monthfee', '');\n\tthis.$set('totalfee', 0);\n\tthis.$set('totalmoney', '');\n\tthis.$set('feedetail', '');\n\tthis.$set('load_list', []);\n\tthis.$set('this_page', 0);\n\tthis.$set('detaillist', []);\n}\n```\n\n*这种方法有弊端，就是如果详情的数据特别特别多，这个页面就会越来越大，越来越卡，有另一种可以动态加载无限列表的库，[iscroll-infinite.js](https://github.com/cubiq/iscroll)，他可以不断的操作DOM来添加和删除列表。","source":"_posts/2016-05-06-vue初体验.md","raw":"---\nlayout: post\ntitle: vue初体验\ndate: 2016-05-06\ntags: ['vue']\ncategories: vue\t\n---\n\n最近QA提了一个问题，我原来做的[到账记录的页面](http://www.yatessss.com/2016/02/19/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93.html)从列表页点进详情页之后返回列表页的时候不能返回到之前进去的位置。当时写这个页面的时候也遇到了一些问题，具体可以看这里[到账记录的页面](http://www.yatessss.com/2016/02/19/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93.html)。\n\n因为当时做到账记录这个页面时是两个页面，列表页是通过接口的数据生成的，页面并不会缓存，进入详情页返回列表页时数据要重新请求，所以不能回到当时的位置。正好最近公司准备开始使用vue，所以我就用vue重构了这个页面，vue自带路由，因为是单页面所以列表页也可以保存起来。\n\n用了一次vue就会觉得他很方便，用vue就不需要再使用模板来渲染页面了，他自带过滤器功能在渲染模板的时候就可以过滤字符串，自带路由功能。\n\n先给出两个文档的地址，一个是[vue的文档](http://vuejs.org.cn/guide/)，另一个是[vue的官方路由组件的文档](http://vuejs.github.io/vue-router/zh-cn/basic.html)。这里写的非常的详细，在这里可以找到所有的答案。\n\n说说过程中的经验。\n\n### vue在编写组件的时候，也支持使用模板。\n\n在html中可以像用模板语言那样，写一个`script`标签，定义一个`id`，在这个标签内写相应的组件的html。\n\n```html\n<script id=\"list-template\" type=\"text/x-template\">\n.....\n</script>\n```\n然后在js的组件内引用这个模板就可以了。\n\n```js\nvar List = Vue.extend({\n\ttemplate: '#list-template'\n})\n```\n\n### 传递参数\n\n整个到账做成了一个页面，就会包含列表和详情两个组件。原来是两个页面的时候是使用url来传递参数（比如详情页要使用列表页的单号来请求后台接口），现在传递参数会有两种方法：\n\n1. 因为路由需要一个根组件，可以在根组件上定义一个变量，点击列表组件的时候把单号传到根组件的变量中，在详情组件中取根组件的这个变量，得到单号。\n2. 就是用sessionStorage，在点击列表时绑定一个事件，把单号存到sessionStorage中。\n\n我是选择用第二种办法，因为他过程更方便，容易理解。在组件中都会有生命周期（可以看路由组件的文档），在组件创建的时候就从sessionStorage中取单号就可以了。\n\n需求中的列表返回到进入时的位置其实也是用sessionStorage实现的。\n\n### 下拉加载\n\n使用的下拉加载和原来的页面没有区别，都是给window绑定一个监听事件，监听滚动条的高度判断是否到页面的底部，然后去加载列表。\n\n但是在单页面中，需要注意如果监听事件一直存在的话，进入详情页后下拉到底部还是会加载列表，所以在列表页的`deactivate`的生命周期中需要把监听事件去掉，在`activate`的时候再继续去监听。\n\n### 页面加载慢\n\n在进入详情页后，如果后台返回数据过多，页面渲染会很受影响，在性能比较差的手机上可能会导致卡死或者app崩溃。这是因为后台一次性返回的数据太多，当反应这个问题后，后台由于其他业务的关系不能添加分页的功能，但是由前端自己也可以实现分布加载数据的功能（当然这是在万不得已的情况下，其实最好还是做分页）。\n\n首先后台返回了一个很长的数组，我们需要的是把他缓存起来，首次渲染时只渲染一部分，在页面到达底部的时候再去加载。因为是单页面，不存在刷新的问题，所以把数据缓存在js的一个变量当中就可以了。\n\n```js\n/*\n *detaillist: [], //整个列表缓存\n *load_list : [], //初次加载的列表\n *page_count: 30, // 分页大小\n *this_page: 0,   // 当前页\n*/\npushData: function() {\n\tvar _this = this;\n\tvar len = _this.detaillist.length;\n\tfor(var i = 0; i < _this.page_count && (_this.load_list.length < len) ; i++){\n\t\t_this.load_list.push(_this.detaillist[_this.page_count * _this.this_page + i]);\n\t};\n\t_this.this_page++\n}\n```\n\n这个是详情页到底部时所执行的方法。有一点需要注意，就是在详情组件每次`activate`的生命周期的时候，需要把数据都重置，因为如果没有重置数据的话，变量里保存的还是原来的数组，渲染页面时数据就不对了。重置可以先一个函数来实现。\n\n```js\ninit : function(){\n\tthis.$set('monthfee', '');\n\tthis.$set('totalfee', 0);\n\tthis.$set('totalmoney', '');\n\tthis.$set('feedetail', '');\n\tthis.$set('load_list', []);\n\tthis.$set('this_page', 0);\n\tthis.$set('detaillist', []);\n}\n```\n\n*这种方法有弊端，就是如果详情的数据特别特别多，这个页面就会越来越大，越来越卡，有另一种可以动态加载无限列表的库，[iscroll-infinite.js](https://github.com/cubiq/iscroll)，他可以不断的操作DOM来添加和删除列表。","slug":"vue初体验","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1zo0029sq5l9frg5p9m","content":"<p>最近QA提了一个问题，我原来做的<a href=\"http://www.yatessss.com/2016/02/19/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93.html\">到账记录的页面</a>从列表页点进详情页之后返回列表页的时候不能返回到之前进去的位置。当时写这个页面的时候也遇到了一些问题，具体可以看这里<a href=\"http://www.yatessss.com/2016/02/19/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93.html\">到账记录的页面</a>。</p>\n<p>因为当时做到账记录这个页面时是两个页面，列表页是通过接口的数据生成的，页面并不会缓存，进入详情页返回列表页时数据要重新请求，所以不能回到当时的位置。正好最近公司准备开始使用vue，所以我就用vue重构了这个页面，vue自带路由，因为是单页面所以列表页也可以保存起来。</p>\n<p>用了一次vue就会觉得他很方便，用vue就不需要再使用模板来渲染页面了，他自带过滤器功能在渲染模板的时候就可以过滤字符串，自带路由功能。</p>\n<p>先给出两个文档的地址，一个是<a href=\"http://vuejs.org.cn/guide/\" target=\"_blank\" rel=\"external\">vue的文档</a>，另一个是<a href=\"http://vuejs.github.io/vue-router/zh-cn/basic.html\" target=\"_blank\" rel=\"external\">vue的官方路由组件的文档</a>。这里写的非常的详细，在这里可以找到所有的答案。</p>\n<p>说说过程中的经验。</p>\n<h3 id=\"vue在编写组件的时候，也支持使用模板。\"><a href=\"#vue在编写组件的时候，也支持使用模板。\" class=\"headerlink\" title=\"vue在编写组件的时候，也支持使用模板。\"></a>vue在编写组件的时候，也支持使用模板。</h3><p>在html中可以像用模板语言那样，写一个<code>script</code>标签，定义一个<code>id</code>，在这个标签内写相应的组件的html。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">id</span>=<span class=\"string\">\"list-template\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/x-template\"</span>&gt;</span><span class=\"undefined\"></span><br><span class=\"line\">.....</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在js的组件内引用这个模板就可以了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> List = Vue.extend(&#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'#list-template'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h3><p>整个到账做成了一个页面，就会包含列表和详情两个组件。原来是两个页面的时候是使用url来传递参数（比如详情页要使用列表页的单号来请求后台接口），现在传递参数会有两种方法：</p>\n<ol>\n<li>因为路由需要一个根组件，可以在根组件上定义一个变量，点击列表组件的时候把单号传到根组件的变量中，在详情组件中取根组件的这个变量，得到单号。</li>\n<li>就是用sessionStorage，在点击列表时绑定一个事件，把单号存到sessionStorage中。</li>\n</ol>\n<p>我是选择用第二种办法，因为他过程更方便，容易理解。在组件中都会有生命周期（可以看路由组件的文档），在组件创建的时候就从sessionStorage中取单号就可以了。</p>\n<p>需求中的列表返回到进入时的位置其实也是用sessionStorage实现的。</p>\n<h3 id=\"下拉加载\"><a href=\"#下拉加载\" class=\"headerlink\" title=\"下拉加载\"></a>下拉加载</h3><p>使用的下拉加载和原来的页面没有区别，都是给window绑定一个监听事件，监听滚动条的高度判断是否到页面的底部，然后去加载列表。</p>\n<p>但是在单页面中，需要注意如果监听事件一直存在的话，进入详情页后下拉到底部还是会加载列表，所以在列表页的<code>deactivate</code>的生命周期中需要把监听事件去掉，在<code>activate</code>的时候再继续去监听。</p>\n<h3 id=\"页面加载慢\"><a href=\"#页面加载慢\" class=\"headerlink\" title=\"页面加载慢\"></a>页面加载慢</h3><p>在进入详情页后，如果后台返回数据过多，页面渲染会很受影响，在性能比较差的手机上可能会导致卡死或者app崩溃。这是因为后台一次性返回的数据太多，当反应这个问题后，后台由于其他业务的关系不能添加分页的功能，但是由前端自己也可以实现分布加载数据的功能（当然这是在万不得已的情况下，其实最好还是做分页）。</p>\n<p>首先后台返回了一个很长的数组，我们需要的是把他缓存起来，首次渲染时只渲染一部分，在页面到达底部的时候再去加载。因为是单页面，不存在刷新的问题，所以把数据缓存在js的一个变量当中就可以了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\"> *detaillist: [], //整个列表缓存</span><br><span class=\"line\"> *load_list : [], //初次加载的列表</span><br><span class=\"line\"> *page_count: 30, // 分页大小</span><br><span class=\"line\"> *this_page: 0,   // 当前页</span><br><span class=\"line\">*/</span></span><br><span class=\"line\">pushData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> len = _this.detaillist.length;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; _this.page_count &amp;&amp; (_this.load_list.length &lt; len) ; i++)&#123;</span><br><span class=\"line\">\t\t_this.load_list.push(_this.detaillist[_this.page_count * _this.this_page + i]);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t_this.this_page++</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个是详情页到底部时所执行的方法。有一点需要注意，就是在详情组件每次<code>activate</code>的生命周期的时候，需要把数据都重置，因为如果没有重置数据的话，变量里保存的还是原来的数组，渲染页面时数据就不对了。重置可以先一个函数来实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'monthfee'</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'totalfee'</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'totalmoney'</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'feedetail'</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'load_list'</span>, []);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'this_page'</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'detaillist'</span>, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>*这种方法有弊端，就是如果详情的数据特别特别多，这个页面就会越来越大，越来越卡，有另一种可以动态加载无限列表的库，<a href=\"https://github.com/cubiq/iscroll\" target=\"_blank\" rel=\"external\">iscroll-infinite.js</a>，他可以不断的操作DOM来添加和删除列表。</p>\n","excerpt":"","more":"<p>最近QA提了一个问题，我原来做的<a href=\"http://www.yatessss.com/2016/02/19/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93.html\">到账记录的页面</a>从列表页点进详情页之后返回列表页的时候不能返回到之前进去的位置。当时写这个页面的时候也遇到了一些问题，具体可以看这里<a href=\"http://www.yatessss.com/2016/02/19/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93.html\">到账记录的页面</a>。</p>\n<p>因为当时做到账记录这个页面时是两个页面，列表页是通过接口的数据生成的，页面并不会缓存，进入详情页返回列表页时数据要重新请求，所以不能回到当时的位置。正好最近公司准备开始使用vue，所以我就用vue重构了这个页面，vue自带路由，因为是单页面所以列表页也可以保存起来。</p>\n<p>用了一次vue就会觉得他很方便，用vue就不需要再使用模板来渲染页面了，他自带过滤器功能在渲染模板的时候就可以过滤字符串，自带路由功能。</p>\n<p>先给出两个文档的地址，一个是<a href=\"http://vuejs.org.cn/guide/\">vue的文档</a>，另一个是<a href=\"http://vuejs.github.io/vue-router/zh-cn/basic.html\">vue的官方路由组件的文档</a>。这里写的非常的详细，在这里可以找到所有的答案。</p>\n<p>说说过程中的经验。</p>\n<h3 id=\"vue在编写组件的时候，也支持使用模板。\"><a href=\"#vue在编写组件的时候，也支持使用模板。\" class=\"headerlink\" title=\"vue在编写组件的时候，也支持使用模板。\"></a>vue在编写组件的时候，也支持使用模板。</h3><p>在html中可以像用模板语言那样，写一个<code>script</code>标签，定义一个<code>id</code>，在这个标签内写相应的组件的html。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">id</span>=<span class=\"string\">\"list-template\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/x-template\"</span>&gt;</span><span class=\"undefined\"></span><br><span class=\"line\">.....</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在js的组件内引用这个模板就可以了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> List = Vue.extend(&#123;</span><br><span class=\"line\">\ttemplate: <span class=\"string\">'#list-template'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"传递参数\"><a href=\"#传递参数\" class=\"headerlink\" title=\"传递参数\"></a>传递参数</h3><p>整个到账做成了一个页面，就会包含列表和详情两个组件。原来是两个页面的时候是使用url来传递参数（比如详情页要使用列表页的单号来请求后台接口），现在传递参数会有两种方法：</p>\n<ol>\n<li>因为路由需要一个根组件，可以在根组件上定义一个变量，点击列表组件的时候把单号传到根组件的变量中，在详情组件中取根组件的这个变量，得到单号。</li>\n<li>就是用sessionStorage，在点击列表时绑定一个事件，把单号存到sessionStorage中。</li>\n</ol>\n<p>我是选择用第二种办法，因为他过程更方便，容易理解。在组件中都会有生命周期（可以看路由组件的文档），在组件创建的时候就从sessionStorage中取单号就可以了。</p>\n<p>需求中的列表返回到进入时的位置其实也是用sessionStorage实现的。</p>\n<h3 id=\"下拉加载\"><a href=\"#下拉加载\" class=\"headerlink\" title=\"下拉加载\"></a>下拉加载</h3><p>使用的下拉加载和原来的页面没有区别，都是给window绑定一个监听事件，监听滚动条的高度判断是否到页面的底部，然后去加载列表。</p>\n<p>但是在单页面中，需要注意如果监听事件一直存在的话，进入详情页后下拉到底部还是会加载列表，所以在列表页的<code>deactivate</code>的生命周期中需要把监听事件去掉，在<code>activate</code>的时候再继续去监听。</p>\n<h3 id=\"页面加载慢\"><a href=\"#页面加载慢\" class=\"headerlink\" title=\"页面加载慢\"></a>页面加载慢</h3><p>在进入详情页后，如果后台返回数据过多，页面渲染会很受影响，在性能比较差的手机上可能会导致卡死或者app崩溃。这是因为后台一次性返回的数据太多，当反应这个问题后，后台由于其他业务的关系不能添加分页的功能，但是由前端自己也可以实现分布加载数据的功能（当然这是在万不得已的情况下，其实最好还是做分页）。</p>\n<p>首先后台返回了一个很长的数组，我们需要的是把他缓存起来，首次渲染时只渲染一部分，在页面到达底部的时候再去加载。因为是单页面，不存在刷新的问题，所以把数据缓存在js的一个变量当中就可以了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\"> *detaillist: [], //整个列表缓存</span><br><span class=\"line\"> *load_list : [], //初次加载的列表</span><br><span class=\"line\"> *page_count: 30, // 分页大小</span><br><span class=\"line\"> *this_page: 0,   // 当前页</span><br><span class=\"line\">*/</span></span><br><span class=\"line\">pushData: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> len = _this.detaillist.length;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; _this.page_count &amp;&amp; (_this.load_list.length &lt; len) ; i++)&#123;</span><br><span class=\"line\">\t\t_this.load_list.push(_this.detaillist[_this.page_count * _this.this_page + i]);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t_this.this_page++</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个是详情页到底部时所执行的方法。有一点需要注意，就是在详情组件每次<code>activate</code>的生命周期的时候，需要把数据都重置，因为如果没有重置数据的话，变量里保存的还是原来的数组，渲染页面时数据就不对了。重置可以先一个函数来实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'monthfee'</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'totalfee'</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'totalmoney'</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'feedetail'</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'load_list'</span>, []);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'this_page'</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.$set(<span class=\"string\">'detaillist'</span>, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>*这种方法有弊端，就是如果详情的数据特别特别多，这个页面就会越来越大，越来越卡，有另一种可以动态加载无限列表的库，<a href=\"https://github.com/cubiq/iscroll\">iscroll-infinite.js</a>，他可以不断的操作DOM来添加和删除列表。</p>\n"},{"layout":"post","title":"webstorm项目下文件夹消失","date":"2016-05-16T16:00:00.000Z","_content":"\n大概情况就是webstorm打开项目后，文件夹都会消失，并且文件夹都会变到左上方，不会像正常情况一样，呈现一个树状的目录结构。[解决地址](http://stackoverflow.com/questions/9302346/folders-missing-in-project-pane-in-webstorm)\n\n具体办法就是：\n1. `cd`进入项目当前的目录\n2. `ls -a`找到`.idea`这个文件夹\n3. `rm -r .idea`删除这个文件夹\n4. 重新打开项目就好啦~","source":"_posts/2016-05-17-webstorm项目下文件夹消失.md.md","raw":"---\nlayout: post\ntitle: webstorm项目下文件夹消失\ndate: 2016-05-17\ntags: ['webstorm']\ncategories: webstorm\t\n---\n\n大概情况就是webstorm打开项目后，文件夹都会消失，并且文件夹都会变到左上方，不会像正常情况一样，呈现一个树状的目录结构。[解决地址](http://stackoverflow.com/questions/9302346/folders-missing-in-project-pane-in-webstorm)\n\n具体办法就是：\n1. `cd`进入项目当前的目录\n2. `ls -a`找到`.idea`这个文件夹\n3. `rm -r .idea`删除这个文件夹\n4. 重新打开项目就好啦~","slug":"webstorm项目下文件夹消失.md","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1zp002csq5ljpbgrsra","content":"<p>大概情况就是webstorm打开项目后，文件夹都会消失，并且文件夹都会变到左上方，不会像正常情况一样，呈现一个树状的目录结构。<a href=\"http://stackoverflow.com/questions/9302346/folders-missing-in-project-pane-in-webstorm\" target=\"_blank\" rel=\"external\">解决地址</a></p>\n<p>具体办法就是：</p>\n<ol>\n<li><code>cd</code>进入项目当前的目录</li>\n<li><code>ls -a</code>找到<code>.idea</code>这个文件夹</li>\n<li><code>rm -r .idea</code>删除这个文件夹</li>\n<li>重新打开项目就好啦~</li>\n</ol>\n","excerpt":"","more":"<p>大概情况就是webstorm打开项目后，文件夹都会消失，并且文件夹都会变到左上方，不会像正常情况一样，呈现一个树状的目录结构。<a href=\"http://stackoverflow.com/questions/9302346/folders-missing-in-project-pane-in-webstorm\">解决地址</a></p>\n<p>具体办法就是：</p>\n<ol>\n<li><code>cd</code>进入项目当前的目录</li>\n<li><code>ls -a</code>找到<code>.idea</code>这个文件夹</li>\n<li><code>rm -r .idea</code>删除这个文件夹</li>\n<li>重新打开项目就好啦~</li>\n</ol>\n"},{"layout":"post","title":"使用vue完成上传文件页面","date":"2016-06-07T16:00:00.000Z","_content":"\n### 需求描述\n\n最近加班加点完成了一个上传文件的需求，听起来很简单想着也很简单，但是知易行难实际操作起来，还是遇到了很多问题，现在就来总结一下，使用vue来构建一个上传文件的页面中会遇到哪些问题，其中的一些问题也可能是用别的框架也会遇到的问题。\n\n平台：主要是在安卓和苹果的微信webview中运行。\n\n先来看下主要的技术点：\n\n1. 父子组件的动态渲染\n2. 初始化数据和判断数据\n3. input表单隐藏联动\n4. 上传图片后可以预览\n\n遇到的问题：\n\n1. 在iPhone中，click()事件无效\n2. 在微信安卓webview中，img标签使用background属性无效\n3. 预览上传图片保证宽高比\n4. 在某些安卓机型用rem单位不显示边框\n\n设计图大概是这样的：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_06_pic_1.png)\n\n完成后的效果是这样：\n\n1. 首先登陆后，如果没有选择两个选项的话提交按钮点击不了并会有提示\n2. 当选择图片后，下面会显示选择图片的缩略图\n3. 当点击提交后，会显示loading成功后会刷新页面\n4. 提交过的部分不会显示示意图会改为一张提示图片，刚上传过所有图片时会提示已经上传过所有图片\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_2.gif)\n\n大概就是这么一个步骤流程吧。\n\n### 技术点分析\n\n这个页面主要使用的UI包括：提示、loading、选项栏等都是从WEUI样式库中扒出来的，因为是在微信公众号中使用的，体验上会一致。上传部分使用的是post表单上传，我把form表单隐藏了起来，通过模拟上传按钮，当点击上传按钮的时候同步触发表单中的input type=‘file’标签，调起原生的选择图片的界面，选择图片后，点击上传按钮的同时触发一个post请求把图片传到后台，完成整个功能。\n\n#### 父子组件的动态渲染\n\n可以从设计图看出上传图片的部分基本上设计是一样的，所以用一个vue组件来复用是最好的，顺便说一下这个页面用到了三个组件，一个是dialog提示的组件，一个是loading的组件，还有一个就是上传这部分用到的组件。\n\n主要说一下上传部分的组件，在vue中，子父组件要传递的参数需要在子组件的props中声明，下面是我的组件中的模板，我主要用到了以下参数：\n\n```js\n<template>\n  <div class=\"com-box\">\n    <h3 v-if=\"comTitle\" class=\"com-title\">{{comTitle}}</h3>\n    <div class=\"upload-box\">\n      <h2>{{nameCn}}</h2>\n      <div class=\"img-box\" id=\"{{nameId}}\" :style=\"bgUrl\">\n        <!--<img :src=\"imgUrl\">-->\n      </div>\n      <p class=\"tip\" v-if=\"tip\">{{tip}}</p>\n      <!--<div v-if=\"isUpload\" class=\"upload-btn upload-true\">图片已提交</div>-->\n      <div v-if=\"!isUpload\" class=\"upload-btn upload-false clickable-div\" onclick=\"document.querySelector('input').click()\" @click=\"inputBtn(name, $event)\">上传图片</div>\n    </div>\n  </div>\n</template>\n\n<script>\n/*\n* name：主要是让input表单和组件通过id产生关联\n* nameCn：组件的title\n* imgUrl：（最后弃用但没有删掉）\n* isUpload： 标识有没有上传，这个会在父组件中进行判断，如果已经上传了会把上传按钮隐藏掉\n* tip：图片下部的说明文字\n* bgUrl：默认的说明背景图，上传完成后会在父组件中更改这个图片改成一张上传完成的提示图\n*/\nprops: ['name', 'nameCn', 'imgUrl', 'isUpload', 'tip', 'bgUrl', 'comTitle']，\ncomputed: {\n  nameId () {\n    return this.name + 'content'\n  }\n}\n</script>\n```\n\n然后在父组件中我们可以引入这个组件，并声明它，然后在标签中把子组件需要用到的参数传递进去就好了。我这里是使用了`v-for`去遍历了一个`result_data`的数组，把所有需要上传的组件遍历渲染了出来。如下：\n\n```js\n<template>\n\t<upload v-for=\"(index, item) in result_data\" :name=\"item.name\" :name-cn=\"item.nameCn\" :bg-url=\"item.bgUrl\" :img-url=\"item.imgUrl\" :tip=\"item.tip\" :is-upload=\"item.isUpload\" :com-title=\"item.comTitle\"> </upload>\n</template>\n\n<script>\n  import upload from './upload.vue'\n  components: {\n      upload\n    },\n</script>\n\n```\n\n这样子父组件就可以传递数据了，具体的大家可以去看一下官方的文档。\n\n#### 初始化数据和判断数据\n\n这是这个任务里最坑的一个部分。因为后台只会把已经上传过图片的字段告诉我，所以我需要在前端去造一些初始化的数据，去和后台返回回来的比较，再去判断哪些上传过需要展示出来，那些没上传需要上传。\n\n注意：可以造数据的前提是，数据量不是很大，且数据是固定的。其实最好是后台可以完成这些判断，因为前端本就不应该去处理数据方面的逻辑。\n\n我初始化的数据大概是这个样子的：\n\n```js\ninit_data: [\n//          0\n  {\n    name: 'shopphoto',\n    nameCn: '店铺门头照片',\n    bgUrl: {\n      backgroundImage: \"url('http://near.m1img.com/op_upload/62/146502860635.jpg')\",\n      backgroundSize: '100% 100%'\n    },\n    imgUrl: '',\n    tip: '',\n    isUpload: false\n  },\n\t\n//          1\n  {\n    name: 'goodsphoto',\n    nameCn: '店铺内景照片',\n    bgUrl: {\n      backgroundImage: \"url('http://near.m1img.com/op_upload/62/146502865726.jpg')\",\n      backgroundSize: '100% 100%'\n    },\n    imgUrl: '',\n    tip: '',\n    isUpload: false\n  }\n]\n```\n\n然后我去遍历后台返回的那个数组和我自己初始化得数组，用`name`这个字段产生关联去比较，因为后台只返回了上传过图片的字段，所以我就可以判断出哪些是没有上传的部分。判断的逻辑如下：\n\n```js\ncompareArr (oldArr, newArr) {\n    var _this = this\n    var _oldArr = oldArr\n    var _newArr = newArr\n    for (let i = 0, len1 = _newArr.length; i < len1; i++) {\n      for (let j = 0, len2 = _oldArr.length; j < len2; j++) {\n        if (_newArr[i].name === _oldArr[j].name) {\n          let initData = _this.init_data\n          initData[i].bgUrl = {\n            backgroundImage: \"url('http://near.m1img.com/op_upload/62/146520417256.png')\",\n            backgroundSize: '100% 100%'\n          }\n          initData[i].isUpload = true\n          _this.$set('init_data', initData)\n        }\n      }\n    }\n  }\n```\n\n我会给这个方法传入两个数组。oldArr是后台的数组，newArr是我自己初始化的数组。\n循环遍历比较两个数组，把我自己初始化的数据做出一些修改，主要是提示图片和是否上传标识字段的更改。\n\n#### input表单隐藏联动\n\n这个逻辑也不是很复杂，就是在点击上传按钮的时候，调一个方法，在方法中选择到对应的`input`标签出发一个`click()`事件，主要是在iphone上面，可能会不支持input type=‘file’的标签，这里有一个坑，在网上找到了一些解决办法，但是试了一下没有效果，最后自己试验了一下找到了一个解决办法，在下面遇到的问题中会叙述。\n\n第二是要注意在form表单中要禁止事件冒泡，不然你点击一次input表单就会提交一次。\n\n#### 上传图片后可以预览\n\n可以我是汲取了广大人民的智慧。。。\n\n主要思路就是把图片读取成一个base64格式，然后再把他装到一个img标签中。实现预览功能，这里我给几个参考的资料，有的demo直接就可以跑，改一改就可以运用到自己的项目中。\n\n1. [移动前端—图片压缩上传实践](http://www.cnblogs.com/axes/p/4603984.html)\n2. [使用HTML5的两个api，前端js完成图片压缩](http://www.gbtags.com/gb/share/2991.htm)\n3. [使用HTML5 FILE API上传图片移动端缩略图兼容问题](http://blog.csdn.net/wuweitiandian/article/details/46472017)\n\n大概看完他们的思路以后，就能够实现这个功能了，但是他并不能保持宽高比适配屏幕，后面我优化了一下这部分。\n\n### 遇到的问题\n\n遇到的这四个问题我们来一一解决：\n\n1. 在iPhone中，click()事件无效\n2. 在微信安卓webview中，img标签使用background属性无效\n3. 预览上传图片保证宽高比\n4. 在某些安卓机型用rem单位不显示边框\n\n#### 在iPhone中click()事件无效\n\n这个问题在网上也有类似问题，[地址](http://stackoverflow.com/questions/14795944/jquery-click-events-not-working-in-ios)，但是我依照网上的办法都不行，但是我发现显式的在标签内通过onclick=\"document.querySelector('input').click()这种方式是可以调用的，所以我把所有的我需要隐式调用input的地方都绑定了这个`onclick=\"document.querySelector('input').click()`，然后逻辑方面我又用vue的@click绑定了一个方法来处理逻辑方面。\n\n#### img标签使用background属性无效\n\n这个可能是安卓的微信webview支持的不好，因为在iphone和别的手机浏览器当中都可以支持，但是在安卓的微信webview不能显示，这个是兼容性的问题，所以最后我选择在`div`中加background。\n\n#### 预览上传图片保证宽高比\n\n这个其实也不难优化，因为上面的方法是把base64的图片放到一个img标签当中，所以没法去适配这个宽高比，如果把这个放到`div`的`background-image`属性当中，并把`background-size`设置成`contain`，把`background-color`设置成页面背景一样的颜色，这样就能模拟出浏览图片的功能了。\n\n#### 在某些安卓机型用rem单位不显示边框\n\n因为移动端使用的是rem为单位，用postcss去处理（就是在css中写px，后处理器去处理成rem），在1px时转换为rem单位可能不足屏幕显示的1px，则不会显示边框。解决办法就是当写`border`时加注释去避免处理器去处理这句css（`/*px*/`）\n\n整个过程大概就是这样吧，[我把这个页面放到了github上](https://github.com/yatessss/yatessss.github.io/tree/master/demo/supplement-information)，但是没有vue的环境跑不起来，如果有需要可以拷到自己vue项目下去尝试。代码垃圾，轻喷。。。。。。\n\n顺嘴说一句，那天晚上加班到两点，然后坐车回家，到地方付款的时候，发现银行维护没法付款，而且微信里也没有余额，正在想怎么办司机师傅说，没事赶紧回家吧等能付款的时候付了就好了，一句赶紧回家吧真实一阵感动啊。。。\n","source":"_posts/2016-06-08-使用vue完成上传文件页面.md","raw":"---\nlayout: post\ntitle: 使用vue完成上传文件页面\ndate: 2016-06-08\ntags: ['vue','文件上传']\ncategories: 工作总结\t\n---\n\n### 需求描述\n\n最近加班加点完成了一个上传文件的需求，听起来很简单想着也很简单，但是知易行难实际操作起来，还是遇到了很多问题，现在就来总结一下，使用vue来构建一个上传文件的页面中会遇到哪些问题，其中的一些问题也可能是用别的框架也会遇到的问题。\n\n平台：主要是在安卓和苹果的微信webview中运行。\n\n先来看下主要的技术点：\n\n1. 父子组件的动态渲染\n2. 初始化数据和判断数据\n3. input表单隐藏联动\n4. 上传图片后可以预览\n\n遇到的问题：\n\n1. 在iPhone中，click()事件无效\n2. 在微信安卓webview中，img标签使用background属性无效\n3. 预览上传图片保证宽高比\n4. 在某些安卓机型用rem单位不显示边框\n\n设计图大概是这样的：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_06_pic_1.png)\n\n完成后的效果是这样：\n\n1. 首先登陆后，如果没有选择两个选项的话提交按钮点击不了并会有提示\n2. 当选择图片后，下面会显示选择图片的缩略图\n3. 当点击提交后，会显示loading成功后会刷新页面\n4. 提交过的部分不会显示示意图会改为一张提示图片，刚上传过所有图片时会提示已经上传过所有图片\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_2.gif)\n\n大概就是这么一个步骤流程吧。\n\n### 技术点分析\n\n这个页面主要使用的UI包括：提示、loading、选项栏等都是从WEUI样式库中扒出来的，因为是在微信公众号中使用的，体验上会一致。上传部分使用的是post表单上传，我把form表单隐藏了起来，通过模拟上传按钮，当点击上传按钮的时候同步触发表单中的input type=‘file’标签，调起原生的选择图片的界面，选择图片后，点击上传按钮的同时触发一个post请求把图片传到后台，完成整个功能。\n\n#### 父子组件的动态渲染\n\n可以从设计图看出上传图片的部分基本上设计是一样的，所以用一个vue组件来复用是最好的，顺便说一下这个页面用到了三个组件，一个是dialog提示的组件，一个是loading的组件，还有一个就是上传这部分用到的组件。\n\n主要说一下上传部分的组件，在vue中，子父组件要传递的参数需要在子组件的props中声明，下面是我的组件中的模板，我主要用到了以下参数：\n\n```js\n<template>\n  <div class=\"com-box\">\n    <h3 v-if=\"comTitle\" class=\"com-title\">{{comTitle}}</h3>\n    <div class=\"upload-box\">\n      <h2>{{nameCn}}</h2>\n      <div class=\"img-box\" id=\"{{nameId}}\" :style=\"bgUrl\">\n        <!--<img :src=\"imgUrl\">-->\n      </div>\n      <p class=\"tip\" v-if=\"tip\">{{tip}}</p>\n      <!--<div v-if=\"isUpload\" class=\"upload-btn upload-true\">图片已提交</div>-->\n      <div v-if=\"!isUpload\" class=\"upload-btn upload-false clickable-div\" onclick=\"document.querySelector('input').click()\" @click=\"inputBtn(name, $event)\">上传图片</div>\n    </div>\n  </div>\n</template>\n\n<script>\n/*\n* name：主要是让input表单和组件通过id产生关联\n* nameCn：组件的title\n* imgUrl：（最后弃用但没有删掉）\n* isUpload： 标识有没有上传，这个会在父组件中进行判断，如果已经上传了会把上传按钮隐藏掉\n* tip：图片下部的说明文字\n* bgUrl：默认的说明背景图，上传完成后会在父组件中更改这个图片改成一张上传完成的提示图\n*/\nprops: ['name', 'nameCn', 'imgUrl', 'isUpload', 'tip', 'bgUrl', 'comTitle']，\ncomputed: {\n  nameId () {\n    return this.name + 'content'\n  }\n}\n</script>\n```\n\n然后在父组件中我们可以引入这个组件，并声明它，然后在标签中把子组件需要用到的参数传递进去就好了。我这里是使用了`v-for`去遍历了一个`result_data`的数组，把所有需要上传的组件遍历渲染了出来。如下：\n\n```js\n<template>\n\t<upload v-for=\"(index, item) in result_data\" :name=\"item.name\" :name-cn=\"item.nameCn\" :bg-url=\"item.bgUrl\" :img-url=\"item.imgUrl\" :tip=\"item.tip\" :is-upload=\"item.isUpload\" :com-title=\"item.comTitle\"> </upload>\n</template>\n\n<script>\n  import upload from './upload.vue'\n  components: {\n      upload\n    },\n</script>\n\n```\n\n这样子父组件就可以传递数据了，具体的大家可以去看一下官方的文档。\n\n#### 初始化数据和判断数据\n\n这是这个任务里最坑的一个部分。因为后台只会把已经上传过图片的字段告诉我，所以我需要在前端去造一些初始化的数据，去和后台返回回来的比较，再去判断哪些上传过需要展示出来，那些没上传需要上传。\n\n注意：可以造数据的前提是，数据量不是很大，且数据是固定的。其实最好是后台可以完成这些判断，因为前端本就不应该去处理数据方面的逻辑。\n\n我初始化的数据大概是这个样子的：\n\n```js\ninit_data: [\n//          0\n  {\n    name: 'shopphoto',\n    nameCn: '店铺门头照片',\n    bgUrl: {\n      backgroundImage: \"url('http://near.m1img.com/op_upload/62/146502860635.jpg')\",\n      backgroundSize: '100% 100%'\n    },\n    imgUrl: '',\n    tip: '',\n    isUpload: false\n  },\n\t\n//          1\n  {\n    name: 'goodsphoto',\n    nameCn: '店铺内景照片',\n    bgUrl: {\n      backgroundImage: \"url('http://near.m1img.com/op_upload/62/146502865726.jpg')\",\n      backgroundSize: '100% 100%'\n    },\n    imgUrl: '',\n    tip: '',\n    isUpload: false\n  }\n]\n```\n\n然后我去遍历后台返回的那个数组和我自己初始化得数组，用`name`这个字段产生关联去比较，因为后台只返回了上传过图片的字段，所以我就可以判断出哪些是没有上传的部分。判断的逻辑如下：\n\n```js\ncompareArr (oldArr, newArr) {\n    var _this = this\n    var _oldArr = oldArr\n    var _newArr = newArr\n    for (let i = 0, len1 = _newArr.length; i < len1; i++) {\n      for (let j = 0, len2 = _oldArr.length; j < len2; j++) {\n        if (_newArr[i].name === _oldArr[j].name) {\n          let initData = _this.init_data\n          initData[i].bgUrl = {\n            backgroundImage: \"url('http://near.m1img.com/op_upload/62/146520417256.png')\",\n            backgroundSize: '100% 100%'\n          }\n          initData[i].isUpload = true\n          _this.$set('init_data', initData)\n        }\n      }\n    }\n  }\n```\n\n我会给这个方法传入两个数组。oldArr是后台的数组，newArr是我自己初始化的数组。\n循环遍历比较两个数组，把我自己初始化的数据做出一些修改，主要是提示图片和是否上传标识字段的更改。\n\n#### input表单隐藏联动\n\n这个逻辑也不是很复杂，就是在点击上传按钮的时候，调一个方法，在方法中选择到对应的`input`标签出发一个`click()`事件，主要是在iphone上面，可能会不支持input type=‘file’的标签，这里有一个坑，在网上找到了一些解决办法，但是试了一下没有效果，最后自己试验了一下找到了一个解决办法，在下面遇到的问题中会叙述。\n\n第二是要注意在form表单中要禁止事件冒泡，不然你点击一次input表单就会提交一次。\n\n#### 上传图片后可以预览\n\n可以我是汲取了广大人民的智慧。。。\n\n主要思路就是把图片读取成一个base64格式，然后再把他装到一个img标签中。实现预览功能，这里我给几个参考的资料，有的demo直接就可以跑，改一改就可以运用到自己的项目中。\n\n1. [移动前端—图片压缩上传实践](http://www.cnblogs.com/axes/p/4603984.html)\n2. [使用HTML5的两个api，前端js完成图片压缩](http://www.gbtags.com/gb/share/2991.htm)\n3. [使用HTML5 FILE API上传图片移动端缩略图兼容问题](http://blog.csdn.net/wuweitiandian/article/details/46472017)\n\n大概看完他们的思路以后，就能够实现这个功能了，但是他并不能保持宽高比适配屏幕，后面我优化了一下这部分。\n\n### 遇到的问题\n\n遇到的这四个问题我们来一一解决：\n\n1. 在iPhone中，click()事件无效\n2. 在微信安卓webview中，img标签使用background属性无效\n3. 预览上传图片保证宽高比\n4. 在某些安卓机型用rem单位不显示边框\n\n#### 在iPhone中click()事件无效\n\n这个问题在网上也有类似问题，[地址](http://stackoverflow.com/questions/14795944/jquery-click-events-not-working-in-ios)，但是我依照网上的办法都不行，但是我发现显式的在标签内通过onclick=\"document.querySelector('input').click()这种方式是可以调用的，所以我把所有的我需要隐式调用input的地方都绑定了这个`onclick=\"document.querySelector('input').click()`，然后逻辑方面我又用vue的@click绑定了一个方法来处理逻辑方面。\n\n#### img标签使用background属性无效\n\n这个可能是安卓的微信webview支持的不好，因为在iphone和别的手机浏览器当中都可以支持，但是在安卓的微信webview不能显示，这个是兼容性的问题，所以最后我选择在`div`中加background。\n\n#### 预览上传图片保证宽高比\n\n这个其实也不难优化，因为上面的方法是把base64的图片放到一个img标签当中，所以没法去适配这个宽高比，如果把这个放到`div`的`background-image`属性当中，并把`background-size`设置成`contain`，把`background-color`设置成页面背景一样的颜色，这样就能模拟出浏览图片的功能了。\n\n#### 在某些安卓机型用rem单位不显示边框\n\n因为移动端使用的是rem为单位，用postcss去处理（就是在css中写px，后处理器去处理成rem），在1px时转换为rem单位可能不足屏幕显示的1px，则不会显示边框。解决办法就是当写`border`时加注释去避免处理器去处理这句css（`/*px*/`）\n\n整个过程大概就是这样吧，[我把这个页面放到了github上](https://github.com/yatessss/yatessss.github.io/tree/master/demo/supplement-information)，但是没有vue的环境跑不起来，如果有需要可以拷到自己vue项目下去尝试。代码垃圾，轻喷。。。。。。\n\n顺嘴说一句，那天晚上加班到两点，然后坐车回家，到地方付款的时候，发现银行维护没法付款，而且微信里也没有余额，正在想怎么办司机师傅说，没事赶紧回家吧等能付款的时候付了就好了，一句赶紧回家吧真实一阵感动啊。。。\n","slug":"使用vue完成上传文件页面","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1zt002gsq5ln0yi0kdh","content":"<h3 id=\"需求描述\"><a href=\"#需求描述\" class=\"headerlink\" title=\"需求描述\"></a>需求描述</h3><p>最近加班加点完成了一个上传文件的需求，听起来很简单想着也很简单，但是知易行难实际操作起来，还是遇到了很多问题，现在就来总结一下，使用vue来构建一个上传文件的页面中会遇到哪些问题，其中的一些问题也可能是用别的框架也会遇到的问题。</p>\n<p>平台：主要是在安卓和苹果的微信webview中运行。</p>\n<p>先来看下主要的技术点：</p>\n<ol>\n<li>父子组件的动态渲染</li>\n<li>初始化数据和判断数据</li>\n<li>input表单隐藏联动</li>\n<li>上传图片后可以预览</li>\n</ol>\n<p>遇到的问题：</p>\n<ol>\n<li>在iPhone中，click()事件无效</li>\n<li>在微信安卓webview中，img标签使用background属性无效</li>\n<li>预览上传图片保证宽高比</li>\n<li>在某些安卓机型用rem单位不显示边框</li>\n</ol>\n<p>设计图大概是这样的：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_06_pic_1.png\" alt=\"\"></p>\n<p>完成后的效果是这样：</p>\n<ol>\n<li>首先登陆后，如果没有选择两个选项的话提交按钮点击不了并会有提示</li>\n<li>当选择图片后，下面会显示选择图片的缩略图</li>\n<li>当点击提交后，会显示loading成功后会刷新页面</li>\n<li>提交过的部分不会显示示意图会改为一张提示图片，刚上传过所有图片时会提示已经上传过所有图片</li>\n</ol>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_2.gif\" alt=\"\"></p>\n<p>大概就是这么一个步骤流程吧。</p>\n<h3 id=\"技术点分析\"><a href=\"#技术点分析\" class=\"headerlink\" title=\"技术点分析\"></a>技术点分析</h3><p>这个页面主要使用的UI包括：提示、loading、选项栏等都是从WEUI样式库中扒出来的，因为是在微信公众号中使用的，体验上会一致。上传部分使用的是post表单上传，我把form表单隐藏了起来，通过模拟上传按钮，当点击上传按钮的时候同步触发表单中的input type=‘file’标签，调起原生的选择图片的界面，选择图片后，点击上传按钮的同时触发一个post请求把图片传到后台，完成整个功能。</p>\n<h4 id=\"父子组件的动态渲染\"><a href=\"#父子组件的动态渲染\" class=\"headerlink\" title=\"父子组件的动态渲染\"></a>父子组件的动态渲染</h4><p>可以从设计图看出上传图片的部分基本上设计是一样的，所以用一个vue组件来复用是最好的，顺便说一下这个页面用到了三个组件，一个是dialog提示的组件，一个是loading的组件，还有一个就是上传这部分用到的组件。</p>\n<p>主要说一下上传部分的组件，在vue中，子父组件要传递的参数需要在子组件的props中声明，下面是我的组件中的模板，我主要用到了以下参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com-box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"comTitle\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com-title\"</span>&gt;</span>&#123;&#123;comTitle&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"upload-box\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123;nameCn&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"img-box\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"&#123;&#123;nameId&#125;&#125;\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"bgUrl\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--&lt;img :src=\"imgUrl\"&gt;--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tip\"</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"tip\"</span>&gt;</span>&#123;&#123;tip&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!--&lt;div v-if=\"isUpload\" class=\"upload-btn upload-true\"&gt;图片已提交&lt;/div&gt;--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"!isUpload\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"upload-btn upload-false clickable-div\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"document.querySelector('input').click()\"</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"inputBtn(name, $event)\"</span>&gt;</span>上传图片<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\">* name：主要是让input表单和组件通过id产生关联</span><br><span class=\"line\">* nameCn：组件的title</span><br><span class=\"line\">* imgUrl：（最后弃用但没有删掉）</span><br><span class=\"line\">* isUpload： 标识有没有上传，这个会在父组件中进行判断，如果已经上传了会把上传按钮隐藏掉</span><br><span class=\"line\">* tip：图片下部的说明文字</span><br><span class=\"line\">* bgUrl：默认的说明背景图，上传完成后会在父组件中更改这个图片改成一张上传完成的提示图</span><br><span class=\"line\">*/</span></span><br><span class=\"line\">props: [<span class=\"string\">'name'</span>, <span class=\"string\">'nameCn'</span>, <span class=\"string\">'imgUrl'</span>, <span class=\"string\">'isUpload'</span>, <span class=\"string\">'tip'</span>, <span class=\"string\">'bgUrl'</span>, <span class=\"string\">'comTitle'</span>]，</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  nameId () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">'content'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在父组件中我们可以引入这个组件，并声明它，然后在标签中把子组件需要用到的参数传递进去就好了。我这里是使用了<code>v-for</code>去遍历了一个<code>result_data</code>的数组，把所有需要上传的组件遍历渲染了出来。如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;upload v-for=\"(index, item) in result_data\" :name=\"item.name\" :name-cn=\"item.nameCn\" :bg-url=\"item.bgUrl\" :img-url=\"item.imgUrl\" :tip=\"item.tip\" :is-upload=\"item.isUpload\" :com-title=\"item.comTitle\"&gt; &lt;/upload&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  import upload from './upload.vue'</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">      upload</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这样子父组件就可以传递数据了，具体的大家可以去看一下官方的文档。</p>\n<h4 id=\"初始化数据和判断数据\"><a href=\"#初始化数据和判断数据\" class=\"headerlink\" title=\"初始化数据和判断数据\"></a>初始化数据和判断数据</h4><p>这是这个任务里最坑的一个部分。因为后台只会把已经上传过图片的字段告诉我，所以我需要在前端去造一些初始化的数据，去和后台返回回来的比较，再去判断哪些上传过需要展示出来，那些没上传需要上传。</p>\n<p>注意：可以造数据的前提是，数据量不是很大，且数据是固定的。其实最好是后台可以完成这些判断，因为前端本就不应该去处理数据方面的逻辑。</p>\n<p>我初始化的数据大概是这个样子的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_data: [</span><br><span class=\"line\"><span class=\"comment\">//          0</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'shopphoto'</span>,</span><br><span class=\"line\">    nameCn: <span class=\"string\">'店铺门头照片'</span>,</span><br><span class=\"line\">    bgUrl: &#123;</span><br><span class=\"line\">      backgroundImage: <span class=\"string\">\"url('http://near.m1img.com/op_upload/62/146502860635.jpg')\"</span>,</span><br><span class=\"line\">      backgroundSize: <span class=\"string\">'100% 100%'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    imgUrl: <span class=\"string\">''</span>,</span><br><span class=\"line\">    tip: <span class=\"string\">''</span>,</span><br><span class=\"line\">    isUpload: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">//          1</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'goodsphoto'</span>,</span><br><span class=\"line\">    nameCn: <span class=\"string\">'店铺内景照片'</span>,</span><br><span class=\"line\">    bgUrl: &#123;</span><br><span class=\"line\">      backgroundImage: <span class=\"string\">\"url('http://near.m1img.com/op_upload/62/146502865726.jpg')\"</span>,</span><br><span class=\"line\">      backgroundSize: <span class=\"string\">'100% 100%'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    imgUrl: <span class=\"string\">''</span>,</span><br><span class=\"line\">    tip: <span class=\"string\">''</span>,</span><br><span class=\"line\">    isUpload: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>然后我去遍历后台返回的那个数组和我自己初始化得数组，用<code>name</code>这个字段产生关联去比较，因为后台只返回了上传过图片的字段，所以我就可以判断出哪些是没有上传的部分。判断的逻辑如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compareArr (oldArr, newArr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> _oldArr = oldArr</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _newArr = newArr</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len1 = _newArr.length; i &lt; len1; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>, len2 = _oldArr.length; j &lt; len2; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_newArr[i].name === _oldArr[j].name) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> initData = _this.init_data</span><br><span class=\"line\">          initData[i].bgUrl = &#123;</span><br><span class=\"line\">            backgroundImage: <span class=\"string\">\"url('http://near.m1img.com/op_upload/62/146520417256.png')\"</span>,</span><br><span class=\"line\">            backgroundSize: <span class=\"string\">'100% 100%'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          initData[i].isUpload = <span class=\"literal\">true</span></span><br><span class=\"line\">          _this.$set(<span class=\"string\">'init_data'</span>, initData)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>我会给这个方法传入两个数组。oldArr是后台的数组，newArr是我自己初始化的数组。<br>循环遍历比较两个数组，把我自己初始化的数据做出一些修改，主要是提示图片和是否上传标识字段的更改。</p>\n<h4 id=\"input表单隐藏联动\"><a href=\"#input表单隐藏联动\" class=\"headerlink\" title=\"input表单隐藏联动\"></a>input表单隐藏联动</h4><p>这个逻辑也不是很复杂，就是在点击上传按钮的时候，调一个方法，在方法中选择到对应的<code>input</code>标签出发一个<code>click()</code>事件，主要是在iphone上面，可能会不支持input type=‘file’的标签，这里有一个坑，在网上找到了一些解决办法，但是试了一下没有效果，最后自己试验了一下找到了一个解决办法，在下面遇到的问题中会叙述。</p>\n<p>第二是要注意在form表单中要禁止事件冒泡，不然你点击一次input表单就会提交一次。</p>\n<h4 id=\"上传图片后可以预览\"><a href=\"#上传图片后可以预览\" class=\"headerlink\" title=\"上传图片后可以预览\"></a>上传图片后可以预览</h4><p>可以我是汲取了广大人民的智慧。。。</p>\n<p>主要思路就是把图片读取成一个base64格式，然后再把他装到一个img标签中。实现预览功能，这里我给几个参考的资料，有的demo直接就可以跑，改一改就可以运用到自己的项目中。</p>\n<ol>\n<li><a href=\"http://www.cnblogs.com/axes/p/4603984.html\" target=\"_blank\" rel=\"external\">移动前端—图片压缩上传实践</a></li>\n<li><a href=\"http://www.gbtags.com/gb/share/2991.htm\" target=\"_blank\" rel=\"external\">使用HTML5的两个api，前端js完成图片压缩</a></li>\n<li><a href=\"http://blog.csdn.net/wuweitiandian/article/details/46472017\" target=\"_blank\" rel=\"external\">使用HTML5 FILE API上传图片移动端缩略图兼容问题</a></li>\n</ol>\n<p>大概看完他们的思路以后，就能够实现这个功能了，但是他并不能保持宽高比适配屏幕，后面我优化了一下这部分。</p>\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><p>遇到的这四个问题我们来一一解决：</p>\n<ol>\n<li>在iPhone中，click()事件无效</li>\n<li>在微信安卓webview中，img标签使用background属性无效</li>\n<li>预览上传图片保证宽高比</li>\n<li>在某些安卓机型用rem单位不显示边框</li>\n</ol>\n<h4 id=\"在iPhone中click-事件无效\"><a href=\"#在iPhone中click-事件无效\" class=\"headerlink\" title=\"在iPhone中click()事件无效\"></a>在iPhone中click()事件无效</h4><p>这个问题在网上也有类似问题，<a href=\"http://stackoverflow.com/questions/14795944/jquery-click-events-not-working-in-ios\" target=\"_blank\" rel=\"external\">地址</a>，但是我依照网上的办法都不行，但是我发现显式的在标签内通过onclick=”document.querySelector(‘input’).click()这种方式是可以调用的，所以我把所有的我需要隐式调用input的地方都绑定了这个<code>onclick=&quot;document.querySelector(&#39;input&#39;).click()</code>，然后逻辑方面我又用vue的@click绑定了一个方法来处理逻辑方面。</p>\n<h4 id=\"img标签使用background属性无效\"><a href=\"#img标签使用background属性无效\" class=\"headerlink\" title=\"img标签使用background属性无效\"></a>img标签使用background属性无效</h4><p>这个可能是安卓的微信webview支持的不好，因为在iphone和别的手机浏览器当中都可以支持，但是在安卓的微信webview不能显示，这个是兼容性的问题，所以最后我选择在<code>div</code>中加background。</p>\n<h4 id=\"预览上传图片保证宽高比\"><a href=\"#预览上传图片保证宽高比\" class=\"headerlink\" title=\"预览上传图片保证宽高比\"></a>预览上传图片保证宽高比</h4><p>这个其实也不难优化，因为上面的方法是把base64的图片放到一个img标签当中，所以没法去适配这个宽高比，如果把这个放到<code>div</code>的<code>background-image</code>属性当中，并把<code>background-size</code>设置成<code>contain</code>，把<code>background-color</code>设置成页面背景一样的颜色，这样就能模拟出浏览图片的功能了。</p>\n<h4 id=\"在某些安卓机型用rem单位不显示边框\"><a href=\"#在某些安卓机型用rem单位不显示边框\" class=\"headerlink\" title=\"在某些安卓机型用rem单位不显示边框\"></a>在某些安卓机型用rem单位不显示边框</h4><p>因为移动端使用的是rem为单位，用postcss去处理（就是在css中写px，后处理器去处理成rem），在1px时转换为rem单位可能不足屏幕显示的1px，则不会显示边框。解决办法就是当写<code>border</code>时加注释去避免处理器去处理这句css（<code>/*px*/</code>）</p>\n<p>整个过程大概就是这样吧，<a href=\"https://github.com/yatessss/yatessss.github.io/tree/master/demo/supplement-information\" target=\"_blank\" rel=\"external\">我把这个页面放到了github上</a>，但是没有vue的环境跑不起来，如果有需要可以拷到自己vue项目下去尝试。代码垃圾，轻喷。。。。。。</p>\n<p>顺嘴说一句，那天晚上加班到两点，然后坐车回家，到地方付款的时候，发现银行维护没法付款，而且微信里也没有余额，正在想怎么办司机师傅说，没事赶紧回家吧等能付款的时候付了就好了，一句赶紧回家吧真实一阵感动啊。。。</p>\n","excerpt":"","more":"<h3 id=\"需求描述\"><a href=\"#需求描述\" class=\"headerlink\" title=\"需求描述\"></a>需求描述</h3><p>最近加班加点完成了一个上传文件的需求，听起来很简单想着也很简单，但是知易行难实际操作起来，还是遇到了很多问题，现在就来总结一下，使用vue来构建一个上传文件的页面中会遇到哪些问题，其中的一些问题也可能是用别的框架也会遇到的问题。</p>\n<p>平台：主要是在安卓和苹果的微信webview中运行。</p>\n<p>先来看下主要的技术点：</p>\n<ol>\n<li>父子组件的动态渲染</li>\n<li>初始化数据和判断数据</li>\n<li>input表单隐藏联动</li>\n<li>上传图片后可以预览</li>\n</ol>\n<p>遇到的问题：</p>\n<ol>\n<li>在iPhone中，click()事件无效</li>\n<li>在微信安卓webview中，img标签使用background属性无效</li>\n<li>预览上传图片保证宽高比</li>\n<li>在某些安卓机型用rem单位不显示边框</li>\n</ol>\n<p>设计图大概是这样的：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_06_pic_1.png\" alt=\"\"></p>\n<p>完成后的效果是这样：</p>\n<ol>\n<li>首先登陆后，如果没有选择两个选项的话提交按钮点击不了并会有提示</li>\n<li>当选择图片后，下面会显示选择图片的缩略图</li>\n<li>当点击提交后，会显示loading成功后会刷新页面</li>\n<li>提交过的部分不会显示示意图会改为一张提示图片，刚上传过所有图片时会提示已经上传过所有图片</li>\n</ol>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_03_pic_2.gif\" alt=\"\"></p>\n<p>大概就是这么一个步骤流程吧。</p>\n<h3 id=\"技术点分析\"><a href=\"#技术点分析\" class=\"headerlink\" title=\"技术点分析\"></a>技术点分析</h3><p>这个页面主要使用的UI包括：提示、loading、选项栏等都是从WEUI样式库中扒出来的，因为是在微信公众号中使用的，体验上会一致。上传部分使用的是post表单上传，我把form表单隐藏了起来，通过模拟上传按钮，当点击上传按钮的时候同步触发表单中的input type=‘file’标签，调起原生的选择图片的界面，选择图片后，点击上传按钮的同时触发一个post请求把图片传到后台，完成整个功能。</p>\n<h4 id=\"父子组件的动态渲染\"><a href=\"#父子组件的动态渲染\" class=\"headerlink\" title=\"父子组件的动态渲染\"></a>父子组件的动态渲染</h4><p>可以从设计图看出上传图片的部分基本上设计是一样的，所以用一个vue组件来复用是最好的，顺便说一下这个页面用到了三个组件，一个是dialog提示的组件，一个是loading的组件，还有一个就是上传这部分用到的组件。</p>\n<p>主要说一下上传部分的组件，在vue中，子父组件要传递的参数需要在子组件的props中声明，下面是我的组件中的模板，我主要用到了以下参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com-box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h3</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"comTitle\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com-title\"</span>&gt;</span>&#123;&#123;comTitle&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"upload-box\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>&#123;&#123;nameCn&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"img-box\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"&#123;&#123;nameId&#125;&#125;\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"bgUrl\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--&lt;img :src=\"imgUrl\"&gt;--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">class</span>=<span class=\"string\">\"tip\"</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"tip\"</span>&gt;</span>&#123;&#123;tip&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!--&lt;div v-if=\"isUpload\" class=\"upload-btn upload-true\"&gt;图片已提交&lt;/div&gt;--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"!isUpload\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"upload-btn upload-false clickable-div\"</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"document.querySelector('input').click()\"</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"inputBtn(name, $event)\"</span>&gt;</span>上传图片<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\">* name：主要是让input表单和组件通过id产生关联</span><br><span class=\"line\">* nameCn：组件的title</span><br><span class=\"line\">* imgUrl：（最后弃用但没有删掉）</span><br><span class=\"line\">* isUpload： 标识有没有上传，这个会在父组件中进行判断，如果已经上传了会把上传按钮隐藏掉</span><br><span class=\"line\">* tip：图片下部的说明文字</span><br><span class=\"line\">* bgUrl：默认的说明背景图，上传完成后会在父组件中更改这个图片改成一张上传完成的提示图</span><br><span class=\"line\">*/</span></span><br><span class=\"line\">props: [<span class=\"string\">'name'</span>, <span class=\"string\">'nameCn'</span>, <span class=\"string\">'imgUrl'</span>, <span class=\"string\">'isUpload'</span>, <span class=\"string\">'tip'</span>, <span class=\"string\">'bgUrl'</span>, <span class=\"string\">'comTitle'</span>]，</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  nameId () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">'content'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在父组件中我们可以引入这个组件，并声明它，然后在标签中把子组件需要用到的参数传递进去就好了。我这里是使用了<code>v-for</code>去遍历了一个<code>result_data</code>的数组，把所有需要上传的组件遍历渲染了出来。如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">\t&lt;upload v-for=\"(index, item) in result_data\" :name=\"item.name\" :name-cn=\"item.nameCn\" :bg-url=\"item.bgUrl\" :img-url=\"item.imgUrl\" :tip=\"item.tip\" :is-upload=\"item.isUpload\" :com-title=\"item.comTitle\"&gt; &lt;/upload&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  import upload from './upload.vue'</span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">      upload</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这样子父组件就可以传递数据了，具体的大家可以去看一下官方的文档。</p>\n<h4 id=\"初始化数据和判断数据\"><a href=\"#初始化数据和判断数据\" class=\"headerlink\" title=\"初始化数据和判断数据\"></a>初始化数据和判断数据</h4><p>这是这个任务里最坑的一个部分。因为后台只会把已经上传过图片的字段告诉我，所以我需要在前端去造一些初始化的数据，去和后台返回回来的比较，再去判断哪些上传过需要展示出来，那些没上传需要上传。</p>\n<p>注意：可以造数据的前提是，数据量不是很大，且数据是固定的。其实最好是后台可以完成这些判断，因为前端本就不应该去处理数据方面的逻辑。</p>\n<p>我初始化的数据大概是这个样子的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_data: [</span><br><span class=\"line\"><span class=\"comment\">//          0</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'shopphoto'</span>,</span><br><span class=\"line\">    nameCn: <span class=\"string\">'店铺门头照片'</span>,</span><br><span class=\"line\">    bgUrl: &#123;</span><br><span class=\"line\">      backgroundImage: <span class=\"string\">\"url('http://near.m1img.com/op_upload/62/146502860635.jpg')\"</span>,</span><br><span class=\"line\">      backgroundSize: <span class=\"string\">'100% 100%'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    imgUrl: <span class=\"string\">''</span>,</span><br><span class=\"line\">    tip: <span class=\"string\">''</span>,</span><br><span class=\"line\">    isUpload: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">//          1</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'goodsphoto'</span>,</span><br><span class=\"line\">    nameCn: <span class=\"string\">'店铺内景照片'</span>,</span><br><span class=\"line\">    bgUrl: &#123;</span><br><span class=\"line\">      backgroundImage: <span class=\"string\">\"url('http://near.m1img.com/op_upload/62/146502865726.jpg')\"</span>,</span><br><span class=\"line\">      backgroundSize: <span class=\"string\">'100% 100%'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    imgUrl: <span class=\"string\">''</span>,</span><br><span class=\"line\">    tip: <span class=\"string\">''</span>,</span><br><span class=\"line\">    isUpload: <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>然后我去遍历后台返回的那个数组和我自己初始化得数组，用<code>name</code>这个字段产生关联去比较，因为后台只返回了上传过图片的字段，所以我就可以判断出哪些是没有上传的部分。判断的逻辑如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compareArr (oldArr, newArr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> _oldArr = oldArr</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _newArr = newArr</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len1 = _newArr.length; i &lt; len1; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>, len2 = _oldArr.length; j &lt; len2; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_newArr[i].name === _oldArr[j].name) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> initData = _this.init_data</span><br><span class=\"line\">          initData[i].bgUrl = &#123;</span><br><span class=\"line\">            backgroundImage: <span class=\"string\">\"url('http://near.m1img.com/op_upload/62/146520417256.png')\"</span>,</span><br><span class=\"line\">            backgroundSize: <span class=\"string\">'100% 100%'</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          initData[i].isUpload = <span class=\"literal\">true</span></span><br><span class=\"line\">          _this.$set(<span class=\"string\">'init_data'</span>, initData)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>我会给这个方法传入两个数组。oldArr是后台的数组，newArr是我自己初始化的数组。<br>循环遍历比较两个数组，把我自己初始化的数据做出一些修改，主要是提示图片和是否上传标识字段的更改。</p>\n<h4 id=\"input表单隐藏联动\"><a href=\"#input表单隐藏联动\" class=\"headerlink\" title=\"input表单隐藏联动\"></a>input表单隐藏联动</h4><p>这个逻辑也不是很复杂，就是在点击上传按钮的时候，调一个方法，在方法中选择到对应的<code>input</code>标签出发一个<code>click()</code>事件，主要是在iphone上面，可能会不支持input type=‘file’的标签，这里有一个坑，在网上找到了一些解决办法，但是试了一下没有效果，最后自己试验了一下找到了一个解决办法，在下面遇到的问题中会叙述。</p>\n<p>第二是要注意在form表单中要禁止事件冒泡，不然你点击一次input表单就会提交一次。</p>\n<h4 id=\"上传图片后可以预览\"><a href=\"#上传图片后可以预览\" class=\"headerlink\" title=\"上传图片后可以预览\"></a>上传图片后可以预览</h4><p>可以我是汲取了广大人民的智慧。。。</p>\n<p>主要思路就是把图片读取成一个base64格式，然后再把他装到一个img标签中。实现预览功能，这里我给几个参考的资料，有的demo直接就可以跑，改一改就可以运用到自己的项目中。</p>\n<ol>\n<li><a href=\"http://www.cnblogs.com/axes/p/4603984.html\">移动前端—图片压缩上传实践</a></li>\n<li><a href=\"http://www.gbtags.com/gb/share/2991.htm\">使用HTML5的两个api，前端js完成图片压缩</a></li>\n<li><a href=\"http://blog.csdn.net/wuweitiandian/article/details/46472017\">使用HTML5 FILE API上传图片移动端缩略图兼容问题</a></li>\n</ol>\n<p>大概看完他们的思路以后，就能够实现这个功能了，但是他并不能保持宽高比适配屏幕，后面我优化了一下这部分。</p>\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><p>遇到的这四个问题我们来一一解决：</p>\n<ol>\n<li>在iPhone中，click()事件无效</li>\n<li>在微信安卓webview中，img标签使用background属性无效</li>\n<li>预览上传图片保证宽高比</li>\n<li>在某些安卓机型用rem单位不显示边框</li>\n</ol>\n<h4 id=\"在iPhone中click-事件无效\"><a href=\"#在iPhone中click-事件无效\" class=\"headerlink\" title=\"在iPhone中click()事件无效\"></a>在iPhone中click()事件无效</h4><p>这个问题在网上也有类似问题，<a href=\"http://stackoverflow.com/questions/14795944/jquery-click-events-not-working-in-ios\">地址</a>，但是我依照网上的办法都不行，但是我发现显式的在标签内通过onclick=”document.querySelector(‘input’).click()这种方式是可以调用的，所以我把所有的我需要隐式调用input的地方都绑定了这个<code>onclick=&quot;document.querySelector(&#39;input&#39;).click()</code>，然后逻辑方面我又用vue的@click绑定了一个方法来处理逻辑方面。</p>\n<h4 id=\"img标签使用background属性无效\"><a href=\"#img标签使用background属性无效\" class=\"headerlink\" title=\"img标签使用background属性无效\"></a>img标签使用background属性无效</h4><p>这个可能是安卓的微信webview支持的不好，因为在iphone和别的手机浏览器当中都可以支持，但是在安卓的微信webview不能显示，这个是兼容性的问题，所以最后我选择在<code>div</code>中加background。</p>\n<h4 id=\"预览上传图片保证宽高比\"><a href=\"#预览上传图片保证宽高比\" class=\"headerlink\" title=\"预览上传图片保证宽高比\"></a>预览上传图片保证宽高比</h4><p>这个其实也不难优化，因为上面的方法是把base64的图片放到一个img标签当中，所以没法去适配这个宽高比，如果把这个放到<code>div</code>的<code>background-image</code>属性当中，并把<code>background-size</code>设置成<code>contain</code>，把<code>background-color</code>设置成页面背景一样的颜色，这样就能模拟出浏览图片的功能了。</p>\n<h4 id=\"在某些安卓机型用rem单位不显示边框\"><a href=\"#在某些安卓机型用rem单位不显示边框\" class=\"headerlink\" title=\"在某些安卓机型用rem单位不显示边框\"></a>在某些安卓机型用rem单位不显示边框</h4><p>因为移动端使用的是rem为单位，用postcss去处理（就是在css中写px，后处理器去处理成rem），在1px时转换为rem单位可能不足屏幕显示的1px，则不会显示边框。解决办法就是当写<code>border</code>时加注释去避免处理器去处理这句css（<code>/*px*/</code>）</p>\n<p>整个过程大概就是这样吧，<a href=\"https://github.com/yatessss/yatessss.github.io/tree/master/demo/supplement-information\">我把这个页面放到了github上</a>，但是没有vue的环境跑不起来，如果有需要可以拷到自己vue项目下去尝试。代码垃圾，轻喷。。。。。。</p>\n<p>顺嘴说一句，那天晚上加班到两点，然后坐车回家，到地方付款的时候，发现银行维护没法付款，而且微信里也没有余额，正在想怎么办司机师傅说，没事赶紧回家吧等能付款的时候付了就好了，一句赶紧回家吧真实一阵感动啊。。。</p>\n"},{"layout":"post","title":"使用vue完成知乎日报web版","date":"2016-07-07T16:00:00.000Z","_content":"\n### 在线地址\n\n[demo地址](http://zhihudaily-vue.yatessss.com/)\n\n[github地址](https://github.com/yatessss/zhihudaily-vue)\n\n### 运行截图\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-13.png)\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-14.png)\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-15.png)\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-16.png)\n\n### 运行动图\n\n运行过程：首页-->轮播-->侧滑栏-->详情页-->分享-->评论页-->专栏列表-->详情页-->个人页-->更改为夜间模式-->运行-->主题日报\n\n[如需观看请在wifi下打开此地址](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picUntitled11.gif)\n\n### 制作起因\n\n前段时间在github上看到了知乎日报的API和一个用vue制作的知乎日报，觉得自己也应该试着做一个用来练习练习vue。制作历时两周，基本上是仿照安卓版知乎日报的ui做的，功能上除了一些需要登录后完成的功能如评论点赞等，基本上都实现了。可能在不同手机浏览器里会出现不兼容的现象。在chrome中可以比较好的运行。\n\n下面就来介绍一下整个过程中，和遇到了哪些比较问题，是如何解决或者是变通的。\n\n### 过程\n\n#### 项目搭建\n\n使用的构建工具是webpack，但是我其实对构建项目上并没有很多经验，主要是应用了vue-cli这个脚手架工具，在vue-cli生成的项目的基础上做了一些小的修改，比如：因为是移动端的页面，用了flexible，所以加了postcss来处理px和rem之间的转换。\n\n项目目录基本维持了vue-cli的目录结构，只是多加了一个view目录来存放每个路由的页面，把跟路由直接写进了入口的html文件内。\n\n### 分析接口\n\n其中很主要的一个工作就是分析接口中返回数据的格式，因为有些接口可能会是同一个但是返回的数据接口可能是不一样的。\n\n比如：推荐者列表这个接口，有主编和没有主编的返回的数据接口是不一样的。\n\n比如：日报详情页面，首页日报和主题日报可能就是不一样的，有些主题日报并没有返回body这个字段，所以你需要判断如果没有body这个字段，就需要用一个iframe标签去加载share_url这个字段的地址去加载内容，否则页面显示就会是空白的。\n\n这样的情况有很多，接口的功能相同，但是返回的字段结构确是不同的，这时候就需要去分析每个接口，在布局方面注意想到不同情况下使展示方面不出现问题。\n\n#### 流程问题\n\n另一个需要去想的就是使用流程方面的问题。\n\n比如，从列表页进入详情页返回时应该要回到当前列表的位置。如下：\n\n```js\n // 判断从哪里来,如果是详情页就不重新请求,并返回上次列表位置\n        if (transition.from.name === 'detail') {\n          _this.$nextTick(function () {\n            window.document.body.scrollTop = window.sessionStorage.scrollTop\n          })\n        } else {\n          _this.getTheme()\n          window.document.body.scrollTop = 0\n        }\n```\n\n进到列表页的可以从详情页返回到列表页，可以从侧边栏选择不同主题进到列表页，所以就需要判断，到底是从那个路由进来的，在不同路由时触发不同的动作。从详情页到列表页就应该回到上次的位置，从侧边栏进入就应该从新请求数据，并返回最顶部。\n\n再比如，有时下个页面会需要一些上个页面的数据，你通过哪种方式携带过去？是通过url，还是通过sessionStorage。\n\n#### 布局\n\n主要用了flexible和flex的布局方案，flexible是因为是移动端页面，根据屏幕大小可以让盒子的尺寸适应屏幕，flex可能不是很兼容pc端一些低级浏览器，但是如果在移动端，基本都支持flex，用flex也可以免去浮动带来的一些特殊情况（比如改变webview的字体大小带来的浮动布局变乱），和绝对定位应用不灵活的缺点。\n\n********\n\n### 问题\n\n#### 知乎的图片防盗链\n\n知乎的图片可能会通过请求头的referer参数判断，如果不是指定的域名会返回403，如果精通后台的同学，可以去访问这些图片来缓存这些图片，我是搜索到了一个相对简单一些的办法，[点击链接](http://tangrui.win/2016/01/09/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%BD%BB%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5/)，主要用到的是[Images.weserv.nl](https://images.weserv.nl/)这个网站，可以缓存图片，而且可以修改图片的尺寸大小。\n\n具体是我自定义了一个过滤器，在需要用到地方，把知乎的url替换成这个图片代理网站的url，这样图片就可以显示了。\n\n```js\nexports.replaceUrl = (srcUrl) => {\n  return srcUrl.replace(/http\\w{0,1}:\\/\\/p/g, 'https://images.weserv.nl/?url=p')\n}\n```\n\n#### 知乎接口跨域问题\n\n接口跨域后浏览器是会禁止的，我试了一下jsonp，但是知乎的接口好像不支持jsonp。所以我们只能是在后台转发这个请求。我也是临时现学了一下nginx，用nginx起了一个服务，所有通过api.yatessss.com/news-at/xxxxxx的请求都会替换成http://news-at.zhihu.com/xxxxxx。下面是nginx配置：\n\n```js\nserver {\n        listen       8888;\n        server_name  api.yatessss.com;\n\tlocation /news-at/{\n\t    proxy_pass http://news-at.zhihu.com/;\n\t    add_header Content-Type \"text/plain;charset=utf-8\";\n\t    add_header 'Access-Control-Allow-Origin' 'http://zhihudaily-vue.yatessss.com';\n\t    add_header 'Access-Control-Allow-Credentials' 'true';\n\t    add_header 'Access-Control-Allow-Methods' 'GET';\n\t}\n}\n```\n\n还有一种方法是听同学说的，用fetch api不会出现跨域的问题，但是我自己没有试过，有兴趣的同学不妨去了解一下试一下。\n\n另另外一种方法，论坛上v友说的，可以用vue里config/index.js 里面的 proxyTable可以代理转发api，我没有试过，但是我觉得这个应该是最简单的方法了，我要去了解一下。\n\n#### 组件复用问题\n\n虽说vue是可以组件化得，我在这里也用到了，但是组件化是一个需要考虑每个应用场景的，同一个组件在不同的view中，展示的会有不一样的地方，所以每种情况显示哪些内容都是需要考虑的。\n\n比如：列表页的每个话题栏`li`，话题栏是一个组件，但是话题栏有些是没有图片的当没有图片时，你的话题栏`li`的高度可以要自适应，如果多图图片右下角要给出提示。而进入到专栏列表时话题栏左下部需要有时间，而在平时是没有的这个也需要去注意。\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-12.png)\n\n#### 获取不到scrollTop的值\n\n这个其实是css的问题，以前从来没有碰到过这样的问题。如果在给body设置了`overflow`这个属性是scroll后就无法获取到scrollTop的值了，所以如果碰到上拉加载更多的时候要尤其注意一下这个问题。\n\n因为我会有一个蒙层，在蒙层出现的时候蒙层下方的列表就不能滑动了，在这里我是给body的`style`加了一个`overflow：hidden`这样一个属性。在蒙层消失后在改变为`overflow：auto`所以才会出现我上述的这个问题。\n\n解决办法是使用添加移除class的方式来添加这个属性，或者是使用`overflow：initial`这个属性。\n\n#### 一些过滤器方面的积累\n\n平时我们在完成工作的过程中，总会遇到后台返回的字符串可能会不太合心意，比如后台python返回给我们的时间戳是10位的，而js生成的是13位的。这就需要我们来处理一下了，另外时间戳的格式化也需要处理；一般后台传回来的金额都是以分为单位的，而一般前端展示是以元为单位的，所以也需要单位转换的方法。\n\n在我们平时的工作当中逐渐积累在遇到相同的问题时就会更加的得心应手了。\n\n#### 动态修改header的title\n\napp中列表页的header上的文字可以随着列表上拉，到相应的日期显示对应的文字，这个目前有一个解决的办法，是判断列表距离顶部的位置，当距离小于小于零的时候就去把他改变成对应的日期，主要用到的是`getBoundingClientRect`这个api，他主要是可以获取选择元素位于当前视口的位置。具体可以看这个资料：[用Javascript获取页面元素的位置](http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html)。但是在iphone中会有在滚动时dom无法及时更新这个问题，搜索了一下暂时没找到解决办法。\n\n#### iphone在滚动时dom无法及时更新\n\n这里有两个答案：\n\n[JavaScript DOM changes in touchmove delayed until scroll ends on mobile Safari](http://stackoverflow.com/questions/10482227/javascript-dom-changes-in-touchmove-delayed-until-scroll-ends-on-mobile-safari)\n\n[移动端onscroll事件在部分浏览器内不能实时触发](https://segmentfault.com/q/1010000004453730)\n\n*******\n\n### 不足\n\n虽然完成了大多数功能，是其实可以优化的地方有很多，最大的优化点，没有使用vuex来管理数据状态，现在所有的都是耦合在项目里的，都是通过变量在组件当中互相传递状态的。因为我还没有学习vuex所以在这里就没有用到，在后面学习了vuex后，我会重新优化一下这个部分。\n\n没有加入手势功能，比如在侧边栏出现的时候，向左滑动来收起侧边栏比点击要自然很多，vue也专门有一个[手势功能的库](https://github.com/vuejs/vue-touch)，所以这个部分也是可以优化的。\n\n","source":"_posts/2016-07-08-使用vue完成知乎日报web版.md","raw":"---\nlayout: post\ntitle: 使用vue完成知乎日报web版\ndate: 2016-07-08\ntags: ['vue','知乎日报']\ncategories: vue\n---\n\n### 在线地址\n\n[demo地址](http://zhihudaily-vue.yatessss.com/)\n\n[github地址](https://github.com/yatessss/zhihudaily-vue)\n\n### 运行截图\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-13.png)\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-14.png)\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-15.png)\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-16.png)\n\n### 运行动图\n\n运行过程：首页-->轮播-->侧滑栏-->详情页-->分享-->评论页-->专栏列表-->详情页-->个人页-->更改为夜间模式-->运行-->主题日报\n\n[如需观看请在wifi下打开此地址](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picUntitled11.gif)\n\n### 制作起因\n\n前段时间在github上看到了知乎日报的API和一个用vue制作的知乎日报，觉得自己也应该试着做一个用来练习练习vue。制作历时两周，基本上是仿照安卓版知乎日报的ui做的，功能上除了一些需要登录后完成的功能如评论点赞等，基本上都实现了。可能在不同手机浏览器里会出现不兼容的现象。在chrome中可以比较好的运行。\n\n下面就来介绍一下整个过程中，和遇到了哪些比较问题，是如何解决或者是变通的。\n\n### 过程\n\n#### 项目搭建\n\n使用的构建工具是webpack，但是我其实对构建项目上并没有很多经验，主要是应用了vue-cli这个脚手架工具，在vue-cli生成的项目的基础上做了一些小的修改，比如：因为是移动端的页面，用了flexible，所以加了postcss来处理px和rem之间的转换。\n\n项目目录基本维持了vue-cli的目录结构，只是多加了一个view目录来存放每个路由的页面，把跟路由直接写进了入口的html文件内。\n\n### 分析接口\n\n其中很主要的一个工作就是分析接口中返回数据的格式，因为有些接口可能会是同一个但是返回的数据接口可能是不一样的。\n\n比如：推荐者列表这个接口，有主编和没有主编的返回的数据接口是不一样的。\n\n比如：日报详情页面，首页日报和主题日报可能就是不一样的，有些主题日报并没有返回body这个字段，所以你需要判断如果没有body这个字段，就需要用一个iframe标签去加载share_url这个字段的地址去加载内容，否则页面显示就会是空白的。\n\n这样的情况有很多，接口的功能相同，但是返回的字段结构确是不同的，这时候就需要去分析每个接口，在布局方面注意想到不同情况下使展示方面不出现问题。\n\n#### 流程问题\n\n另一个需要去想的就是使用流程方面的问题。\n\n比如，从列表页进入详情页返回时应该要回到当前列表的位置。如下：\n\n```js\n // 判断从哪里来,如果是详情页就不重新请求,并返回上次列表位置\n        if (transition.from.name === 'detail') {\n          _this.$nextTick(function () {\n            window.document.body.scrollTop = window.sessionStorage.scrollTop\n          })\n        } else {\n          _this.getTheme()\n          window.document.body.scrollTop = 0\n        }\n```\n\n进到列表页的可以从详情页返回到列表页，可以从侧边栏选择不同主题进到列表页，所以就需要判断，到底是从那个路由进来的，在不同路由时触发不同的动作。从详情页到列表页就应该回到上次的位置，从侧边栏进入就应该从新请求数据，并返回最顶部。\n\n再比如，有时下个页面会需要一些上个页面的数据，你通过哪种方式携带过去？是通过url，还是通过sessionStorage。\n\n#### 布局\n\n主要用了flexible和flex的布局方案，flexible是因为是移动端页面，根据屏幕大小可以让盒子的尺寸适应屏幕，flex可能不是很兼容pc端一些低级浏览器，但是如果在移动端，基本都支持flex，用flex也可以免去浮动带来的一些特殊情况（比如改变webview的字体大小带来的浮动布局变乱），和绝对定位应用不灵活的缺点。\n\n********\n\n### 问题\n\n#### 知乎的图片防盗链\n\n知乎的图片可能会通过请求头的referer参数判断，如果不是指定的域名会返回403，如果精通后台的同学，可以去访问这些图片来缓存这些图片，我是搜索到了一个相对简单一些的办法，[点击链接](http://tangrui.win/2016/01/09/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%BD%BB%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5/)，主要用到的是[Images.weserv.nl](https://images.weserv.nl/)这个网站，可以缓存图片，而且可以修改图片的尺寸大小。\n\n具体是我自定义了一个过滤器，在需要用到地方，把知乎的url替换成这个图片代理网站的url，这样图片就可以显示了。\n\n```js\nexports.replaceUrl = (srcUrl) => {\n  return srcUrl.replace(/http\\w{0,1}:\\/\\/p/g, 'https://images.weserv.nl/?url=p')\n}\n```\n\n#### 知乎接口跨域问题\n\n接口跨域后浏览器是会禁止的，我试了一下jsonp，但是知乎的接口好像不支持jsonp。所以我们只能是在后台转发这个请求。我也是临时现学了一下nginx，用nginx起了一个服务，所有通过api.yatessss.com/news-at/xxxxxx的请求都会替换成http://news-at.zhihu.com/xxxxxx。下面是nginx配置：\n\n```js\nserver {\n        listen       8888;\n        server_name  api.yatessss.com;\n\tlocation /news-at/{\n\t    proxy_pass http://news-at.zhihu.com/;\n\t    add_header Content-Type \"text/plain;charset=utf-8\";\n\t    add_header 'Access-Control-Allow-Origin' 'http://zhihudaily-vue.yatessss.com';\n\t    add_header 'Access-Control-Allow-Credentials' 'true';\n\t    add_header 'Access-Control-Allow-Methods' 'GET';\n\t}\n}\n```\n\n还有一种方法是听同学说的，用fetch api不会出现跨域的问题，但是我自己没有试过，有兴趣的同学不妨去了解一下试一下。\n\n另另外一种方法，论坛上v友说的，可以用vue里config/index.js 里面的 proxyTable可以代理转发api，我没有试过，但是我觉得这个应该是最简单的方法了，我要去了解一下。\n\n#### 组件复用问题\n\n虽说vue是可以组件化得，我在这里也用到了，但是组件化是一个需要考虑每个应用场景的，同一个组件在不同的view中，展示的会有不一样的地方，所以每种情况显示哪些内容都是需要考虑的。\n\n比如：列表页的每个话题栏`li`，话题栏是一个组件，但是话题栏有些是没有图片的当没有图片时，你的话题栏`li`的高度可以要自适应，如果多图图片右下角要给出提示。而进入到专栏列表时话题栏左下部需要有时间，而在平时是没有的这个也需要去注意。\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-12.png)\n\n#### 获取不到scrollTop的值\n\n这个其实是css的问题，以前从来没有碰到过这样的问题。如果在给body设置了`overflow`这个属性是scroll后就无法获取到scrollTop的值了，所以如果碰到上拉加载更多的时候要尤其注意一下这个问题。\n\n因为我会有一个蒙层，在蒙层出现的时候蒙层下方的列表就不能滑动了，在这里我是给body的`style`加了一个`overflow：hidden`这样一个属性。在蒙层消失后在改变为`overflow：auto`所以才会出现我上述的这个问题。\n\n解决办法是使用添加移除class的方式来添加这个属性，或者是使用`overflow：initial`这个属性。\n\n#### 一些过滤器方面的积累\n\n平时我们在完成工作的过程中，总会遇到后台返回的字符串可能会不太合心意，比如后台python返回给我们的时间戳是10位的，而js生成的是13位的。这就需要我们来处理一下了，另外时间戳的格式化也需要处理；一般后台传回来的金额都是以分为单位的，而一般前端展示是以元为单位的，所以也需要单位转换的方法。\n\n在我们平时的工作当中逐渐积累在遇到相同的问题时就会更加的得心应手了。\n\n#### 动态修改header的title\n\napp中列表页的header上的文字可以随着列表上拉，到相应的日期显示对应的文字，这个目前有一个解决的办法，是判断列表距离顶部的位置，当距离小于小于零的时候就去把他改变成对应的日期，主要用到的是`getBoundingClientRect`这个api，他主要是可以获取选择元素位于当前视口的位置。具体可以看这个资料：[用Javascript获取页面元素的位置](http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html)。但是在iphone中会有在滚动时dom无法及时更新这个问题，搜索了一下暂时没找到解决办法。\n\n#### iphone在滚动时dom无法及时更新\n\n这里有两个答案：\n\n[JavaScript DOM changes in touchmove delayed until scroll ends on mobile Safari](http://stackoverflow.com/questions/10482227/javascript-dom-changes-in-touchmove-delayed-until-scroll-ends-on-mobile-safari)\n\n[移动端onscroll事件在部分浏览器内不能实时触发](https://segmentfault.com/q/1010000004453730)\n\n*******\n\n### 不足\n\n虽然完成了大多数功能，是其实可以优化的地方有很多，最大的优化点，没有使用vuex来管理数据状态，现在所有的都是耦合在项目里的，都是通过变量在组件当中互相传递状态的。因为我还没有学习vuex所以在这里就没有用到，在后面学习了vuex后，我会重新优化一下这个部分。\n\n没有加入手势功能，比如在侧边栏出现的时候，向左滑动来收起侧边栏比点击要自然很多，vue也专门有一个[手势功能的库](https://github.com/vuejs/vue-touch)，所以这个部分也是可以优化的。\n\n","slug":"使用vue完成知乎日报web版","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1zu002hsq5ljknkq66v","content":"<h3 id=\"在线地址\"><a href=\"#在线地址\" class=\"headerlink\" title=\"在线地址\"></a>在线地址</h3><p><a href=\"http://zhihudaily-vue.yatessss.com/\" target=\"_blank\" rel=\"external\">demo地址</a></p>\n<p><a href=\"https://github.com/yatessss/zhihudaily-vue\" target=\"_blank\" rel=\"external\">github地址</a></p>\n<h3 id=\"运行截图\"><a href=\"#运行截图\" class=\"headerlink\" title=\"运行截图\"></a>运行截图</h3><p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-13.png\" alt=\"\"><br><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-14.png\" alt=\"\"><br><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-15.png\" alt=\"\"><br><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-16.png\" alt=\"\"></p>\n<h3 id=\"运行动图\"><a href=\"#运行动图\" class=\"headerlink\" title=\"运行动图\"></a>运行动图</h3><p>运行过程：首页–&gt;轮播–&gt;侧滑栏–&gt;详情页–&gt;分享–&gt;评论页–&gt;专栏列表–&gt;详情页–&gt;个人页–&gt;更改为夜间模式–&gt;运行–&gt;主题日报</p>\n<p><a href=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picUntitled11.gif\" target=\"_blank\" rel=\"external\">如需观看请在wifi下打开此地址</a></p>\n<h3 id=\"制作起因\"><a href=\"#制作起因\" class=\"headerlink\" title=\"制作起因\"></a>制作起因</h3><p>前段时间在github上看到了知乎日报的API和一个用vue制作的知乎日报，觉得自己也应该试着做一个用来练习练习vue。制作历时两周，基本上是仿照安卓版知乎日报的ui做的，功能上除了一些需要登录后完成的功能如评论点赞等，基本上都实现了。可能在不同手机浏览器里会出现不兼容的现象。在chrome中可以比较好的运行。</p>\n<p>下面就来介绍一下整个过程中，和遇到了哪些比较问题，是如何解决或者是变通的。</p>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><h4 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h4><p>使用的构建工具是webpack，但是我其实对构建项目上并没有很多经验，主要是应用了vue-cli这个脚手架工具，在vue-cli生成的项目的基础上做了一些小的修改，比如：因为是移动端的页面，用了flexible，所以加了postcss来处理px和rem之间的转换。</p>\n<p>项目目录基本维持了vue-cli的目录结构，只是多加了一个view目录来存放每个路由的页面，把跟路由直接写进了入口的html文件内。</p>\n<h3 id=\"分析接口\"><a href=\"#分析接口\" class=\"headerlink\" title=\"分析接口\"></a>分析接口</h3><p>其中很主要的一个工作就是分析接口中返回数据的格式，因为有些接口可能会是同一个但是返回的数据接口可能是不一样的。</p>\n<p>比如：推荐者列表这个接口，有主编和没有主编的返回的数据接口是不一样的。</p>\n<p>比如：日报详情页面，首页日报和主题日报可能就是不一样的，有些主题日报并没有返回body这个字段，所以你需要判断如果没有body这个字段，就需要用一个iframe标签去加载share_url这个字段的地址去加载内容，否则页面显示就会是空白的。</p>\n<p>这样的情况有很多，接口的功能相同，但是返回的字段结构确是不同的，这时候就需要去分析每个接口，在布局方面注意想到不同情况下使展示方面不出现问题。</p>\n<h4 id=\"流程问题\"><a href=\"#流程问题\" class=\"headerlink\" title=\"流程问题\"></a>流程问题</h4><p>另一个需要去想的就是使用流程方面的问题。</p>\n<p>比如，从列表页进入详情页返回时应该要回到当前列表的位置。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断从哪里来,如果是详情页就不重新请求,并返回上次列表位置</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (transition.from.name === <span class=\"string\">'detail'</span>) &#123;</span><br><span class=\"line\">         _this.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"built_in\">window</span>.document.body.scrollTop = <span class=\"built_in\">window</span>.sessionStorage.scrollTop</span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         _this.getTheme()</span><br><span class=\"line\">         <span class=\"built_in\">window</span>.document.body.scrollTop = <span class=\"number\">0</span></span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>进到列表页的可以从详情页返回到列表页，可以从侧边栏选择不同主题进到列表页，所以就需要判断，到底是从那个路由进来的，在不同路由时触发不同的动作。从详情页到列表页就应该回到上次的位置，从侧边栏进入就应该从新请求数据，并返回最顶部。</p>\n<p>再比如，有时下个页面会需要一些上个页面的数据，你通过哪种方式携带过去？是通过url，还是通过sessionStorage。</p>\n<h4 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h4><p>主要用了flexible和flex的布局方案，flexible是因为是移动端页面，根据屏幕大小可以让盒子的尺寸适应屏幕，flex可能不是很兼容pc端一些低级浏览器，但是如果在移动端，基本都支持flex，用flex也可以免去浮动带来的一些特殊情况（比如改变webview的字体大小带来的浮动布局变乱），和绝对定位应用不灵活的缺点。</p>\n<hr>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><h4 id=\"知乎的图片防盗链\"><a href=\"#知乎的图片防盗链\" class=\"headerlink\" title=\"知乎的图片防盗链\"></a>知乎的图片防盗链</h4><p>知乎的图片可能会通过请求头的referer参数判断，如果不是指定的域名会返回403，如果精通后台的同学，可以去访问这些图片来缓存这些图片，我是搜索到了一个相对简单一些的办法，<a href=\"http://tangrui.win/2016/01/09/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%BD%BB%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5/\" target=\"_blank\" rel=\"external\">点击链接</a>，主要用到的是<a href=\"https://images.weserv.nl/\" target=\"_blank\" rel=\"external\">Images.weserv.nl</a>这个网站，可以缓存图片，而且可以修改图片的尺寸大小。</p>\n<p>具体是我自定义了一个过滤器，在需要用到地方，把知乎的url替换成这个图片代理网站的url，这样图片就可以显示了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.replaceUrl = (srcUrl) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> srcUrl.replace(<span class=\"regexp\">/http\\w&#123;0,1&#125;:\\/\\/p/g</span>, <span class=\"string\">'https://images.weserv.nl/?url=p'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"知乎接口跨域问题\"><a href=\"#知乎接口跨域问题\" class=\"headerlink\" title=\"知乎接口跨域问题\"></a>知乎接口跨域问题</h4><p>接口跨域后浏览器是会禁止的，我试了一下jsonp，但是知乎的接口好像不支持jsonp。所以我们只能是在后台转发这个请求。我也是临时现学了一下nginx，用nginx起了一个服务，所有通过api.yatessss.com/news-at/xxxxxx的请求都会替换成<a href=\"http://news-at.zhihu.com/xxxxxx。下面是nginx配置：\" target=\"_blank\" rel=\"external\">http://news-at.zhihu.com/xxxxxx。下面是nginx配置：</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       <span class=\"number\">8888</span>;</span><br><span class=\"line\">        server_name  api.yatessss.com;</span><br><span class=\"line\">\tlocation /news-at/&#123;</span><br><span class=\"line\">\t    proxy_pass http:<span class=\"comment\">//news-at.zhihu.com/;</span></span><br><span class=\"line\">\t    add_header Content-Type <span class=\"string\">\"text/plain;charset=utf-8\"</span>;</span><br><span class=\"line\">\t    add_header <span class=\"string\">'Access-Control-Allow-Origin'</span> <span class=\"string\">'http://zhihudaily-vue.yatessss.com'</span>;</span><br><span class=\"line\">\t    add_header <span class=\"string\">'Access-Control-Allow-Credentials'</span> <span class=\"string\">'true'</span>;</span><br><span class=\"line\">\t    add_header <span class=\"string\">'Access-Control-Allow-Methods'</span> <span class=\"string\">'GET'</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一种方法是听同学说的，用fetch api不会出现跨域的问题，但是我自己没有试过，有兴趣的同学不妨去了解一下试一下。</p>\n<p>另另外一种方法，论坛上v友说的，可以用vue里config/index.js 里面的 proxyTable可以代理转发api，我没有试过，但是我觉得这个应该是最简单的方法了，我要去了解一下。</p>\n<h4 id=\"组件复用问题\"><a href=\"#组件复用问题\" class=\"headerlink\" title=\"组件复用问题\"></a>组件复用问题</h4><p>虽说vue是可以组件化得，我在这里也用到了，但是组件化是一个需要考虑每个应用场景的，同一个组件在不同的view中，展示的会有不一样的地方，所以每种情况显示哪些内容都是需要考虑的。</p>\n<p>比如：列表页的每个话题栏<code>li</code>，话题栏是一个组件，但是话题栏有些是没有图片的当没有图片时，你的话题栏<code>li</code>的高度可以要自适应，如果多图图片右下角要给出提示。而进入到专栏列表时话题栏左下部需要有时间，而在平时是没有的这个也需要去注意。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-12.png\" alt=\"\"></p>\n<h4 id=\"获取不到scrollTop的值\"><a href=\"#获取不到scrollTop的值\" class=\"headerlink\" title=\"获取不到scrollTop的值\"></a>获取不到scrollTop的值</h4><p>这个其实是css的问题，以前从来没有碰到过这样的问题。如果在给body设置了<code>overflow</code>这个属性是scroll后就无法获取到scrollTop的值了，所以如果碰到上拉加载更多的时候要尤其注意一下这个问题。</p>\n<p>因为我会有一个蒙层，在蒙层出现的时候蒙层下方的列表就不能滑动了，在这里我是给body的<code>style</code>加了一个<code>overflow：hidden</code>这样一个属性。在蒙层消失后在改变为<code>overflow：auto</code>所以才会出现我上述的这个问题。</p>\n<p>解决办法是使用添加移除class的方式来添加这个属性，或者是使用<code>overflow：initial</code>这个属性。</p>\n<h4 id=\"一些过滤器方面的积累\"><a href=\"#一些过滤器方面的积累\" class=\"headerlink\" title=\"一些过滤器方面的积累\"></a>一些过滤器方面的积累</h4><p>平时我们在完成工作的过程中，总会遇到后台返回的字符串可能会不太合心意，比如后台python返回给我们的时间戳是10位的，而js生成的是13位的。这就需要我们来处理一下了，另外时间戳的格式化也需要处理；一般后台传回来的金额都是以分为单位的，而一般前端展示是以元为单位的，所以也需要单位转换的方法。</p>\n<p>在我们平时的工作当中逐渐积累在遇到相同的问题时就会更加的得心应手了。</p>\n<h4 id=\"动态修改header的title\"><a href=\"#动态修改header的title\" class=\"headerlink\" title=\"动态修改header的title\"></a>动态修改header的title</h4><p>app中列表页的header上的文字可以随着列表上拉，到相应的日期显示对应的文字，这个目前有一个解决的办法，是判断列表距离顶部的位置，当距离小于小于零的时候就去把他改变成对应的日期，主要用到的是<code>getBoundingClientRect</code>这个api，他主要是可以获取选择元素位于当前视口的位置。具体可以看这个资料：<a href=\"http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html\" target=\"_blank\" rel=\"external\">用Javascript获取页面元素的位置</a>。但是在iphone中会有在滚动时dom无法及时更新这个问题，搜索了一下暂时没找到解决办法。</p>\n<h4 id=\"iphone在滚动时dom无法及时更新\"><a href=\"#iphone在滚动时dom无法及时更新\" class=\"headerlink\" title=\"iphone在滚动时dom无法及时更新\"></a>iphone在滚动时dom无法及时更新</h4><p>这里有两个答案：</p>\n<p><a href=\"http://stackoverflow.com/questions/10482227/javascript-dom-changes-in-touchmove-delayed-until-scroll-ends-on-mobile-safari\" target=\"_blank\" rel=\"external\">JavaScript DOM changes in touchmove delayed until scroll ends on mobile Safari</a></p>\n<p><a href=\"https://segmentfault.com/q/1010000004453730\" target=\"_blank\" rel=\"external\">移动端onscroll事件在部分浏览器内不能实时触发</a></p>\n<hr>\n<h3 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h3><p>虽然完成了大多数功能，是其实可以优化的地方有很多，最大的优化点，没有使用vuex来管理数据状态，现在所有的都是耦合在项目里的，都是通过变量在组件当中互相传递状态的。因为我还没有学习vuex所以在这里就没有用到，在后面学习了vuex后，我会重新优化一下这个部分。</p>\n<p>没有加入手势功能，比如在侧边栏出现的时候，向左滑动来收起侧边栏比点击要自然很多，vue也专门有一个<a href=\"https://github.com/vuejs/vue-touch\" target=\"_blank\" rel=\"external\">手势功能的库</a>，所以这个部分也是可以优化的。</p>\n","excerpt":"","more":"<h3 id=\"在线地址\"><a href=\"#在线地址\" class=\"headerlink\" title=\"在线地址\"></a>在线地址</h3><p><a href=\"http://zhihudaily-vue.yatessss.com/\">demo地址</a></p>\n<p><a href=\"https://github.com/yatessss/zhihudaily-vue\">github地址</a></p>\n<h3 id=\"运行截图\"><a href=\"#运行截图\" class=\"headerlink\" title=\"运行截图\"></a>运行截图</h3><p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-13.png\" alt=\"\"><br><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-14.png\" alt=\"\"><br><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-15.png\" alt=\"\"><br><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-16.png\" alt=\"\"></p>\n<h3 id=\"运行动图\"><a href=\"#运行动图\" class=\"headerlink\" title=\"运行动图\"></a>运行动图</h3><p>运行过程：首页–&gt;轮播–&gt;侧滑栏–&gt;详情页–&gt;分享–&gt;评论页–&gt;专栏列表–&gt;详情页–&gt;个人页–&gt;更改为夜间模式–&gt;运行–&gt;主题日报</p>\n<p><a href=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picUntitled11.gif\">如需观看请在wifi下打开此地址</a></p>\n<h3 id=\"制作起因\"><a href=\"#制作起因\" class=\"headerlink\" title=\"制作起因\"></a>制作起因</h3><p>前段时间在github上看到了知乎日报的API和一个用vue制作的知乎日报，觉得自己也应该试着做一个用来练习练习vue。制作历时两周，基本上是仿照安卓版知乎日报的ui做的，功能上除了一些需要登录后完成的功能如评论点赞等，基本上都实现了。可能在不同手机浏览器里会出现不兼容的现象。在chrome中可以比较好的运行。</p>\n<p>下面就来介绍一下整个过程中，和遇到了哪些比较问题，是如何解决或者是变通的。</p>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><h4 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h4><p>使用的构建工具是webpack，但是我其实对构建项目上并没有很多经验，主要是应用了vue-cli这个脚手架工具，在vue-cli生成的项目的基础上做了一些小的修改，比如：因为是移动端的页面，用了flexible，所以加了postcss来处理px和rem之间的转换。</p>\n<p>项目目录基本维持了vue-cli的目录结构，只是多加了一个view目录来存放每个路由的页面，把跟路由直接写进了入口的html文件内。</p>\n<h3 id=\"分析接口\"><a href=\"#分析接口\" class=\"headerlink\" title=\"分析接口\"></a>分析接口</h3><p>其中很主要的一个工作就是分析接口中返回数据的格式，因为有些接口可能会是同一个但是返回的数据接口可能是不一样的。</p>\n<p>比如：推荐者列表这个接口，有主编和没有主编的返回的数据接口是不一样的。</p>\n<p>比如：日报详情页面，首页日报和主题日报可能就是不一样的，有些主题日报并没有返回body这个字段，所以你需要判断如果没有body这个字段，就需要用一个iframe标签去加载share_url这个字段的地址去加载内容，否则页面显示就会是空白的。</p>\n<p>这样的情况有很多，接口的功能相同，但是返回的字段结构确是不同的，这时候就需要去分析每个接口，在布局方面注意想到不同情况下使展示方面不出现问题。</p>\n<h4 id=\"流程问题\"><a href=\"#流程问题\" class=\"headerlink\" title=\"流程问题\"></a>流程问题</h4><p>另一个需要去想的就是使用流程方面的问题。</p>\n<p>比如，从列表页进入详情页返回时应该要回到当前列表的位置。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断从哪里来,如果是详情页就不重新请求,并返回上次列表位置</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (transition.from.name === <span class=\"string\">'detail'</span>) &#123;</span><br><span class=\"line\">         _this.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"built_in\">window</span>.document.body.scrollTop = <span class=\"built_in\">window</span>.sessionStorage.scrollTop</span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         _this.getTheme()</span><br><span class=\"line\">         <span class=\"built_in\">window</span>.document.body.scrollTop = <span class=\"number\">0</span></span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>进到列表页的可以从详情页返回到列表页，可以从侧边栏选择不同主题进到列表页，所以就需要判断，到底是从那个路由进来的，在不同路由时触发不同的动作。从详情页到列表页就应该回到上次的位置，从侧边栏进入就应该从新请求数据，并返回最顶部。</p>\n<p>再比如，有时下个页面会需要一些上个页面的数据，你通过哪种方式携带过去？是通过url，还是通过sessionStorage。</p>\n<h4 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h4><p>主要用了flexible和flex的布局方案，flexible是因为是移动端页面，根据屏幕大小可以让盒子的尺寸适应屏幕，flex可能不是很兼容pc端一些低级浏览器，但是如果在移动端，基本都支持flex，用flex也可以免去浮动带来的一些特殊情况（比如改变webview的字体大小带来的浮动布局变乱），和绝对定位应用不灵活的缺点。</p>\n<hr>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><h4 id=\"知乎的图片防盗链\"><a href=\"#知乎的图片防盗链\" class=\"headerlink\" title=\"知乎的图片防盗链\"></a>知乎的图片防盗链</h4><p>知乎的图片可能会通过请求头的referer参数判断，如果不是指定的域名会返回403，如果精通后台的同学，可以去访问这些图片来缓存这些图片，我是搜索到了一个相对简单一些的办法，<a href=\"http://tangrui.win/2016/01/09/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%BD%BB%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5/\">点击链接</a>，主要用到的是<a href=\"https://images.weserv.nl/\">Images.weserv.nl</a>这个网站，可以缓存图片，而且可以修改图片的尺寸大小。</p>\n<p>具体是我自定义了一个过滤器，在需要用到地方，把知乎的url替换成这个图片代理网站的url，这样图片就可以显示了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exports.replaceUrl = (srcUrl) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> srcUrl.replace(<span class=\"regexp\">/http\\w&#123;0,1&#125;:\\/\\/p/g</span>, <span class=\"string\">'https://images.weserv.nl/?url=p'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"知乎接口跨域问题\"><a href=\"#知乎接口跨域问题\" class=\"headerlink\" title=\"知乎接口跨域问题\"></a>知乎接口跨域问题</h4><p>接口跨域后浏览器是会禁止的，我试了一下jsonp，但是知乎的接口好像不支持jsonp。所以我们只能是在后台转发这个请求。我也是临时现学了一下nginx，用nginx起了一个服务，所有通过api.yatessss.com/news-at/xxxxxx的请求都会替换成<a href=\"http://news-at.zhihu.com/xxxxxx。下面是nginx配置：\">http://news-at.zhihu.com/xxxxxx。下面是nginx配置：</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       <span class=\"number\">8888</span>;</span><br><span class=\"line\">        server_name  api.yatessss.com;</span><br><span class=\"line\">\tlocation /news-at/&#123;</span><br><span class=\"line\">\t    proxy_pass http:<span class=\"comment\">//news-at.zhihu.com/;</span></span><br><span class=\"line\">\t    add_header Content-Type <span class=\"string\">\"text/plain;charset=utf-8\"</span>;</span><br><span class=\"line\">\t    add_header <span class=\"string\">'Access-Control-Allow-Origin'</span> <span class=\"string\">'http://zhihudaily-vue.yatessss.com'</span>;</span><br><span class=\"line\">\t    add_header <span class=\"string\">'Access-Control-Allow-Credentials'</span> <span class=\"string\">'true'</span>;</span><br><span class=\"line\">\t    add_header <span class=\"string\">'Access-Control-Allow-Methods'</span> <span class=\"string\">'GET'</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一种方法是听同学说的，用fetch api不会出现跨域的问题，但是我自己没有试过，有兴趣的同学不妨去了解一下试一下。</p>\n<p>另另外一种方法，论坛上v友说的，可以用vue里config/index.js 里面的 proxyTable可以代理转发api，我没有试过，但是我觉得这个应该是最简单的方法了，我要去了解一下。</p>\n<h4 id=\"组件复用问题\"><a href=\"#组件复用问题\" class=\"headerlink\" title=\"组件复用问题\"></a>组件复用问题</h4><p>虽说vue是可以组件化得，我在这里也用到了，但是组件化是一个需要考虑每个应用场景的，同一个组件在不同的view中，展示的会有不一样的地方，所以每种情况显示哪些内容都是需要考虑的。</p>\n<p>比如：列表页的每个话题栏<code>li</code>，话题栏是一个组件，但是话题栏有些是没有图片的当没有图片时，你的话题栏<code>li</code>的高度可以要自适应，如果多图图片右下角要给出提示。而进入到专栏列表时话题栏左下部需要有时间，而在平时是没有的这个也需要去注意。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_07_picQQ20160708-12.png\" alt=\"\"></p>\n<h4 id=\"获取不到scrollTop的值\"><a href=\"#获取不到scrollTop的值\" class=\"headerlink\" title=\"获取不到scrollTop的值\"></a>获取不到scrollTop的值</h4><p>这个其实是css的问题，以前从来没有碰到过这样的问题。如果在给body设置了<code>overflow</code>这个属性是scroll后就无法获取到scrollTop的值了，所以如果碰到上拉加载更多的时候要尤其注意一下这个问题。</p>\n<p>因为我会有一个蒙层，在蒙层出现的时候蒙层下方的列表就不能滑动了，在这里我是给body的<code>style</code>加了一个<code>overflow：hidden</code>这样一个属性。在蒙层消失后在改变为<code>overflow：auto</code>所以才会出现我上述的这个问题。</p>\n<p>解决办法是使用添加移除class的方式来添加这个属性，或者是使用<code>overflow：initial</code>这个属性。</p>\n<h4 id=\"一些过滤器方面的积累\"><a href=\"#一些过滤器方面的积累\" class=\"headerlink\" title=\"一些过滤器方面的积累\"></a>一些过滤器方面的积累</h4><p>平时我们在完成工作的过程中，总会遇到后台返回的字符串可能会不太合心意，比如后台python返回给我们的时间戳是10位的，而js生成的是13位的。这就需要我们来处理一下了，另外时间戳的格式化也需要处理；一般后台传回来的金额都是以分为单位的，而一般前端展示是以元为单位的，所以也需要单位转换的方法。</p>\n<p>在我们平时的工作当中逐渐积累在遇到相同的问题时就会更加的得心应手了。</p>\n<h4 id=\"动态修改header的title\"><a href=\"#动态修改header的title\" class=\"headerlink\" title=\"动态修改header的title\"></a>动态修改header的title</h4><p>app中列表页的header上的文字可以随着列表上拉，到相应的日期显示对应的文字，这个目前有一个解决的办法，是判断列表距离顶部的位置，当距离小于小于零的时候就去把他改变成对应的日期，主要用到的是<code>getBoundingClientRect</code>这个api，他主要是可以获取选择元素位于当前视口的位置。具体可以看这个资料：<a href=\"http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html\">用Javascript获取页面元素的位置</a>。但是在iphone中会有在滚动时dom无法及时更新这个问题，搜索了一下暂时没找到解决办法。</p>\n<h4 id=\"iphone在滚动时dom无法及时更新\"><a href=\"#iphone在滚动时dom无法及时更新\" class=\"headerlink\" title=\"iphone在滚动时dom无法及时更新\"></a>iphone在滚动时dom无法及时更新</h4><p>这里有两个答案：</p>\n<p><a href=\"http://stackoverflow.com/questions/10482227/javascript-dom-changes-in-touchmove-delayed-until-scroll-ends-on-mobile-safari\">JavaScript DOM changes in touchmove delayed until scroll ends on mobile Safari</a></p>\n<p><a href=\"https://segmentfault.com/q/1010000004453730\">移动端onscroll事件在部分浏览器内不能实时触发</a></p>\n<hr>\n<h3 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h3><p>虽然完成了大多数功能，是其实可以优化的地方有很多，最大的优化点，没有使用vuex来管理数据状态，现在所有的都是耦合在项目里的，都是通过变量在组件当中互相传递状态的。因为我还没有学习vuex所以在这里就没有用到，在后面学习了vuex后，我会重新优化一下这个部分。</p>\n<p>没有加入手势功能，比如在侧边栏出现的时候，向左滑动来收起侧边栏比点击要自然很多，vue也专门有一个<a href=\"https://github.com/vuejs/vue-touch\">手势功能的库</a>，所以这个部分也是可以优化的。</p>\n"},{"layout":"post","title":"ES6模块化","date":"2016-07-27T16:00:00.000Z","_content":"\n这几天在看vuex，模块引入这块看的有些迷，所以看了[阮大大关于模块化这部分的教程](http://es6.ruanyifeng.com/#docs/module)。然后总结了一些常用的部分。\n\n### export\n\n输出可以有两种方式：第三种是用来重命名\n\n```js\n// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n```\n\n下面的写法是不对的：\n\n```js\n// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n```\n\n还要注意输出的接口与模块内部对应的值是一个动态绑定的关系：\n\n```js\nexport var foo = 'bar';\nsetTimeout(() => foo = 'baz', 500);\n```\n\n上面代码输出变量foo，值为bar，500毫秒之后变成baz。\n\n### import\n\n使用import来加载模块\n\n```js\nimport {firstName, lastName, year} from './profile';\n```\n\n也可以使用`as`来更改引入模块的名字\n\n```js\nimport { lastName as surname } from './profile';\n```\n\n整体引入模块而不是只引入模块的一部分，可以把模块内所有的方法依次引入，也可以用*来引入：\n\n```js\nexport function area(radius) {\n  return Math.PI * radius * radius;\n}\n\nexport function circumference(radius) {\n  return 2 * Math.PI * radius;\n}\n```\n\n```js\nimport * as circle from './circle';\n\nconsole.log('圆面积：' + circle.area(4));\nconsole.log('圆周长：' + circle.circumference(14));\n```\n\n这样所有引入模块的方法都挂载到了circle这个对象上面，只需要在`circle`上取到对应的方法。\n\n### ES6模块加载实质\n\n**ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。**\n\n这句话很重要，CommonJS模块值一旦输出，内部的变化不会影响输出的值。因为他是一个值的拷贝。\n\n而ES6模块是生成一个动态的只读引用，这里有两个重点：动态引用、只读。\n\n动态，模块内部外部是会动态改变的。\n\n```js\n// lib.js\nexport let counter = 3;\nexport function incCounter() {\n  counter++;\n}\n\n// main.js\nimport { counter, incCounter } from './lib';\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n```\n\n只读，可以添加属性，但是不能重新赋值。类似于`const`\n\n```js\n// lib.js\nexport let obj = {};\n\n// main.js\nimport { obj } from './lib';\n\nobj.prop = 123; // OK\nobj = {}; // TypeError\n```\n\nexport通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。\n\n```js\n// mod.js\nfunction C() {\n  this.sum = 0;\n  this.add = function () {\n    this.sum += 1;\n  };\n  this.show = function () {\n    console.log(this.sum);\n  };\n}\n\nexport let c = new C();\n```\n\n```js\n\n// x.js\nimport {c} from './mod';\nc.add();\n\n// y.js\nimport {c} from './mod';\nc.show();\n\n// main.js\nimport './x';\nimport './y';\n\n//执行main.js\n//输出1\n\n```\n\n这就证明的是输出了同一个实例。","source":"_posts/2016-07-28-ES6模块化.md","raw":"---\nlayout: post\ntitle: ES6模块化\ndate: 2016-07-28\ncategories: ES6\n---\n\n这几天在看vuex，模块引入这块看的有些迷，所以看了[阮大大关于模块化这部分的教程](http://es6.ruanyifeng.com/#docs/module)。然后总结了一些常用的部分。\n\n### export\n\n输出可以有两种方式：第三种是用来重命名\n\n```js\n// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n```\n\n下面的写法是不对的：\n\n```js\n// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n```\n\n还要注意输出的接口与模块内部对应的值是一个动态绑定的关系：\n\n```js\nexport var foo = 'bar';\nsetTimeout(() => foo = 'baz', 500);\n```\n\n上面代码输出变量foo，值为bar，500毫秒之后变成baz。\n\n### import\n\n使用import来加载模块\n\n```js\nimport {firstName, lastName, year} from './profile';\n```\n\n也可以使用`as`来更改引入模块的名字\n\n```js\nimport { lastName as surname } from './profile';\n```\n\n整体引入模块而不是只引入模块的一部分，可以把模块内所有的方法依次引入，也可以用*来引入：\n\n```js\nexport function area(radius) {\n  return Math.PI * radius * radius;\n}\n\nexport function circumference(radius) {\n  return 2 * Math.PI * radius;\n}\n```\n\n```js\nimport * as circle from './circle';\n\nconsole.log('圆面积：' + circle.area(4));\nconsole.log('圆周长：' + circle.circumference(14));\n```\n\n这样所有引入模块的方法都挂载到了circle这个对象上面，只需要在`circle`上取到对应的方法。\n\n### ES6模块加载实质\n\n**ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。**\n\n这句话很重要，CommonJS模块值一旦输出，内部的变化不会影响输出的值。因为他是一个值的拷贝。\n\n而ES6模块是生成一个动态的只读引用，这里有两个重点：动态引用、只读。\n\n动态，模块内部外部是会动态改变的。\n\n```js\n// lib.js\nexport let counter = 3;\nexport function incCounter() {\n  counter++;\n}\n\n// main.js\nimport { counter, incCounter } from './lib';\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n```\n\n只读，可以添加属性，但是不能重新赋值。类似于`const`\n\n```js\n// lib.js\nexport let obj = {};\n\n// main.js\nimport { obj } from './lib';\n\nobj.prop = 123; // OK\nobj = {}; // TypeError\n```\n\nexport通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。\n\n```js\n// mod.js\nfunction C() {\n  this.sum = 0;\n  this.add = function () {\n    this.sum += 1;\n  };\n  this.show = function () {\n    console.log(this.sum);\n  };\n}\n\nexport let c = new C();\n```\n\n```js\n\n// x.js\nimport {c} from './mod';\nc.add();\n\n// y.js\nimport {c} from './mod';\nc.show();\n\n// main.js\nimport './x';\nimport './y';\n\n//执行main.js\n//输出1\n\n```\n\n这就证明的是输出了同一个实例。","slug":"ES6模块化","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg1zy002lsq5l7l56yw8o","content":"<p>这几天在看vuex，模块引入这块看的有些迷，所以看了<a href=\"http://es6.ruanyifeng.com/#docs/module\" target=\"_blank\" rel=\"external\">阮大大关于模块化这部分的教程</a>。然后总结了一些常用的部分。</p>\n<h3 id=\"export\"><a href=\"#export\" class=\"headerlink\" title=\"export\"></a>export</h3><p>输出可以有两种方式：第三种是用来重命名</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> m = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;m&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法三</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;n <span class=\"keyword\">as</span> m&#125;;</span><br></pre></td></tr></table></figure>\n<p>下面的写法是不对的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> m;</span><br></pre></td></tr></table></figure>\n<p>还要注意输出的接口与模块内部对应的值是一个动态绑定的关系：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">setTimeout(() =&gt; foo = <span class=\"string\">'baz'</span>, <span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码输出变量foo，值为bar，500毫秒之后变成baz。</p>\n<h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h3><p>使用import来加载模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;firstName, lastName, year&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./profile'</span>;</span><br></pre></td></tr></table></figure>\n<p>也可以使用<code>as</code>来更改引入模块的名字</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; lastName <span class=\"keyword\">as</span> surname &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./profile'</span>;</span><br></pre></td></tr></table></figure>\n<p>整体引入模块而不是只引入模块的一部分，可以把模块内所有的方法依次引入，也可以用*来引入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">radius</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * radius * radius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">circumference</span>(<span class=\"params\">radius</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI * radius;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> circle <span class=\"keyword\">from</span> <span class=\"string\">'./circle'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'圆面积：'</span> + circle.area(<span class=\"number\">4</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'圆周长：'</span> + circle.circumference(<span class=\"number\">14</span>));</span><br></pre></td></tr></table></figure>\n<p>这样所有引入模块的方法都挂载到了circle这个对象上面，只需要在<code>circle</code>上取到对应的方法。</p>\n<h3 id=\"ES6模块加载实质\"><a href=\"#ES6模块加载实质\" class=\"headerlink\" title=\"ES6模块加载实质\"></a>ES6模块加载实质</h3><p><strong>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。</strong></p>\n<p>这句话很重要，CommonJS模块值一旦输出，内部的变化不会影响输出的值。因为他是一个值的拷贝。</p>\n<p>而ES6模块是生成一个动态的只读引用，这里有两个重点：动态引用、只读。</p>\n<p>动态，模块内部外部是会动态改变的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lib.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> counter = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  counter++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; counter, incCounter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./lib'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(counter); <span class=\"comment\">// 3</span></span><br><span class=\"line\">incCounter();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(counter); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n<p>只读，可以添加属性，但是不能重新赋值。类似于<code>const</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lib.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; obj &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./lib'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.prop = <span class=\"number\">123</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">obj = &#123;&#125;; <span class=\"comment\">// TypeError</span></span><br></pre></td></tr></table></figure>\n<p>export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mod.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">C</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sum += <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.show = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sum);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// x.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;c&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./mod'</span>;</span><br><span class=\"line\">c.add();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// y.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;c&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./mod'</span>;</span><br><span class=\"line\">c.show();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./x'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./y'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//执行main.js</span></span><br><span class=\"line\"><span class=\"comment\">//输出1</span></span><br></pre></td></tr></table></figure>\n<p>这就证明的是输出了同一个实例。</p>\n","excerpt":"","more":"<p>这几天在看vuex，模块引入这块看的有些迷，所以看了<a href=\"http://es6.ruanyifeng.com/#docs/module\">阮大大关于模块化这部分的教程</a>。然后总结了一些常用的部分。</p>\n<h3 id=\"export\"><a href=\"#export\" class=\"headerlink\" title=\"export\"></a>export</h3><p>输出可以有两种方式：第三种是用来重命名</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> m = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;m&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法三</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123;n <span class=\"keyword\">as</span> m&#125;;</span><br></pre></td></tr></table></figure>\n<p>下面的写法是不对的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 报错</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> m;</span><br></pre></td></tr></table></figure>\n<p>还要注意输出的接口与模块内部对应的值是一个动态绑定的关系：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">var</span> foo = <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">setTimeout(() =&gt; foo = <span class=\"string\">'baz'</span>, <span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码输出变量foo，值为bar，500毫秒之后变成baz。</p>\n<h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h3><p>使用import来加载模块</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;firstName, lastName, year&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./profile'</span>;</span><br></pre></td></tr></table></figure>\n<p>也可以使用<code>as</code>来更改引入模块的名字</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; lastName <span class=\"keyword\">as</span> surname &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./profile'</span>;</span><br></pre></td></tr></table></figure>\n<p>整体引入模块而不是只引入模块的一部分，可以把模块内所有的方法依次引入，也可以用*来引入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">radius</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * radius * radius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">circumference</span>(<span class=\"params\">radius</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI * radius;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> circle <span class=\"keyword\">from</span> <span class=\"string\">'./circle'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'圆面积：'</span> + circle.area(<span class=\"number\">4</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'圆周长：'</span> + circle.circumference(<span class=\"number\">14</span>));</span><br></pre></td></tr></table></figure>\n<p>这样所有引入模块的方法都挂载到了circle这个对象上面，只需要在<code>circle</code>上取到对应的方法。</p>\n<h3 id=\"ES6模块加载实质\"><a href=\"#ES6模块加载实质\" class=\"headerlink\" title=\"ES6模块加载实质\"></a>ES6模块加载实质</h3><p><strong>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。</strong></p>\n<p>这句话很重要，CommonJS模块值一旦输出，内部的变化不会影响输出的值。因为他是一个值的拷贝。</p>\n<p>而ES6模块是生成一个动态的只读引用，这里有两个重点：动态引用、只读。</p>\n<p>动态，模块内部外部是会动态改变的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lib.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> counter = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  counter++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; counter, incCounter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./lib'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(counter); <span class=\"comment\">// 3</span></span><br><span class=\"line\">incCounter();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(counter); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n<p>只读，可以添加属性，但是不能重新赋值。类似于<code>const</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lib.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> obj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; obj &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./lib'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.prop = <span class=\"number\">123</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">obj = &#123;&#125;; <span class=\"comment\">// TypeError</span></span><br></pre></td></tr></table></figure>\n<p>export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mod.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">C</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.add = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sum += <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.show = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.sum);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// x.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;c&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./mod'</span>;</span><br><span class=\"line\">c.add();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// y.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;c&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./mod'</span>;</span><br><span class=\"line\">c.show();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./x'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'./y'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//执行main.js</span></span><br><span class=\"line\"><span class=\"comment\">//输出1</span></span><br></pre></td></tr></table></figure>\n<p>这就证明的是输出了同一个实例。</p>\n"},{"layout":"post","title":"一个前端的工作方法总结","date":"2016-07-31T16:00:00.000Z","_content":"\n进入前端也半年多了，在工作中也学到了一些帮助自己提高工作效率的工具、方法，和大家分享一下，知识需要慢慢的积累，光读文章是不够的需要结合平时的实践才能融会贯通，这篇文章不会涉及很多知识，会分享一些平时工作中用到的工具、方法，主要偏向于移动端的开发方面。\n\n### 跨域问题\n\n平时在调试接口的时候，难免会碰到一系列问题，因为在本地调试的时候和线上会有不同，可能会碰到跨域，和未登录的问题。\n\n跨协议、主域、子域、端口号都算跨域。具体的很多文章都讲的很详细。通常我们解决跨域使用jsonp、后端加跨域头，这两种需要后端来配合完成，还有是通过iframe来跨域。这是我们在生产时用到的办法。\n\n但是在开发的时候我们总不可能让后端同学加一个本地的跨域头把。。。jsonp是可以的，但是如果暂时后端没有配合，我们本地开发也可以用一些简单的方法来实现：\n我们可以使用浏览器插件：*Allow-Control-Allow-Origin:** ，这个插件会转发请求，然后在请求头中加上`Allow-Control-Allow-Origin: *`（插件名字简单粗暴），这样就可以使请求跨域了。\n\n*****\n\n### cookie问题\n\n像平常不知道大家会不会遇到这样的情况：在联调的时候会需要不同状态的账号切换，来看前端页面展示的不同状态是不是正常的。\n\n这时通过两个插件配合就可以比较方便的解决类似的问题：ModHeader和EditThisCookie。\n\n通过EditThisCookie来取出页面中我们需要的cookie。通过ModHeader来设置请求头加上cookie的字段。\n\n这样首先通过登录不同的账号取到不同的cookie：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160802-1.png)\n\n然后把他加到ModHeader的请求头中：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160802-2.png)\n\n通过勾选不同的cookie来切换账号就可以解决上述的问题了。\n\n其实ModHeader也可以实现跨域。因为他可以加返回头，在返回头中加入跨域的头`Access-Control-Allow-Origin: *`就可以实现跨域了。\n\n因为ModHeader可以加请求头和返回头，所以它的功能不仅仅如此，大家可以尝试着使用它。\n\n*****\n\n### 接口调试\n\n如果后台已经开发完接口，就配合跨域应该就可以了。\n\n平常经常会碰到前后端已经约定好字段了或者文档已经有了，但是后台接口还没有开发完成，所以这时候需要我们自己来mock数据。\n\n不知道大家平时是怎么mock数据的，第一开始我知道的是mock.js这个库，用这个库可以造出想要的字段和格式，而且字段都是随机的挺方便的，但是也需要学习一下。\n\n直到有一天，我发现有人直接在ajax中直接请求了一个json文件（可能大家早已经知道了。。。），我发现这种方式真的很方便，直接把文档复制过来就可以了，还可以根据自己的需求来更改字段方便调试。\n\n```js\n//mock.json\n{\n  \"resperr\": \"\",\n  \"respcd\": \"0000\",\n  \"respmsg\": \"\",\n  \"data\": {\n    \"cur_pt\": 1,\n    \"diff_exchange\": 3,\n    \"exchange_pt\": 2,\n    \"shopname\": \"伏牛堂\",\n    \"addr\": \"望京SOHO\",\n    \"start_time\": \"2016-01-01 00:00:00\",\n    \"expire_time\": \"2016-01-02 23:59:59\",\n    \"state\": 1,\n    \"status\": 1,\n    \"goods_name\": \"鸡丝大凉面一份\",\n    \"goods_amt\": \"2000\",\n    \"obtain_amt\": 8,\n    \"obtain_limit\": 1,\n    \"activity_id\": 1,\n    \"exchange\": 1\n  }\n}\n```\n另外这个npm包也不错的[JSON Server](https://github.com/typicode/json-server)，JSON Server可以起一个类似api的服务。\n\n*****\n\n### CSS兼容前缀\n\n在开发移动端的时候会有`webkit`兼容的问题，必须去写一些兼容的前缀。但是也有方法可以省去手动的添加，当然这也依赖构建的工具去实现。但是这样做也有不好的地方，就是我们总不去手写，就会不熟悉哪些属性需要去添加兼容，辩证来看吧。\n\n[autoprefixer](https://github.com/postcss/autoprefixer#webpack)\n\n```js\nvar autoprefixer = require('autoprefixer');\n\nmodule.exports = {\n    module: {\n        loaders: [\n            {\n                test:   /\\.css$/,\n                loader: \"style-loader!css-loader!postcss-loader\"\n            }\n        ]\n    },\n    postcss: [ autoprefixer({ browsers: ['last 2 versions'] }) ]\n}\n```\n\n这个网站也能去看浏览器的兼容性，[Can I use ](http://caniuse.com/)。\n\n*****\n\n### px转rem\n\n因为工作一直以来都是以移动端为主，移动端现在主流的解决方法就是配合flexible，css是使用rem单位来布局。\n\n从前。。。我是看着设计稿，比如如果设计稿是375的，我在写样式的时候比如200px，我就在拿计算器算：200/37.5*2 （dpr是2）然后算出来rem的值。。。。然后原来我就天天按计算器。\n\n直到有一天。。。我知道了可以在sass中写一个计算函数来进行计算：[具体链接](http://www.w3cplus.com/preprocessor/sass-px-to-rem-with-mixin-and-function.html)如果懒得看我来贴出来：\n\n```css\n@function pxTorem($px){//$px为需要转换的字号\n    @return $px / $browser-default-font-size * 1rem;\n}\n\n$browser-default-font-size: 16px !default;//变量的值可以根据自己需求定义\n\n//SCSS\nhtml {\n    font-size: $browser-default-font-size;\n}\n.header {\n    font-size: pxTorem(12px);\n}\n\n//CSS\nhtml {\n  font-size: 16px; }\n\n.header {\n  font-size: 0.75rem; }\n  \n```\n\n\n这样是会简单一些，而现在呢直接使用webpack的插件可以直接在样式中写`px`就可以了，然后构建的时候会自动转换为`rem`，如果不想转换在样式后面跟`/*px*/`就可以了。具体使用可以看下面链接：\n\n[postcss-px2rem](https://www.npmjs.com/package/postcss-px2rem)\n\n```js\n//npm install postcss-loader\n\nvar px2rem = require('postcss-px2rem');\n \nmodule.exports = {\n  module: {\n    loaders: [\n      {\n        test: /\\.css$/,\n        loader: \"style-loader!css-loader!postcss-loader\"\n      }\n    ]\n  },\n  postcss: function() {\n    return [px2rem({remUnit: 75})];\n  }\n}\n```\n\n*****\n\n### 压缩图片 \n\n[tinypng](https://tinypng.com/)\n\n设计师和前端都会用到的一个超好用的图片压缩工具。\n\n*****\n\n### 代码规范\n\n可以使用eslint，[eslint](http://eslint.org/docs/rules/)，这样大家代码风格就一样了，刚开始使用的时候确实有不适应，但是慢慢就习惯了。\n\n*****\n\n### ColorZilla\n\n这个插件可以在页面上取色，记录取色的历史，还可以生成渐变的css等等。不过平常用的可能还是取色功能吧~\n\n*****\n\n### 网站配色\n\n配色是一门学问，在我们不了解设计的情况下可以使用这个网站来快速的找到合适的配色方案：[http://paletton.com/](http://paletton.com/)\n\n*****\n\n### Octotree\n\n不知道大家平常在浏览github时会不会有这样的情况：进入的目录深了之后，如果要返回之前的目录不是一直点浏览器的退后，就是点`../`那个按钮，在同事那里看到了这个插件`Octotree `，他在浏览器的左侧生成一个目录结构，类似于webstorm左侧一样。\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160802-0.png)\n\n这样不管进入的目录有多深都可以一键返回主目录了，挺方便的。\n\n*****\n\n### WEB前端助手(FeHelper)\n\n这个工具是有一次看慕课网的视频看到的，然后自己就找到了用了一下主要包括有下面的功能：\n\nFE助手：包括字符串编解码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、页面取色\n\n平常常用的可能是字符串编解码，时间转换，JSON格式化这几个因为别的有其他插件来代替的。\n\n\n*****\n\n### 二维码(QR码)生成器(QR Code Generator)\n\n原来如果要手机调试页面的时候，我会这样做：把网址发到QQ或者微信上，然后再去打开网址。我估计和我这么蠢的人也不是很多了。\n\n安装这个插件后直接扫二维码进入就好了，方便了一些。\n\n\n******\n\n\n我深知一个人所了解到的是远远不够的，很多都是从同事或者网上学习到的。希望别的同学也可以不吝啬自己的小技巧，把大家平常工作中所用到的一些觉得很方便的方法、浏览器插件、代码库、webpack插件等等，只要可以提高效率都可以分享出来，可以在下面留言，我希望可以和大家一起学习进步。\n\n最后，分享一下自己前段时间写的一个vue小项目，[知乎日报移动web版](http://zhihudaily-vue.yatessss.com/)，[github地址](https://github.com/yatessss/zhihudaily-vue)。","source":"_posts/2016-08-01-一个前端的工作方法总结.md","raw":"---\nlayout: post\ntitle: 一个前端的工作方法总结\ndate: 2016-08-01\ntags: ['工作总结']\ncategories: 工作总结\n---\n\n进入前端也半年多了，在工作中也学到了一些帮助自己提高工作效率的工具、方法，和大家分享一下，知识需要慢慢的积累，光读文章是不够的需要结合平时的实践才能融会贯通，这篇文章不会涉及很多知识，会分享一些平时工作中用到的工具、方法，主要偏向于移动端的开发方面。\n\n### 跨域问题\n\n平时在调试接口的时候，难免会碰到一系列问题，因为在本地调试的时候和线上会有不同，可能会碰到跨域，和未登录的问题。\n\n跨协议、主域、子域、端口号都算跨域。具体的很多文章都讲的很详细。通常我们解决跨域使用jsonp、后端加跨域头，这两种需要后端来配合完成，还有是通过iframe来跨域。这是我们在生产时用到的办法。\n\n但是在开发的时候我们总不可能让后端同学加一个本地的跨域头把。。。jsonp是可以的，但是如果暂时后端没有配合，我们本地开发也可以用一些简单的方法来实现：\n我们可以使用浏览器插件：*Allow-Control-Allow-Origin:** ，这个插件会转发请求，然后在请求头中加上`Allow-Control-Allow-Origin: *`（插件名字简单粗暴），这样就可以使请求跨域了。\n\n*****\n\n### cookie问题\n\n像平常不知道大家会不会遇到这样的情况：在联调的时候会需要不同状态的账号切换，来看前端页面展示的不同状态是不是正常的。\n\n这时通过两个插件配合就可以比较方便的解决类似的问题：ModHeader和EditThisCookie。\n\n通过EditThisCookie来取出页面中我们需要的cookie。通过ModHeader来设置请求头加上cookie的字段。\n\n这样首先通过登录不同的账号取到不同的cookie：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160802-1.png)\n\n然后把他加到ModHeader的请求头中：\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160802-2.png)\n\n通过勾选不同的cookie来切换账号就可以解决上述的问题了。\n\n其实ModHeader也可以实现跨域。因为他可以加返回头，在返回头中加入跨域的头`Access-Control-Allow-Origin: *`就可以实现跨域了。\n\n因为ModHeader可以加请求头和返回头，所以它的功能不仅仅如此，大家可以尝试着使用它。\n\n*****\n\n### 接口调试\n\n如果后台已经开发完接口，就配合跨域应该就可以了。\n\n平常经常会碰到前后端已经约定好字段了或者文档已经有了，但是后台接口还没有开发完成，所以这时候需要我们自己来mock数据。\n\n不知道大家平时是怎么mock数据的，第一开始我知道的是mock.js这个库，用这个库可以造出想要的字段和格式，而且字段都是随机的挺方便的，但是也需要学习一下。\n\n直到有一天，我发现有人直接在ajax中直接请求了一个json文件（可能大家早已经知道了。。。），我发现这种方式真的很方便，直接把文档复制过来就可以了，还可以根据自己的需求来更改字段方便调试。\n\n```js\n//mock.json\n{\n  \"resperr\": \"\",\n  \"respcd\": \"0000\",\n  \"respmsg\": \"\",\n  \"data\": {\n    \"cur_pt\": 1,\n    \"diff_exchange\": 3,\n    \"exchange_pt\": 2,\n    \"shopname\": \"伏牛堂\",\n    \"addr\": \"望京SOHO\",\n    \"start_time\": \"2016-01-01 00:00:00\",\n    \"expire_time\": \"2016-01-02 23:59:59\",\n    \"state\": 1,\n    \"status\": 1,\n    \"goods_name\": \"鸡丝大凉面一份\",\n    \"goods_amt\": \"2000\",\n    \"obtain_amt\": 8,\n    \"obtain_limit\": 1,\n    \"activity_id\": 1,\n    \"exchange\": 1\n  }\n}\n```\n另外这个npm包也不错的[JSON Server](https://github.com/typicode/json-server)，JSON Server可以起一个类似api的服务。\n\n*****\n\n### CSS兼容前缀\n\n在开发移动端的时候会有`webkit`兼容的问题，必须去写一些兼容的前缀。但是也有方法可以省去手动的添加，当然这也依赖构建的工具去实现。但是这样做也有不好的地方，就是我们总不去手写，就会不熟悉哪些属性需要去添加兼容，辩证来看吧。\n\n[autoprefixer](https://github.com/postcss/autoprefixer#webpack)\n\n```js\nvar autoprefixer = require('autoprefixer');\n\nmodule.exports = {\n    module: {\n        loaders: [\n            {\n                test:   /\\.css$/,\n                loader: \"style-loader!css-loader!postcss-loader\"\n            }\n        ]\n    },\n    postcss: [ autoprefixer({ browsers: ['last 2 versions'] }) ]\n}\n```\n\n这个网站也能去看浏览器的兼容性，[Can I use ](http://caniuse.com/)。\n\n*****\n\n### px转rem\n\n因为工作一直以来都是以移动端为主，移动端现在主流的解决方法就是配合flexible，css是使用rem单位来布局。\n\n从前。。。我是看着设计稿，比如如果设计稿是375的，我在写样式的时候比如200px，我就在拿计算器算：200/37.5*2 （dpr是2）然后算出来rem的值。。。。然后原来我就天天按计算器。\n\n直到有一天。。。我知道了可以在sass中写一个计算函数来进行计算：[具体链接](http://www.w3cplus.com/preprocessor/sass-px-to-rem-with-mixin-and-function.html)如果懒得看我来贴出来：\n\n```css\n@function pxTorem($px){//$px为需要转换的字号\n    @return $px / $browser-default-font-size * 1rem;\n}\n\n$browser-default-font-size: 16px !default;//变量的值可以根据自己需求定义\n\n//SCSS\nhtml {\n    font-size: $browser-default-font-size;\n}\n.header {\n    font-size: pxTorem(12px);\n}\n\n//CSS\nhtml {\n  font-size: 16px; }\n\n.header {\n  font-size: 0.75rem; }\n  \n```\n\n\n这样是会简单一些，而现在呢直接使用webpack的插件可以直接在样式中写`px`就可以了，然后构建的时候会自动转换为`rem`，如果不想转换在样式后面跟`/*px*/`就可以了。具体使用可以看下面链接：\n\n[postcss-px2rem](https://www.npmjs.com/package/postcss-px2rem)\n\n```js\n//npm install postcss-loader\n\nvar px2rem = require('postcss-px2rem');\n \nmodule.exports = {\n  module: {\n    loaders: [\n      {\n        test: /\\.css$/,\n        loader: \"style-loader!css-loader!postcss-loader\"\n      }\n    ]\n  },\n  postcss: function() {\n    return [px2rem({remUnit: 75})];\n  }\n}\n```\n\n*****\n\n### 压缩图片 \n\n[tinypng](https://tinypng.com/)\n\n设计师和前端都会用到的一个超好用的图片压缩工具。\n\n*****\n\n### 代码规范\n\n可以使用eslint，[eslint](http://eslint.org/docs/rules/)，这样大家代码风格就一样了，刚开始使用的时候确实有不适应，但是慢慢就习惯了。\n\n*****\n\n### ColorZilla\n\n这个插件可以在页面上取色，记录取色的历史，还可以生成渐变的css等等。不过平常用的可能还是取色功能吧~\n\n*****\n\n### 网站配色\n\n配色是一门学问，在我们不了解设计的情况下可以使用这个网站来快速的找到合适的配色方案：[http://paletton.com/](http://paletton.com/)\n\n*****\n\n### Octotree\n\n不知道大家平常在浏览github时会不会有这样的情况：进入的目录深了之后，如果要返回之前的目录不是一直点浏览器的退后，就是点`../`那个按钮，在同事那里看到了这个插件`Octotree `，他在浏览器的左侧生成一个目录结构，类似于webstorm左侧一样。\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160802-0.png)\n\n这样不管进入的目录有多深都可以一键返回主目录了，挺方便的。\n\n*****\n\n### WEB前端助手(FeHelper)\n\n这个工具是有一次看慕课网的视频看到的，然后自己就找到了用了一下主要包括有下面的功能：\n\nFE助手：包括字符串编解码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、页面取色\n\n平常常用的可能是字符串编解码，时间转换，JSON格式化这几个因为别的有其他插件来代替的。\n\n\n*****\n\n### 二维码(QR码)生成器(QR Code Generator)\n\n原来如果要手机调试页面的时候，我会这样做：把网址发到QQ或者微信上，然后再去打开网址。我估计和我这么蠢的人也不是很多了。\n\n安装这个插件后直接扫二维码进入就好了，方便了一些。\n\n\n******\n\n\n我深知一个人所了解到的是远远不够的，很多都是从同事或者网上学习到的。希望别的同学也可以不吝啬自己的小技巧，把大家平常工作中所用到的一些觉得很方便的方法、浏览器插件、代码库、webpack插件等等，只要可以提高效率都可以分享出来，可以在下面留言，我希望可以和大家一起学习进步。\n\n最后，分享一下自己前段时间写的一个vue小项目，[知乎日报移动web版](http://zhihudaily-vue.yatessss.com/)，[github地址](https://github.com/yatessss/zhihudaily-vue)。","slug":"一个前端的工作方法总结","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg200002nsq5l8ei4forg","content":"<p>进入前端也半年多了，在工作中也学到了一些帮助自己提高工作效率的工具、方法，和大家分享一下，知识需要慢慢的积累，光读文章是不够的需要结合平时的实践才能融会贯通，这篇文章不会涉及很多知识，会分享一些平时工作中用到的工具、方法，主要偏向于移动端的开发方面。</p>\n<h3 id=\"跨域问题\"><a href=\"#跨域问题\" class=\"headerlink\" title=\"跨域问题\"></a>跨域问题</h3><p>平时在调试接口的时候，难免会碰到一系列问题，因为在本地调试的时候和线上会有不同，可能会碰到跨域，和未登录的问题。</p>\n<p>跨协议、主域、子域、端口号都算跨域。具体的很多文章都讲的很详细。通常我们解决跨域使用jsonp、后端加跨域头，这两种需要后端来配合完成，还有是通过iframe来跨域。这是我们在生产时用到的办法。</p>\n<p>但是在开发的时候我们总不可能让后端同学加一个本地的跨域头把。。。jsonp是可以的，但是如果暂时后端没有配合，我们本地开发也可以用一些简单的方法来实现：<br>我们可以使用浏览器插件：<em>Allow-Control-Allow-Origin:** ，这个插件会转发请求，然后在请求头中加上`Allow-Control-Allow-Origin: </em>`（插件名字简单粗暴），这样就可以使请求跨域了。</p>\n<hr>\n<h3 id=\"cookie问题\"><a href=\"#cookie问题\" class=\"headerlink\" title=\"cookie问题\"></a>cookie问题</h3><p>像平常不知道大家会不会遇到这样的情况：在联调的时候会需要不同状态的账号切换，来看前端页面展示的不同状态是不是正常的。</p>\n<p>这时通过两个插件配合就可以比较方便的解决类似的问题：ModHeader和EditThisCookie。</p>\n<p>通过EditThisCookie来取出页面中我们需要的cookie。通过ModHeader来设置请求头加上cookie的字段。</p>\n<p>这样首先通过登录不同的账号取到不同的cookie：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160802-1.png\" alt=\"\"></p>\n<p>然后把他加到ModHeader的请求头中：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160802-2.png\" alt=\"\"></p>\n<p>通过勾选不同的cookie来切换账号就可以解决上述的问题了。</p>\n<p>其实ModHeader也可以实现跨域。因为他可以加返回头，在返回头中加入跨域的头<code>Access-Control-Allow-Origin: *</code>就可以实现跨域了。</p>\n<p>因为ModHeader可以加请求头和返回头，所以它的功能不仅仅如此，大家可以尝试着使用它。</p>\n<hr>\n<h3 id=\"接口调试\"><a href=\"#接口调试\" class=\"headerlink\" title=\"接口调试\"></a>接口调试</h3><p>如果后台已经开发完接口，就配合跨域应该就可以了。</p>\n<p>平常经常会碰到前后端已经约定好字段了或者文档已经有了，但是后台接口还没有开发完成，所以这时候需要我们自己来mock数据。</p>\n<p>不知道大家平时是怎么mock数据的，第一开始我知道的是mock.js这个库，用这个库可以造出想要的字段和格式，而且字段都是随机的挺方便的，但是也需要学习一下。</p>\n<p>直到有一天，我发现有人直接在ajax中直接请求了一个json文件（可能大家早已经知道了。。。），我发现这种方式真的很方便，直接把文档复制过来就可以了，还可以根据自己的需求来更改字段方便调试。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//mock.json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"resperr\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"respcd\"</span>: <span class=\"string\">\"0000\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"respmsg\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"data\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"cur_pt\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"diff_exchange\"</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"string\">\"exchange_pt\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"string\">\"shopname\"</span>: <span class=\"string\">\"伏牛堂\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"addr\"</span>: <span class=\"string\">\"望京SOHO\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"start_time\"</span>: <span class=\"string\">\"2016-01-01 00:00:00\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"expire_time\"</span>: <span class=\"string\">\"2016-01-02 23:59:59\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"state\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"status\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"goods_name\"</span>: <span class=\"string\">\"鸡丝大凉面一份\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"goods_amt\"</span>: <span class=\"string\">\"2000\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"obtain_amt\"</span>: <span class=\"number\">8</span>,</span><br><span class=\"line\">    <span class=\"string\">\"obtain_limit\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"activity_id\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"exchange\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外这个npm包也不错的<a href=\"https://github.com/typicode/json-server\" target=\"_blank\" rel=\"external\">JSON Server</a>，JSON Server可以起一个类似api的服务。</p>\n<hr>\n<h3 id=\"CSS兼容前缀\"><a href=\"#CSS兼容前缀\" class=\"headerlink\" title=\"CSS兼容前缀\"></a>CSS兼容前缀</h3><p>在开发移动端的时候会有<code>webkit</code>兼容的问题，必须去写一些兼容的前缀。但是也有方法可以省去手动的添加，当然这也依赖构建的工具去实现。但是这样做也有不好的地方，就是我们总不去手写，就会不熟悉哪些属性需要去添加兼容，辩证来看吧。</p>\n<p><a href=\"https://github.com/postcss/autoprefixer#webpack\" target=\"_blank\" rel=\"external\">autoprefixer</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> autoprefixer = <span class=\"built_in\">require</span>(<span class=\"string\">'autoprefixer'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test:   <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">                loader: <span class=\"string\">\"style-loader!css-loader!postcss-loader\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    postcss: [ autoprefixer(&#123; browsers: [<span class=\"string\">'last 2 versions'</span>] &#125;) ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个网站也能去看浏览器的兼容性，<a href=\"http://caniuse.com/\" target=\"_blank\" rel=\"external\">Can I use </a>。</p>\n<hr>\n<h3 id=\"px转rem\"><a href=\"#px转rem\" class=\"headerlink\" title=\"px转rem\"></a>px转rem</h3><p>因为工作一直以来都是以移动端为主，移动端现在主流的解决方法就是配合flexible，css是使用rem单位来布局。</p>\n<p>从前。。。我是看着设计稿，比如如果设计稿是375的，我在写样式的时候比如200px，我就在拿计算器算：200/37.5*2 （dpr是2）然后算出来rem的值。。。。然后原来我就天天按计算器。</p>\n<p>直到有一天。。。我知道了可以在sass中写一个计算函数来进行计算：<a href=\"http://www.w3cplus.com/preprocessor/sass-px-to-rem-with-mixin-and-function.html\" target=\"_blank\" rel=\"external\">具体链接</a>如果懒得看我来贴出来：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function pxTorem($px)&#123;//$px为需要转换的字号</span><br><span class=\"line\">    @return $px / $browser-default-font-size * 1rem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$browser-default-font-size: 16px !default;//变量的值可以根据自己需求定义</span><br><span class=\"line\"></span><br><span class=\"line\">//SCSS</span><br><span class=\"line\">html &#123;</span><br><span class=\"line\">    font-size: $browser-default-font-size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.header &#123;</span><br><span class=\"line\">    font-size: pxTorem(12px);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//CSS</span><br><span class=\"line\">html &#123;</span><br><span class=\"line\">  font-size: 16px; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.header &#123;</span><br><span class=\"line\">  font-size: 0.75rem; &#125;</span><br></pre></td></tr></table></figure>\n<p>这样是会简单一些，而现在呢直接使用webpack的插件可以直接在样式中写<code>px</code>就可以了，然后构建的时候会自动转换为<code>rem</code>，如果不想转换在样式后面跟<code>/*px*/</code>就可以了。具体使用可以看下面链接：</p>\n<p><a href=\"https://www.npmjs.com/package/postcss-px2rem\" target=\"_blank\" rel=\"external\">postcss-px2rem</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//npm install postcss-loader</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> px2rem = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-px2rem'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    loaders: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">\"style-loader!css-loader!postcss-loader\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postcss: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [px2rem(&#123;remUnit: <span class=\"number\">75</span>&#125;)];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"压缩图片\"><a href=\"#压缩图片\" class=\"headerlink\" title=\"压缩图片\"></a>压缩图片</h3><p><a href=\"https://tinypng.com/\" target=\"_blank\" rel=\"external\">tinypng</a></p>\n<p>设计师和前端都会用到的一个超好用的图片压缩工具。</p>\n<hr>\n<h3 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h3><p>可以使用eslint，<a href=\"http://eslint.org/docs/rules/\" target=\"_blank\" rel=\"external\">eslint</a>，这样大家代码风格就一样了，刚开始使用的时候确实有不适应，但是慢慢就习惯了。</p>\n<hr>\n<h3 id=\"ColorZilla\"><a href=\"#ColorZilla\" class=\"headerlink\" title=\"ColorZilla\"></a>ColorZilla</h3><p>这个插件可以在页面上取色，记录取色的历史，还可以生成渐变的css等等。不过平常用的可能还是取色功能吧~</p>\n<hr>\n<h3 id=\"网站配色\"><a href=\"#网站配色\" class=\"headerlink\" title=\"网站配色\"></a>网站配色</h3><p>配色是一门学问，在我们不了解设计的情况下可以使用这个网站来快速的找到合适的配色方案：<a href=\"http://paletton.com/\" target=\"_blank\" rel=\"external\">http://paletton.com/</a></p>\n<hr>\n<h3 id=\"Octotree\"><a href=\"#Octotree\" class=\"headerlink\" title=\"Octotree\"></a>Octotree</h3><p>不知道大家平常在浏览github时会不会有这样的情况：进入的目录深了之后，如果要返回之前的目录不是一直点浏览器的退后，就是点<code>../</code>那个按钮，在同事那里看到了这个插件<code>Octotree</code>，他在浏览器的左侧生成一个目录结构，类似于webstorm左侧一样。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160802-0.png\" alt=\"\"></p>\n<p>这样不管进入的目录有多深都可以一键返回主目录了，挺方便的。</p>\n<hr>\n<h3 id=\"WEB前端助手-FeHelper\"><a href=\"#WEB前端助手-FeHelper\" class=\"headerlink\" title=\"WEB前端助手(FeHelper)\"></a>WEB前端助手(FeHelper)</h3><p>这个工具是有一次看慕课网的视频看到的，然后自己就找到了用了一下主要包括有下面的功能：</p>\n<p>FE助手：包括字符串编解码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、页面取色</p>\n<p>平常常用的可能是字符串编解码，时间转换，JSON格式化这几个因为别的有其他插件来代替的。</p>\n<hr>\n<h3 id=\"二维码-QR码-生成器-QR-Code-Generator\"><a href=\"#二维码-QR码-生成器-QR-Code-Generator\" class=\"headerlink\" title=\"二维码(QR码)生成器(QR Code Generator)\"></a>二维码(QR码)生成器(QR Code Generator)</h3><p>原来如果要手机调试页面的时候，我会这样做：把网址发到QQ或者微信上，然后再去打开网址。我估计和我这么蠢的人也不是很多了。</p>\n<p>安装这个插件后直接扫二维码进入就好了，方便了一些。</p>\n<hr>\n<p>我深知一个人所了解到的是远远不够的，很多都是从同事或者网上学习到的。希望别的同学也可以不吝啬自己的小技巧，把大家平常工作中所用到的一些觉得很方便的方法、浏览器插件、代码库、webpack插件等等，只要可以提高效率都可以分享出来，可以在下面留言，我希望可以和大家一起学习进步。</p>\n<p>最后，分享一下自己前段时间写的一个vue小项目，<a href=\"http://zhihudaily-vue.yatessss.com/\" target=\"_blank\" rel=\"external\">知乎日报移动web版</a>，<a href=\"https://github.com/yatessss/zhihudaily-vue\" target=\"_blank\" rel=\"external\">github地址</a>。</p>\n","excerpt":"","more":"<p>进入前端也半年多了，在工作中也学到了一些帮助自己提高工作效率的工具、方法，和大家分享一下，知识需要慢慢的积累，光读文章是不够的需要结合平时的实践才能融会贯通，这篇文章不会涉及很多知识，会分享一些平时工作中用到的工具、方法，主要偏向于移动端的开发方面。</p>\n<h3 id=\"跨域问题\"><a href=\"#跨域问题\" class=\"headerlink\" title=\"跨域问题\"></a>跨域问题</h3><p>平时在调试接口的时候，难免会碰到一系列问题，因为在本地调试的时候和线上会有不同，可能会碰到跨域，和未登录的问题。</p>\n<p>跨协议、主域、子域、端口号都算跨域。具体的很多文章都讲的很详细。通常我们解决跨域使用jsonp、后端加跨域头，这两种需要后端来配合完成，还有是通过iframe来跨域。这是我们在生产时用到的办法。</p>\n<p>但是在开发的时候我们总不可能让后端同学加一个本地的跨域头把。。。jsonp是可以的，但是如果暂时后端没有配合，我们本地开发也可以用一些简单的方法来实现：<br>我们可以使用浏览器插件：<em>Allow-Control-Allow-Origin:** ，这个插件会转发请求，然后在请求头中加上`Allow-Control-Allow-Origin: </em>`（插件名字简单粗暴），这样就可以使请求跨域了。</p>\n<hr>\n<h3 id=\"cookie问题\"><a href=\"#cookie问题\" class=\"headerlink\" title=\"cookie问题\"></a>cookie问题</h3><p>像平常不知道大家会不会遇到这样的情况：在联调的时候会需要不同状态的账号切换，来看前端页面展示的不同状态是不是正常的。</p>\n<p>这时通过两个插件配合就可以比较方便的解决类似的问题：ModHeader和EditThisCookie。</p>\n<p>通过EditThisCookie来取出页面中我们需要的cookie。通过ModHeader来设置请求头加上cookie的字段。</p>\n<p>这样首先通过登录不同的账号取到不同的cookie：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160802-1.png\" alt=\"\"></p>\n<p>然后把他加到ModHeader的请求头中：</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160802-2.png\" alt=\"\"></p>\n<p>通过勾选不同的cookie来切换账号就可以解决上述的问题了。</p>\n<p>其实ModHeader也可以实现跨域。因为他可以加返回头，在返回头中加入跨域的头<code>Access-Control-Allow-Origin: *</code>就可以实现跨域了。</p>\n<p>因为ModHeader可以加请求头和返回头，所以它的功能不仅仅如此，大家可以尝试着使用它。</p>\n<hr>\n<h3 id=\"接口调试\"><a href=\"#接口调试\" class=\"headerlink\" title=\"接口调试\"></a>接口调试</h3><p>如果后台已经开发完接口，就配合跨域应该就可以了。</p>\n<p>平常经常会碰到前后端已经约定好字段了或者文档已经有了，但是后台接口还没有开发完成，所以这时候需要我们自己来mock数据。</p>\n<p>不知道大家平时是怎么mock数据的，第一开始我知道的是mock.js这个库，用这个库可以造出想要的字段和格式，而且字段都是随机的挺方便的，但是也需要学习一下。</p>\n<p>直到有一天，我发现有人直接在ajax中直接请求了一个json文件（可能大家早已经知道了。。。），我发现这种方式真的很方便，直接把文档复制过来就可以了，还可以根据自己的需求来更改字段方便调试。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//mock.json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"resperr\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"respcd\"</span>: <span class=\"string\">\"0000\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"respmsg\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"data\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"cur_pt\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"diff_exchange\"</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"string\">\"exchange_pt\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"string\">\"shopname\"</span>: <span class=\"string\">\"伏牛堂\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"addr\"</span>: <span class=\"string\">\"望京SOHO\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"start_time\"</span>: <span class=\"string\">\"2016-01-01 00:00:00\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"expire_time\"</span>: <span class=\"string\">\"2016-01-02 23:59:59\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"state\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"status\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"goods_name\"</span>: <span class=\"string\">\"鸡丝大凉面一份\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"goods_amt\"</span>: <span class=\"string\">\"2000\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"obtain_amt\"</span>: <span class=\"number\">8</span>,</span><br><span class=\"line\">    <span class=\"string\">\"obtain_limit\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"activity_id\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"exchange\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外这个npm包也不错的<a href=\"https://github.com/typicode/json-server\">JSON Server</a>，JSON Server可以起一个类似api的服务。</p>\n<hr>\n<h3 id=\"CSS兼容前缀\"><a href=\"#CSS兼容前缀\" class=\"headerlink\" title=\"CSS兼容前缀\"></a>CSS兼容前缀</h3><p>在开发移动端的时候会有<code>webkit</code>兼容的问题，必须去写一些兼容的前缀。但是也有方法可以省去手动的添加，当然这也依赖构建的工具去实现。但是这样做也有不好的地方，就是我们总不去手写，就会不熟悉哪些属性需要去添加兼容，辩证来看吧。</p>\n<p><a href=\"https://github.com/postcss/autoprefixer#webpack\">autoprefixer</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> autoprefixer = <span class=\"built_in\">require</span>(<span class=\"string\">'autoprefixer'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                test:   <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">                loader: <span class=\"string\">\"style-loader!css-loader!postcss-loader\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    postcss: [ autoprefixer(&#123; browsers: [<span class=\"string\">'last 2 versions'</span>] &#125;) ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个网站也能去看浏览器的兼容性，<a href=\"http://caniuse.com/\">Can I use </a>。</p>\n<hr>\n<h3 id=\"px转rem\"><a href=\"#px转rem\" class=\"headerlink\" title=\"px转rem\"></a>px转rem</h3><p>因为工作一直以来都是以移动端为主，移动端现在主流的解决方法就是配合flexible，css是使用rem单位来布局。</p>\n<p>从前。。。我是看着设计稿，比如如果设计稿是375的，我在写样式的时候比如200px，我就在拿计算器算：200/37.5*2 （dpr是2）然后算出来rem的值。。。。然后原来我就天天按计算器。</p>\n<p>直到有一天。。。我知道了可以在sass中写一个计算函数来进行计算：<a href=\"http://www.w3cplus.com/preprocessor/sass-px-to-rem-with-mixin-and-function.html\">具体链接</a>如果懒得看我来贴出来：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function pxTorem($px)&#123;//$px为需要转换的字号</span><br><span class=\"line\">    @return $px / $browser-default-font-size * 1rem;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$browser-default-font-size: 16px !default;//变量的值可以根据自己需求定义</span><br><span class=\"line\"></span><br><span class=\"line\">//SCSS</span><br><span class=\"line\">html &#123;</span><br><span class=\"line\">    font-size: $browser-default-font-size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.header &#123;</span><br><span class=\"line\">    font-size: pxTorem(12px);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//CSS</span><br><span class=\"line\">html &#123;</span><br><span class=\"line\">  font-size: 16px; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.header &#123;</span><br><span class=\"line\">  font-size: 0.75rem; &#125;</span><br></pre></td></tr></table></figure>\n<p>这样是会简单一些，而现在呢直接使用webpack的插件可以直接在样式中写<code>px</code>就可以了，然后构建的时候会自动转换为<code>rem</code>，如果不想转换在样式后面跟<code>/*px*/</code>就可以了。具体使用可以看下面链接：</p>\n<p><a href=\"https://www.npmjs.com/package/postcss-px2rem\">postcss-px2rem</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//npm install postcss-loader</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> px2rem = <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-px2rem'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    loaders: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        loader: <span class=\"string\">\"style-loader!css-loader!postcss-loader\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  postcss: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [px2rem(&#123;remUnit: <span class=\"number\">75</span>&#125;)];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"压缩图片\"><a href=\"#压缩图片\" class=\"headerlink\" title=\"压缩图片\"></a>压缩图片</h3><p><a href=\"https://tinypng.com/\">tinypng</a></p>\n<p>设计师和前端都会用到的一个超好用的图片压缩工具。</p>\n<hr>\n<h3 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h3><p>可以使用eslint，<a href=\"http://eslint.org/docs/rules/\">eslint</a>，这样大家代码风格就一样了，刚开始使用的时候确实有不适应，但是慢慢就习惯了。</p>\n<hr>\n<h3 id=\"ColorZilla\"><a href=\"#ColorZilla\" class=\"headerlink\" title=\"ColorZilla\"></a>ColorZilla</h3><p>这个插件可以在页面上取色，记录取色的历史，还可以生成渐变的css等等。不过平常用的可能还是取色功能吧~</p>\n<hr>\n<h3 id=\"网站配色\"><a href=\"#网站配色\" class=\"headerlink\" title=\"网站配色\"></a>网站配色</h3><p>配色是一门学问，在我们不了解设计的情况下可以使用这个网站来快速的找到合适的配色方案：<a href=\"http://paletton.com/\">http://paletton.com/</a></p>\n<hr>\n<h3 id=\"Octotree\"><a href=\"#Octotree\" class=\"headerlink\" title=\"Octotree\"></a>Octotree</h3><p>不知道大家平常在浏览github时会不会有这样的情况：进入的目录深了之后，如果要返回之前的目录不是一直点浏览器的退后，就是点<code>../</code>那个按钮，在同事那里看到了这个插件<code>Octotree</code>，他在浏览器的左侧生成一个目录结构，类似于webstorm左侧一样。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160802-0.png\" alt=\"\"></p>\n<p>这样不管进入的目录有多深都可以一键返回主目录了，挺方便的。</p>\n<hr>\n<h3 id=\"WEB前端助手-FeHelper\"><a href=\"#WEB前端助手-FeHelper\" class=\"headerlink\" title=\"WEB前端助手(FeHelper)\"></a>WEB前端助手(FeHelper)</h3><p>这个工具是有一次看慕课网的视频看到的，然后自己就找到了用了一下主要包括有下面的功能：</p>\n<p>FE助手：包括字符串编解码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、页面取色</p>\n<p>平常常用的可能是字符串编解码，时间转换，JSON格式化这几个因为别的有其他插件来代替的。</p>\n<hr>\n<h3 id=\"二维码-QR码-生成器-QR-Code-Generator\"><a href=\"#二维码-QR码-生成器-QR-Code-Generator\" class=\"headerlink\" title=\"二维码(QR码)生成器(QR Code Generator)\"></a>二维码(QR码)生成器(QR Code Generator)</h3><p>原来如果要手机调试页面的时候，我会这样做：把网址发到QQ或者微信上，然后再去打开网址。我估计和我这么蠢的人也不是很多了。</p>\n<p>安装这个插件后直接扫二维码进入就好了，方便了一些。</p>\n<hr>\n<p>我深知一个人所了解到的是远远不够的，很多都是从同事或者网上学习到的。希望别的同学也可以不吝啬自己的小技巧，把大家平常工作中所用到的一些觉得很方便的方法、浏览器插件、代码库、webpack插件等等，只要可以提高效率都可以分享出来，可以在下面留言，我希望可以和大家一起学习进步。</p>\n<p>最后，分享一下自己前段时间写的一个vue小项目，<a href=\"http://zhihudaily-vue.yatessss.com/\">知乎日报移动web版</a>，<a href=\"https://github.com/yatessss/zhihudaily-vue\">github地址</a>。</p>\n"},{"layout":"post","title":"https有关的一些事","date":"2016-08-04T16:00:00.000Z","_content":"\n今天技术开了一次分享会，主要是分享了http和https相关的一些知识。\n\n其中很多知识了解，但是不是特别清楚，听完了对https更清楚了一些。\n\nhttps其实就是在http协议的基础上多添加了一层加密传输层。一般采用TLS（SSL会有缺陷），其实TLS和SSL说的是一个东西，就像ECMAScript和JavaScript一样，TLS是规范化的SSL协议，比SSL更安全。\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160808-0.png)\n\nTLS过程：\n\n1. 首先客户端会发起第一次请求，告知服务器支持的协议版本、支持的加密算法、和一个随机数。\n2. 服务器会根据客户端的请求，选择合适的协议和加密算法，然后传递给客户端第二个随机数，还有服务器的证书（其中有公钥）。\n3. 客户端会使用服务端的公钥进行加密传输第三个随机数，通知服务端改变编码规则（使用加密编码），结束握手通知。\n4. 服务端很根据三个随机数生成一个秘钥，然后告诉客户端改变编码规则（，结束握手通知。\n5. 客户端和服务端使用对称加密开始传输数据。\n\n其中要注意的就是：客户端和服务端都会有这三个随机数，因为客户端告诉了服务端支持哪些加密算法，所以客户端和服务端都用相同的算法把三个随机数生成一个对称秘钥，然后开始使用对称秘钥加密进行传输。\n\n那如何来保证安全呢？答案就在第三个随机数上。\n\n因为客户端最后传给服务端的第三个随机数是用服务端的公钥加密过的，所以理论上只有服务端才能解密第三个随机数，进而生成的对称秘钥只有双方知道。\n\n那如果在传输中间被劫持了，在传输第三个随机数的时候：劫持者把服务器的公钥劫持后换成自己的公钥发给客户端，客户端用劫持者的公钥加密了第三个随机数传给服务端，然后劫持者解密后，再用劫持到的真正服务器的公钥加密后传回给服务器，这样不就拿到了三个随机数，和加密规则。那后面的加密算法都无效了。\n\n> 客户端<------------攻击者<------------服务端\n  &emsp; &emsp; &emsp;伪造证书 &emsp; &emsp; &emsp;拦截请求\n\n所以这就是证书的用途了。为什么服务器不直接传递公钥而是传递了一个带有公钥的证书，就是为了防止上述问题的发生。证书是由CA来颁发的（一个专门颁发数字证书的机构）\n\n>数字证书的颁发过程：\n\n>用户首先产生自己的密钥对，并将公共密钥及部分个人身份信息传送给认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内包含用户的个人信息和他的公钥信息，同时还附有认证中心的签名信息(根证书私钥签名)。用户就可以使用自己的数字证书进行相关的各种活动。数字证书由独立的证书发行机构发布，数字证书各不相同，每种证书可提供不同级别的可信度。\n\n>浏览器默认都会内置CA根证书，其中根证书包含了CA的公钥\n\n>1. 证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书\n2. 证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。用CA的公钥，对伪造的证书的摘要进行解密，发现解不了，认为是危险证书。\n3. 对于篡改的证书，使用CA的公钥对数字签名进行解密得到摘要A，然后再根据签名的Hash算法计算出证书的摘要B，对比A与B，若相等则正常，若不相等则是被篡改过的。\n4. 证书可在其过期前被吊销，通常情况是该证书的私钥已经失密。较新的浏览器如Chrome、Firefox、Opera和Internet Explorer都实现了在线证书状态协议（OCSP）以排除这种情形：浏览器将网站提供的证书的序列号通过OCSP发送给证书颁发机构，后者会告诉浏览器证书是否还是有效的。\n5. 1、2点是对伪造证书进行的，3是对于篡改后的证书验证，4是对于过期失效的验证。\n\n上面部分来自[详解https是如何确保安全的？](http://www.wxtlife.com/2016/03/27/%E8%AF%A6%E8%A7%A3https%E6%98%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F/)，因为CA认证这部分理论很多，我自己叙述起来也不会很清楚。\n\n\n\n不过有一点可以说明，就是CA证书认证的时候会有签名，这个签名是用服务器自己的私钥来签名的，这样CA根据服务器的公钥就能解密签名。判断这确实是这对公私钥的持有者。（因为私钥被认为只有自己持有没有被泄露）。\n\n这样有了CA在中间的保证，没有中间劫持者来劫持掉证书，这个证书是安全的合法的。所以认为这个https链接也是安全的。\n\n\n为什么charles可以抓包https？\n\n其实charles就是上面所说的中间劫持者。他抓包的过程其实就是一个中间劫持转发的过程。因为在charles解密https之前，必须得在手机上装一个证书。这个其实就是charles的证书。因为这个证书不被CA所认可的（认为是非法的证书）所以手机默认其实是不带有这个证书的。\n\n你在手机上装了这个证书，就是承认的他的合法性和安全性，所以中间劫持了用了charles的公钥加密了你也认为没有问题。\n\n当然这是在我们调试的时候，其实普通用户使用时是没有安装charles的证书的，所以当charles抓包普通用户的时候（中间劫持，使用charles的证书），普通用户认为这个证书是不合法的危险的，就是提示出来（微信浏览器默认拒绝不安全的https）。所以这样看来https是很安全的传输协议。\n\n以上。\n\n","source":"_posts/2016-08-05-和https有关的一些事.md","raw":"---\nlayout: post\ntitle: https有关的一些事\ndate: 2016-08-05\ntags: ['工作总结']\ncategories: 工作总结\n---\n\n今天技术开了一次分享会，主要是分享了http和https相关的一些知识。\n\n其中很多知识了解，但是不是特别清楚，听完了对https更清楚了一些。\n\nhttps其实就是在http协议的基础上多添加了一层加密传输层。一般采用TLS（SSL会有缺陷），其实TLS和SSL说的是一个东西，就像ECMAScript和JavaScript一样，TLS是规范化的SSL协议，比SSL更安全。\n\n![](http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160808-0.png)\n\nTLS过程：\n\n1. 首先客户端会发起第一次请求，告知服务器支持的协议版本、支持的加密算法、和一个随机数。\n2. 服务器会根据客户端的请求，选择合适的协议和加密算法，然后传递给客户端第二个随机数，还有服务器的证书（其中有公钥）。\n3. 客户端会使用服务端的公钥进行加密传输第三个随机数，通知服务端改变编码规则（使用加密编码），结束握手通知。\n4. 服务端很根据三个随机数生成一个秘钥，然后告诉客户端改变编码规则（，结束握手通知。\n5. 客户端和服务端使用对称加密开始传输数据。\n\n其中要注意的就是：客户端和服务端都会有这三个随机数，因为客户端告诉了服务端支持哪些加密算法，所以客户端和服务端都用相同的算法把三个随机数生成一个对称秘钥，然后开始使用对称秘钥加密进行传输。\n\n那如何来保证安全呢？答案就在第三个随机数上。\n\n因为客户端最后传给服务端的第三个随机数是用服务端的公钥加密过的，所以理论上只有服务端才能解密第三个随机数，进而生成的对称秘钥只有双方知道。\n\n那如果在传输中间被劫持了，在传输第三个随机数的时候：劫持者把服务器的公钥劫持后换成自己的公钥发给客户端，客户端用劫持者的公钥加密了第三个随机数传给服务端，然后劫持者解密后，再用劫持到的真正服务器的公钥加密后传回给服务器，这样不就拿到了三个随机数，和加密规则。那后面的加密算法都无效了。\n\n> 客户端<------------攻击者<------------服务端\n  &emsp; &emsp; &emsp;伪造证书 &emsp; &emsp; &emsp;拦截请求\n\n所以这就是证书的用途了。为什么服务器不直接传递公钥而是传递了一个带有公钥的证书，就是为了防止上述问题的发生。证书是由CA来颁发的（一个专门颁发数字证书的机构）\n\n>数字证书的颁发过程：\n\n>用户首先产生自己的密钥对，并将公共密钥及部分个人身份信息传送给认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内包含用户的个人信息和他的公钥信息，同时还附有认证中心的签名信息(根证书私钥签名)。用户就可以使用自己的数字证书进行相关的各种活动。数字证书由独立的证书发行机构发布，数字证书各不相同，每种证书可提供不同级别的可信度。\n\n>浏览器默认都会内置CA根证书，其中根证书包含了CA的公钥\n\n>1. 证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书\n2. 证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。用CA的公钥，对伪造的证书的摘要进行解密，发现解不了，认为是危险证书。\n3. 对于篡改的证书，使用CA的公钥对数字签名进行解密得到摘要A，然后再根据签名的Hash算法计算出证书的摘要B，对比A与B，若相等则正常，若不相等则是被篡改过的。\n4. 证书可在其过期前被吊销，通常情况是该证书的私钥已经失密。较新的浏览器如Chrome、Firefox、Opera和Internet Explorer都实现了在线证书状态协议（OCSP）以排除这种情形：浏览器将网站提供的证书的序列号通过OCSP发送给证书颁发机构，后者会告诉浏览器证书是否还是有效的。\n5. 1、2点是对伪造证书进行的，3是对于篡改后的证书验证，4是对于过期失效的验证。\n\n上面部分来自[详解https是如何确保安全的？](http://www.wxtlife.com/2016/03/27/%E8%AF%A6%E8%A7%A3https%E6%98%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F/)，因为CA认证这部分理论很多，我自己叙述起来也不会很清楚。\n\n\n\n不过有一点可以说明，就是CA证书认证的时候会有签名，这个签名是用服务器自己的私钥来签名的，这样CA根据服务器的公钥就能解密签名。判断这确实是这对公私钥的持有者。（因为私钥被认为只有自己持有没有被泄露）。\n\n这样有了CA在中间的保证，没有中间劫持者来劫持掉证书，这个证书是安全的合法的。所以认为这个https链接也是安全的。\n\n\n为什么charles可以抓包https？\n\n其实charles就是上面所说的中间劫持者。他抓包的过程其实就是一个中间劫持转发的过程。因为在charles解密https之前，必须得在手机上装一个证书。这个其实就是charles的证书。因为这个证书不被CA所认可的（认为是非法的证书）所以手机默认其实是不带有这个证书的。\n\n你在手机上装了这个证书，就是承认的他的合法性和安全性，所以中间劫持了用了charles的公钥加密了你也认为没有问题。\n\n当然这是在我们调试的时候，其实普通用户使用时是没有安装charles的证书的，所以当charles抓包普通用户的时候（中间劫持，使用charles的证书），普通用户认为这个证书是不合法的危险的，就是提示出来（微信浏览器默认拒绝不安全的https）。所以这样看来https是很安全的传输协议。\n\n以上。\n\n","slug":"和https有关的一些事","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg202002qsq5lzw5dnojv","content":"<p>今天技术开了一次分享会，主要是分享了http和https相关的一些知识。</p>\n<p>其中很多知识了解，但是不是特别清楚，听完了对https更清楚了一些。</p>\n<p>https其实就是在http协议的基础上多添加了一层加密传输层。一般采用TLS（SSL会有缺陷），其实TLS和SSL说的是一个东西，就像ECMAScript和JavaScript一样，TLS是规范化的SSL协议，比SSL更安全。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160808-0.png\" alt=\"\"></p>\n<p>TLS过程：</p>\n<ol>\n<li>首先客户端会发起第一次请求，告知服务器支持的协议版本、支持的加密算法、和一个随机数。</li>\n<li>服务器会根据客户端的请求，选择合适的协议和加密算法，然后传递给客户端第二个随机数，还有服务器的证书（其中有公钥）。</li>\n<li>客户端会使用服务端的公钥进行加密传输第三个随机数，通知服务端改变编码规则（使用加密编码），结束握手通知。</li>\n<li>服务端很根据三个随机数生成一个秘钥，然后告诉客户端改变编码规则（，结束握手通知。</li>\n<li>客户端和服务端使用对称加密开始传输数据。</li>\n</ol>\n<p>其中要注意的就是：客户端和服务端都会有这三个随机数，因为客户端告诉了服务端支持哪些加密算法，所以客户端和服务端都用相同的算法把三个随机数生成一个对称秘钥，然后开始使用对称秘钥加密进行传输。</p>\n<p>那如何来保证安全呢？答案就在第三个随机数上。</p>\n<p>因为客户端最后传给服务端的第三个随机数是用服务端的公钥加密过的，所以理论上只有服务端才能解密第三个随机数，进而生成的对称秘钥只有双方知道。</p>\n<p>那如果在传输中间被劫持了，在传输第三个随机数的时候：劫持者把服务器的公钥劫持后换成自己的公钥发给客户端，客户端用劫持者的公钥加密了第三个随机数传给服务端，然后劫持者解密后，再用劫持到的真正服务器的公钥加密后传回给服务器，这样不就拿到了三个随机数，和加密规则。那后面的加密算法都无效了。</p>\n<blockquote>\n<p>客户端&lt;————攻击者&lt;————服务端<br>  &emsp; &emsp; &emsp;伪造证书 &emsp; &emsp; &emsp;拦截请求</p>\n</blockquote>\n<p>所以这就是证书的用途了。为什么服务器不直接传递公钥而是传递了一个带有公钥的证书，就是为了防止上述问题的发生。证书是由CA来颁发的（一个专门颁发数字证书的机构）</p>\n<blockquote>\n<p>数字证书的颁发过程：</p>\n<p>用户首先产生自己的密钥对，并将公共密钥及部分个人身份信息传送给认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内包含用户的个人信息和他的公钥信息，同时还附有认证中心的签名信息(根证书私钥签名)。用户就可以使用自己的数字证书进行相关的各种活动。数字证书由独立的证书发行机构发布，数字证书各不相同，每种证书可提供不同级别的可信度。</p>\n<p>浏览器默认都会内置CA根证书，其中根证书包含了CA的公钥</p>\n<ol>\n<li>证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书</li>\n<li>证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。用CA的公钥，对伪造的证书的摘要进行解密，发现解不了，认为是危险证书。</li>\n<li>对于篡改的证书，使用CA的公钥对数字签名进行解密得到摘要A，然后再根据签名的Hash算法计算出证书的摘要B，对比A与B，若相等则正常，若不相等则是被篡改过的。</li>\n<li>证书可在其过期前被吊销，通常情况是该证书的私钥已经失密。较新的浏览器如Chrome、Firefox、Opera和Internet Explorer都实现了在线证书状态协议（OCSP）以排除这种情形：浏览器将网站提供的证书的序列号通过OCSP发送给证书颁发机构，后者会告诉浏览器证书是否还是有效的。</li>\n<li>1、2点是对伪造证书进行的，3是对于篡改后的证书验证，4是对于过期失效的验证。</li>\n</ol>\n</blockquote>\n<p>上面部分来自<a href=\"http://www.wxtlife.com/2016/03/27/%E8%AF%A6%E8%A7%A3https%E6%98%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F/\" target=\"_blank\" rel=\"external\">详解https是如何确保安全的？</a>，因为CA认证这部分理论很多，我自己叙述起来也不会很清楚。</p>\n<p>不过有一点可以说明，就是CA证书认证的时候会有签名，这个签名是用服务器自己的私钥来签名的，这样CA根据服务器的公钥就能解密签名。判断这确实是这对公私钥的持有者。（因为私钥被认为只有自己持有没有被泄露）。</p>\n<p>这样有了CA在中间的保证，没有中间劫持者来劫持掉证书，这个证书是安全的合法的。所以认为这个https链接也是安全的。</p>\n<p>为什么charles可以抓包https？</p>\n<p>其实charles就是上面所说的中间劫持者。他抓包的过程其实就是一个中间劫持转发的过程。因为在charles解密https之前，必须得在手机上装一个证书。这个其实就是charles的证书。因为这个证书不被CA所认可的（认为是非法的证书）所以手机默认其实是不带有这个证书的。</p>\n<p>你在手机上装了这个证书，就是承认的他的合法性和安全性，所以中间劫持了用了charles的公钥加密了你也认为没有问题。</p>\n<p>当然这是在我们调试的时候，其实普通用户使用时是没有安装charles的证书的，所以当charles抓包普通用户的时候（中间劫持，使用charles的证书），普通用户认为这个证书是不合法的危险的，就是提示出来（微信浏览器默认拒绝不安全的https）。所以这样看来https是很安全的传输协议。</p>\n<p>以上。</p>\n","excerpt":"","more":"<p>今天技术开了一次分享会，主要是分享了http和https相关的一些知识。</p>\n<p>其中很多知识了解，但是不是特别清楚，听完了对https更清楚了一些。</p>\n<p>https其实就是在http协议的基础上多添加了一层加密传输层。一般采用TLS（SSL会有缺陷），其实TLS和SSL说的是一个东西，就像ECMAScript和JavaScript一样，TLS是规范化的SSL协议，比SSL更安全。</p>\n<p><img src=\"http://7xqch8.com1.z0.glb.clouddn.com/blog_2016_08_pic_QQ20160808-0.png\" alt=\"\"></p>\n<p>TLS过程：</p>\n<ol>\n<li>首先客户端会发起第一次请求，告知服务器支持的协议版本、支持的加密算法、和一个随机数。</li>\n<li>服务器会根据客户端的请求，选择合适的协议和加密算法，然后传递给客户端第二个随机数，还有服务器的证书（其中有公钥）。</li>\n<li>客户端会使用服务端的公钥进行加密传输第三个随机数，通知服务端改变编码规则（使用加密编码），结束握手通知。</li>\n<li>服务端很根据三个随机数生成一个秘钥，然后告诉客户端改变编码规则（，结束握手通知。</li>\n<li>客户端和服务端使用对称加密开始传输数据。</li>\n</ol>\n<p>其中要注意的就是：客户端和服务端都会有这三个随机数，因为客户端告诉了服务端支持哪些加密算法，所以客户端和服务端都用相同的算法把三个随机数生成一个对称秘钥，然后开始使用对称秘钥加密进行传输。</p>\n<p>那如何来保证安全呢？答案就在第三个随机数上。</p>\n<p>因为客户端最后传给服务端的第三个随机数是用服务端的公钥加密过的，所以理论上只有服务端才能解密第三个随机数，进而生成的对称秘钥只有双方知道。</p>\n<p>那如果在传输中间被劫持了，在传输第三个随机数的时候：劫持者把服务器的公钥劫持后换成自己的公钥发给客户端，客户端用劫持者的公钥加密了第三个随机数传给服务端，然后劫持者解密后，再用劫持到的真正服务器的公钥加密后传回给服务器，这样不就拿到了三个随机数，和加密规则。那后面的加密算法都无效了。</p>\n<blockquote>\n<p>客户端&lt;————攻击者&lt;————服务端<br>  &emsp; &emsp; &emsp;伪造证书 &emsp; &emsp; &emsp;拦截请求</p>\n</blockquote>\n<p>所以这就是证书的用途了。为什么服务器不直接传递公钥而是传递了一个带有公钥的证书，就是为了防止上述问题的发生。证书是由CA来颁发的（一个专门颁发数字证书的机构）</p>\n<blockquote>\n<p>数字证书的颁发过程：</p>\n<p>用户首先产生自己的密钥对，并将公共密钥及部分个人身份信息传送给认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内包含用户的个人信息和他的公钥信息，同时还附有认证中心的签名信息(根证书私钥签名)。用户就可以使用自己的数字证书进行相关的各种活动。数字证书由独立的证书发行机构发布，数字证书各不相同，每种证书可提供不同级别的可信度。</p>\n<p>浏览器默认都会内置CA根证书，其中根证书包含了CA的公钥</p>\n<ol>\n<li>证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书</li>\n<li>证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。用CA的公钥，对伪造的证书的摘要进行解密，发现解不了，认为是危险证书。</li>\n<li>对于篡改的证书，使用CA的公钥对数字签名进行解密得到摘要A，然后再根据签名的Hash算法计算出证书的摘要B，对比A与B，若相等则正常，若不相等则是被篡改过的。</li>\n<li>证书可在其过期前被吊销，通常情况是该证书的私钥已经失密。较新的浏览器如Chrome、Firefox、Opera和Internet Explorer都实现了在线证书状态协议（OCSP）以排除这种情形：浏览器将网站提供的证书的序列号通过OCSP发送给证书颁发机构，后者会告诉浏览器证书是否还是有效的。</li>\n<li>1、2点是对伪造证书进行的，3是对于篡改后的证书验证，4是对于过期失效的验证。</li>\n</ol>\n</blockquote>\n<p>上面部分来自<a href=\"http://www.wxtlife.com/2016/03/27/%E8%AF%A6%E8%A7%A3https%E6%98%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F/\">详解https是如何确保安全的？</a>，因为CA认证这部分理论很多，我自己叙述起来也不会很清楚。</p>\n<p>不过有一点可以说明，就是CA证书认证的时候会有签名，这个签名是用服务器自己的私钥来签名的，这样CA根据服务器的公钥就能解密签名。判断这确实是这对公私钥的持有者。（因为私钥被认为只有自己持有没有被泄露）。</p>\n<p>这样有了CA在中间的保证，没有中间劫持者来劫持掉证书，这个证书是安全的合法的。所以认为这个https链接也是安全的。</p>\n<p>为什么charles可以抓包https？</p>\n<p>其实charles就是上面所说的中间劫持者。他抓包的过程其实就是一个中间劫持转发的过程。因为在charles解密https之前，必须得在手机上装一个证书。这个其实就是charles的证书。因为这个证书不被CA所认可的（认为是非法的证书）所以手机默认其实是不带有这个证书的。</p>\n<p>你在手机上装了这个证书，就是承认的他的合法性和安全性，所以中间劫持了用了charles的公钥加密了你也认为没有问题。</p>\n<p>当然这是在我们调试的时候，其实普通用户使用时是没有安装charles的证书的，所以当charles抓包普通用户的时候（中间劫持，使用charles的证书），普通用户认为这个证书是不合法的危险的，就是提示出来（微信浏览器默认拒绝不安全的https）。所以这样看来https是很安全的传输协议。</p>\n<p>以上。</p>\n"},{"layout":"post","title":"初试微信小程序需要注意的地方","date":"2016-09-29T16:00:00.000Z","_content":"\n最近微信小程序刚出来，挺火的，自己也准备尝试一下。文档什么的官方都已经提供而且很全面了，所以不准备介绍小程序呢的用法。\n\n来总结一下自己在尝试微信小程序时遇到的一些需要注意的地方吧。\n\n*****\n\n### 1\n\n首先，小程序中的样式表（wxss）是不支持sass等一些预编译语言的，所以样式不能使用嵌套格式来写。\n\n还有就是如果看了wxml渲染出来的dom结构就知道，在html中一些常用的标签如：`<a>``<p>``<div>`等等，在渲染后其实在前面都加了wx-的前缀，我经过试验其实在wxss在样式中还是可以使用标签选择器的，但是在小程序中没有默认的块级元素，所以如果使用`<div>`等标签还需要申明`display: block`。所以可以使用wxml中定义的`<view>`标签，直接就是一个块元素。\n\n所以在wxss中最好还是用`class`类选择器而不是标签选择器去写样式。\n\n也不会支持一些后代选择器。目前支持的只有这些：\n\n选择器 | 样例\t| 样例描述\n---| ---| --- \n.class\t| .intro\t| 选择所有拥有 class=\"intro\" 的组件\n\\#id |\t#firstname |\t选择拥有 id=\"firstname\" 的组件\nelement |\tview |\t选择所有 view 组件\nelement, element |\tview checkbox |\t选择所有文档的 view 组件和所有的 checkbox 组件\n::after |\tview::after |\t在 view 组件后边插入内容\n::before |\tview::before |\t在 view 组件前边插入内容\n\n*****\n\n### 2\n\n如果列表渲染和模板引用一起使用时，在父模板中使用`wx:for`来循环渲染，然后把在子模板中用到的数据通过`data`这个属性传入到子模板中。\n\n```js\n//子模板\n<template name=\"list-component\">\n    <view >{{text}}</view>\n</template>\n\n\n//父模板\n<import src=\"../../component/list/list.wxml\"></import>\n<template wx:for=\"{{text}}\" is=\"list-component\" data=\"{{text: item}}\"/>\n\n```\n\n*****\n\n### 3\n\nwxss规定的rem单位和flexible的rem单位是由区别的：flexible规定把屏幕的宽度分成了10rem，但是wxss是把屏幕宽度分成了20rem。如果是原来web项目迁移的话需要注意一下。[文档地址](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html?t=1475052057161)\n\n****\n\n### 4\n\n如何发起http请求？\n\n```js\nwx.request({\n      url: 'http://news-at.zhihu.com/api/4/news/latest',\n      header: {\n        'Content-Type': 'application/json'\n      },\n      success: function(res) {\n        _this.setData({\n          date: res.data.date,\n          allStories: _this.data.allStories.concat(res.data),\n          loading: true\n        })\n        console.log('打印结果'+_this.data.allStories)\n        console.log('返回结果'+res)\n      }\n    })\n\n```\n小程序中有一个对象`wx.request` [文档地址](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html?t=1475052048561)\n\n当返回数据之后用小程序中的Page上的setData属性赋值到`data`当中。[文档地址](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html?t=1475212238291)\n\n*****\n\n### 5 \n\n在编写小程序的过程中记得不要忘记在`app.json`中注册你所需要的页面。因为有很多不知原因的问题可以是你这里的疏忽所导致的。当你没有注册页面的时候html会正常运行，但是js的逻辑却失效了。\n\n看到下面的警告的时候你就应该注意是这个问题了：\n\n>Page[page/page-detail/page-detail] not found. May be caused by: 1. Forgot to add page route in app.json. \n\n\n（未完）","source":"_posts/2016-09-30-初试微信小程序需要注意的地方.md","raw":"---\nlayout: post\ntitle: 初试微信小程序需要注意的地方\ndate: 2016-09-30\ntags: ['微信小程序']\ncategories: 微信小程序\n---\n\n最近微信小程序刚出来，挺火的，自己也准备尝试一下。文档什么的官方都已经提供而且很全面了，所以不准备介绍小程序呢的用法。\n\n来总结一下自己在尝试微信小程序时遇到的一些需要注意的地方吧。\n\n*****\n\n### 1\n\n首先，小程序中的样式表（wxss）是不支持sass等一些预编译语言的，所以样式不能使用嵌套格式来写。\n\n还有就是如果看了wxml渲染出来的dom结构就知道，在html中一些常用的标签如：`<a>``<p>``<div>`等等，在渲染后其实在前面都加了wx-的前缀，我经过试验其实在wxss在样式中还是可以使用标签选择器的，但是在小程序中没有默认的块级元素，所以如果使用`<div>`等标签还需要申明`display: block`。所以可以使用wxml中定义的`<view>`标签，直接就是一个块元素。\n\n所以在wxss中最好还是用`class`类选择器而不是标签选择器去写样式。\n\n也不会支持一些后代选择器。目前支持的只有这些：\n\n选择器 | 样例\t| 样例描述\n---| ---| --- \n.class\t| .intro\t| 选择所有拥有 class=\"intro\" 的组件\n\\#id |\t#firstname |\t选择拥有 id=\"firstname\" 的组件\nelement |\tview |\t选择所有 view 组件\nelement, element |\tview checkbox |\t选择所有文档的 view 组件和所有的 checkbox 组件\n::after |\tview::after |\t在 view 组件后边插入内容\n::before |\tview::before |\t在 view 组件前边插入内容\n\n*****\n\n### 2\n\n如果列表渲染和模板引用一起使用时，在父模板中使用`wx:for`来循环渲染，然后把在子模板中用到的数据通过`data`这个属性传入到子模板中。\n\n```js\n//子模板\n<template name=\"list-component\">\n    <view >{{text}}</view>\n</template>\n\n\n//父模板\n<import src=\"../../component/list/list.wxml\"></import>\n<template wx:for=\"{{text}}\" is=\"list-component\" data=\"{{text: item}}\"/>\n\n```\n\n*****\n\n### 3\n\nwxss规定的rem单位和flexible的rem单位是由区别的：flexible规定把屏幕的宽度分成了10rem，但是wxss是把屏幕宽度分成了20rem。如果是原来web项目迁移的话需要注意一下。[文档地址](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html?t=1475052057161)\n\n****\n\n### 4\n\n如何发起http请求？\n\n```js\nwx.request({\n      url: 'http://news-at.zhihu.com/api/4/news/latest',\n      header: {\n        'Content-Type': 'application/json'\n      },\n      success: function(res) {\n        _this.setData({\n          date: res.data.date,\n          allStories: _this.data.allStories.concat(res.data),\n          loading: true\n        })\n        console.log('打印结果'+_this.data.allStories)\n        console.log('返回结果'+res)\n      }\n    })\n\n```\n小程序中有一个对象`wx.request` [文档地址](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html?t=1475052048561)\n\n当返回数据之后用小程序中的Page上的setData属性赋值到`data`当中。[文档地址](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html?t=1475212238291)\n\n*****\n\n### 5 \n\n在编写小程序的过程中记得不要忘记在`app.json`中注册你所需要的页面。因为有很多不知原因的问题可以是你这里的疏忽所导致的。当你没有注册页面的时候html会正常运行，但是js的逻辑却失效了。\n\n看到下面的警告的时候你就应该注意是这个问题了：\n\n>Page[page/page-detail/page-detail] not found. May be caused by: 1. Forgot to add page route in app.json. \n\n\n（未完）","slug":"初试微信小程序需要注意的地方","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg204002usq5lbfity65p","content":"<p>最近微信小程序刚出来，挺火的，自己也准备尝试一下。文档什么的官方都已经提供而且很全面了，所以不准备介绍小程序呢的用法。</p>\n<p>来总结一下自己在尝试微信小程序时遇到的一些需要注意的地方吧。</p>\n<hr>\n<h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h3><p>首先，小程序中的样式表（wxss）是不支持sass等一些预编译语言的，所以样式不能使用嵌套格式来写。</p>\n<p>还有就是如果看了wxml渲染出来的dom结构就知道，在html中一些常用的标签如：<code>&lt;a&gt;``&lt;p&gt;``&lt;div&gt;</code>等等，在渲染后其实在前面都加了wx-的前缀，我经过试验其实在wxss在样式中还是可以使用标签选择器的，但是在小程序中没有默认的块级元素，所以如果使用<code>&lt;div&gt;</code>等标签还需要申明<code>display: block</code>。所以可以使用wxml中定义的<code>&lt;view&gt;</code>标签，直接就是一个块元素。</p>\n<p>所以在wxss中最好还是用<code>class</code>类选择器而不是标签选择器去写样式。</p>\n<p>也不会支持一些后代选择器。目前支持的只有这些：</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>样例</th>\n<th>样例描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.class</td>\n<td>.intro</td>\n<td>选择所有拥有 class=”intro” 的组件</td>\n</tr>\n<tr>\n<td>#id</td>\n<td>#firstname</td>\n<td>选择拥有 id=”firstname” 的组件</td>\n</tr>\n<tr>\n<td>element</td>\n<td>view</td>\n<td>选择所有 view 组件</td>\n</tr>\n<tr>\n<td>element, element</td>\n<td>view checkbox</td>\n<td>选择所有文档的 view 组件和所有的 checkbox 组件</td>\n</tr>\n<tr>\n<td>::after</td>\n<td>view::after</td>\n<td>在 view 组件后边插入内容</td>\n</tr>\n<tr>\n<td>::before</td>\n<td>view::before</td>\n<td>在 view 组件前边插入内容</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h3><p>如果列表渲染和模板引用一起使用时，在父模板中使用<code>wx:for</code>来循环渲染，然后把在子模板中用到的数据通过<code>data</code>这个属性传入到子模板中。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//子模板</span><br><span class=\"line\">&lt;template name=\"list-component\"&gt;</span><br><span class=\"line\">    &lt;view &gt;&#123;&#123;text&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//父模板</span><br><span class=\"line\">&lt;import src=\"../../component/list/list.wxml\"&gt;&lt;/import&gt;</span><br><span class=\"line\">&lt;template wx:for=\"&#123;&#123;text&#125;&#125;\" is=\"list-component\" data=\"&#123;&#123;text: item&#125;&#125;\"/&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h3><p>wxss规定的rem单位和flexible的rem单位是由区别的：flexible规定把屏幕的宽度分成了10rem，但是wxss是把屏幕宽度分成了20rem。如果是原来web项目迁移的话需要注意一下。<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html?t=1475052057161\" target=\"_blank\" rel=\"external\">文档地址</a></p>\n<hr>\n<h3 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a>4</h3><p>如何发起http请求？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.request(&#123;</span><br><span class=\"line\">      url: <span class=\"string\">'http://news-at.zhihu.com/api/4/news/latest'</span>,</span><br><span class=\"line\">      header: &#123;</span><br><span class=\"line\">        <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/json'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">        _this.setData(&#123;</span><br><span class=\"line\">          date: res.data.date,</span><br><span class=\"line\">          allStories: _this.data.allStories.concat(res.data),</span><br><span class=\"line\">          loading: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'打印结果'</span>+_this.data.allStories)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'返回结果'</span>+res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>小程序中有一个对象<code>wx.request</code> <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html?t=1475052048561\" target=\"_blank\" rel=\"external\">文档地址</a></p>\n<p>当返回数据之后用小程序中的Page上的setData属性赋值到<code>data</code>当中。<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html?t=1475212238291\" target=\"_blank\" rel=\"external\">文档地址</a></p>\n<hr>\n<h3 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a>5</h3><p>在编写小程序的过程中记得不要忘记在<code>app.json</code>中注册你所需要的页面。因为有很多不知原因的问题可以是你这里的疏忽所导致的。当你没有注册页面的时候html会正常运行，但是js的逻辑却失效了。</p>\n<p>看到下面的警告的时候你就应该注意是这个问题了：</p>\n<blockquote>\n<p>Page[page/page-detail/page-detail] not found. May be caused by: 1. Forgot to add page route in app.json. </p>\n</blockquote>\n<p>（未完）</p>\n","excerpt":"","more":"<p>最近微信小程序刚出来，挺火的，自己也准备尝试一下。文档什么的官方都已经提供而且很全面了，所以不准备介绍小程序呢的用法。</p>\n<p>来总结一下自己在尝试微信小程序时遇到的一些需要注意的地方吧。</p>\n<hr>\n<h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h3><p>首先，小程序中的样式表（wxss）是不支持sass等一些预编译语言的，所以样式不能使用嵌套格式来写。</p>\n<p>还有就是如果看了wxml渲染出来的dom结构就知道，在html中一些常用的标签如：<code>&lt;a&gt;``&lt;p&gt;``&lt;div&gt;</code>等等，在渲染后其实在前面都加了wx-的前缀，我经过试验其实在wxss在样式中还是可以使用标签选择器的，但是在小程序中没有默认的块级元素，所以如果使用<code>&lt;div&gt;</code>等标签还需要申明<code>display: block</code>。所以可以使用wxml中定义的<code>&lt;view&gt;</code>标签，直接就是一个块元素。</p>\n<p>所以在wxss中最好还是用<code>class</code>类选择器而不是标签选择器去写样式。</p>\n<p>也不会支持一些后代选择器。目前支持的只有这些：</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>样例</th>\n<th>样例描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.class</td>\n<td>.intro</td>\n<td>选择所有拥有 class=”intro” 的组件</td>\n</tr>\n<tr>\n<td>#id</td>\n<td>#firstname</td>\n<td>选择拥有 id=”firstname” 的组件</td>\n</tr>\n<tr>\n<td>element</td>\n<td>view</td>\n<td>选择所有 view 组件</td>\n</tr>\n<tr>\n<td>element, element</td>\n<td>view checkbox</td>\n<td>选择所有文档的 view 组件和所有的 checkbox 组件</td>\n</tr>\n<tr>\n<td>::after</td>\n<td>view::after</td>\n<td>在 view 组件后边插入内容</td>\n</tr>\n<tr>\n<td>::before</td>\n<td>view::before</td>\n<td>在 view 组件前边插入内容</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h3><p>如果列表渲染和模板引用一起使用时，在父模板中使用<code>wx:for</code>来循环渲染，然后把在子模板中用到的数据通过<code>data</code>这个属性传入到子模板中。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//子模板</span><br><span class=\"line\">&lt;template name=\"list-component\"&gt;</span><br><span class=\"line\">    &lt;view &gt;&#123;&#123;text&#125;&#125;&lt;/view&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//父模板</span><br><span class=\"line\">&lt;import src=\"../../component/list/list.wxml\"&gt;&lt;/import&gt;</span><br><span class=\"line\">&lt;template wx:for=\"&#123;&#123;text&#125;&#125;\" is=\"list-component\" data=\"&#123;&#123;text: item&#125;&#125;\"/&gt;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h3><p>wxss规定的rem单位和flexible的rem单位是由区别的：flexible规定把屏幕的宽度分成了10rem，但是wxss是把屏幕宽度分成了20rem。如果是原来web项目迁移的话需要注意一下。<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html?t=1475052057161\">文档地址</a></p>\n<hr>\n<h3 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a>4</h3><p>如何发起http请求？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.request(&#123;</span><br><span class=\"line\">      url: <span class=\"string\">'http://news-at.zhihu.com/api/4/news/latest'</span>,</span><br><span class=\"line\">      header: &#123;</span><br><span class=\"line\">        <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/json'</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">        _this.setData(&#123;</span><br><span class=\"line\">          date: res.data.date,</span><br><span class=\"line\">          allStories: _this.data.allStories.concat(res.data),</span><br><span class=\"line\">          loading: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'打印结果'</span>+_this.data.allStories)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'返回结果'</span>+res)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p>小程序中有一个对象<code>wx.request</code> <a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html?t=1475052048561\">文档地址</a></p>\n<p>当返回数据之后用小程序中的Page上的setData属性赋值到<code>data</code>当中。<a href=\"https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html?t=1475212238291\">文档地址</a></p>\n<hr>\n<h3 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a>5</h3><p>在编写小程序的过程中记得不要忘记在<code>app.json</code>中注册你所需要的页面。因为有很多不知原因的问题可以是你这里的疏忽所导致的。当你没有注册页面的时候html会正常运行，但是js的逻辑却失效了。</p>\n<p>看到下面的警告的时候你就应该注意是这个问题了：</p>\n<blockquote>\n<p>Page[page/page-detail/page-detail] not found. May be caused by: 1. Forgot to add page route in app.json. </p>\n</blockquote>\n<p>（未完）</p>\n"},{"layout":"post","title":"前端直接生成及下载二维码和使用七牛SDK上传图片","date":"2016-10-16T16:00:00.000Z","_content":"\n最近工作比较紧张，除了日常的小需求之外，还做了一个给商户用的后台。技术栈除了vue之外，还用到了`materialize`这个UI库[地址](https://github.com/dogfalo/materialize/)，但是这个库有一个缺点，那就是强依赖与jquery。\n\n因为是后台，依赖juqery倒也没什么，因为是在pc端使用对文件大小的要求不是特别高，而且基于juqery的插件特别多，有些地方如果自己去处理可能会存在一些不兼容的问题，用插件会避免很多怪异的问题。\n\n由于这个业务交互不是特别复杂，其中有两点可以分享的：一个就是前端处理二维码及下载，只需要从后端获取到生成二维码的url，就可以生成二维码以及把他下载下来，不需要后台的处理；另一个是应用七牛的SDK去上传图片，其上传也是从前端来完成，不需要后端处理。\n\n\n*********\n\n\n### 前端直接生成二维码及下载\n\n\n生成二维码这个没什么，就是一个生成二维码的库[地址](http://jeromeetienne.github.com/jquery-qrcode/)这个库是基于jquery的，github上还有不依赖于jquery的库。这样二维码就生成了。\n\n下载二维码，原理是这样的：把生成的img标签利用canvas的`toDataURL()`方法转变为base64格式的，然后把base64的串放到`a标签`的href属性中。利用`a标签`的download属性，就可以把它下载下来。如果不仅仅需要二维码而是需要在二维码中加入一些文字或者背景图的话，就可以利用canvas把二维码和需要的文字背景图都绘制到canvas中，再获取这个canvas的`toDataURL()`，再依据上面的方法去下载下来。\n\n不过这种方法也有不足的地方，比如说批量下载。这种方法如果需要批量下载就必须依靠js，然后去遍历`a标签`去主动触发click事件。\n\n下面贴一下代码就好咯~ \n\n```js\n//生成二维码\n//可能代码和业务会有一定关联，我把大部分关联的都删掉了\n\n$.ajax({\n//请求要生成url接口\n  url\t\t:\t'http://172.100.101.106:9099/merchant_qrcode/dccode',\n  type\t:\t'POST',\n  dataType:\t'json',\n  data\t:\tpost_data,\n  success:function(data){\n    $(\"#qrcode_box\").html(\"\");\n    if(data['respcd'] == '0000') {\n      var qrcodes = data.data.qrcode_list; \n      for(var i=0;i<qrcodes.length;i++)\n      {\n        var box_label = $(\"<label for='\"+qrcodes[i]['num']+\"'></label>\");\n        var img_panel = $(\"<div class='col-lg-4 col-md-4 col-sm-6'></div>\");\n        var checkbox = $(\"<input class='chk' type='checkbox' id='\"+qrcodes[i]['num']+\"' />\")[0];\n\n        var new_panel = $(\"<div class='bg-panel'></div>\");\n        var new_elem = $(\"<div class='qrcode'></div>\")[0];\n        var new_desc = $(\"<div class='text-desc text-center'><span>\"+qrcodes[i]['area_name']+\" \"+qrcodes[i]['num']+\"</span></div>\")[0];\n        var label = $(\"<label for='\"+qrcodes[i]['num']+\"'></label>\");\n\t\t\n\t\t//拼接dom包含checkbox，显示二维码的div，文字信息的div等\n        new_panel.append(checkbox);\n        new_panel.append(label);\n        new_panel.append(new_elem);\n        new_panel.append(new_desc);\n\t\t\n\t\t//生成下载按钮，把一些信息保存到标签的data属性里，比如要拼接到canvas中的文字和url信息等等。\n        var btn_panel = $(\"<div class='btn-panel'></div>\");\n        var download_elem = $(\"<div style='display:inline-flex;'><button class='m-l btn btn-primary download_pngcode' data-num='\"+qrcodes[i]['num']+\"' data-qrcode='\"+qrcodes[i]['qrcode']+\"' data-area_name='\"+qrcodes[i]['area_name']+\"' onclick=download_qrcode_png(this) >下载桌贴</button><button class='m-l download_code btn btn-warning' data-num='\"+qrcodes[i]['num']+\"' data-qrcode='\"+qrcodes[i]['qrcode']+\"' data-area_name='\"+qrcodes[i]['area_name']+\"' onclick=download_qrcode(this) >下载二维码</button></div>\");\n        btn_panel.append(download_elem);\n\n        img_panel.append(new_panel);\n        img_panel.append(btn_panel);\n        box_label.append(img_panel)\n\t\t//生成二维码\n        var qrcode = new QRCode(new_elem,{\n          width : 131,\n          height:\t131\n        });\n        qrcode.makeCode(qrcodes[i].qrcode);\n      }\n      _this.btnDisabled \n    }\n  }\n});\n\n//下载二维码\n\n//仅下载二维码\nexports.download_qrcode = function (e){\n  var new_elem = $(\"<div></div>\")[0];\n  var qrcode = new QRCode(new_elem,{\n    width : 262,//设置宽高\n    height : 262\n  });\n  console.log($(e));\n  qrcode.makeCode($(e).data('qrcode'));\n  var c=document.createElement('canvas'),ctx=c.getContext('2d');\n  var qr_ele = qrcode;\n  c.width=262;\n  c.height=310;\n  ctx.rect(0,0,c.width,c.height);\n  ctx.fillStyle='#fff';\n  ctx.fill();\n  var img = new Image;\n  img.crossOrigin = 'Anonymous'; //解决跨域\n  img.src = qrcode._el.children[0].toDataURL();\n  ctx.drawImage(img,0,0,262,262);\n\n  ctx.fillStyle='#fe9b20';\n  ctx.font = \"bold 32px 黑体\";\n  ctx.textAlign = \"center\";\n  \n//在二维码下方添加文字\n  var fill_txt = \"\";\n  if($(e).data(\"area_name\") !=\"\"){\n    fill_txt = $(e).data(\"area_name\")+\" \";\n  }\n  if($(e).data(\"num\") != \"\"){\n    fill_txt += ($(e).data(\"num\") + '号桌');\n  }\n  ctx.fillText(fill_txt,131,300);\n  \n//读取生成标签中的data属性，生成下载a标签\n  var $a = $(\"<a></a>\").attr(\"href\", c.toDataURL()).attr(\"download\", $(e).data(\"area_name\")+$(e).data(\"num\")+\".png\");\n  $a[0].click();\n}\n\n//下载带背景图的二维码\nexports.download_qrcode_png = function (e){\n  var new_elem = $(\"<div></div>\")[0];\n  var qrcode = new QRCode(new_elem,{\n    width : 262,//设置宽高\n    height : 262\n  });\n  qrcode.makeCode($(e).data('qrcode'));\n  var c=document.createElement('canvas'),ctx=c.getContext('2d');\n  var qr_ele = qrcode;\n  c.width=460;\n  c.height=620;\n  ctx.rect(0,0,c.width,c.height);\n  ctx.fill();\n  //读取背景图\n  var bg_img = $(\"#background_image\")[0];\n  var img = new Image;\n  img.crossOrigin = 'Anonymous'; //解决跨域\n  img.src = qrcode._el.children[0].toDataURL();\n  //画到canvas中\n  ctx.drawImage(bg_img,0,0,460,620);\n  ctx.drawImage(img,98,162,262,262);\n\n  ctx.fillStyle='#fe9b20';\n  ctx.font = \"bold 32px 黑体\";\n  ctx.textAlign = \"center\";\n\n  var fill_txt = \"\";\n  if($(e).data(\"area_name\") !=\"\"){\n    fill_txt = $(e).data(\"area_name\")+\" \";\n  }\n  if($(e).data(\"num\") != \"\"){\n    fill_txt += ($(e).data(\"num\") + '号桌');\n  }\n  ctx.fillText(fill_txt,230,465);\n\n  //document.body.appendChild(c);\n\n  var $a = $(\"<a></a>\").attr(\"href\", c.toDataURL()).attr(\"download\", $(e).data(\"area_name\")+$(e).data(\"num\")+\".png\");\n  $a[0].click();\n}\n\n```\n\n************\n\n### 使用七牛SDK上传图片\n\n七牛的开发文档地址[这里。](http://developer.qiniu.com/code/v6/sdk/javascript.html#upload)\n\n按照七牛文档和demo就可以很快实现一个上传图片的功能。我来说一下上传的大概过程和我遇到的一个问题。\n\n首先服务端的会先做一些[工作](http://developer.qiniu.com/code/v7/sdk/python.html#io-put)，这个我们不太需要关心只要知道我们在上传图片之前，需要先向服务端去发起一次请求去拿到token和key，因为可以看到七牛上传图片时是需要这两个参数的。然后开始上传图片，上传图片后还有一个成功回调事件，在回调事件中可以做一些事情。（告知服务端图片上传成功了，并把这张图片的url告诉服务端，这样才能把图片对应起来）\n\n这里这再插一句，七牛的SDK使用的plupload插件是这样的：他在初始化的时候需要的参数有token，按钮的`id`，还有一个可选的参数key（这个参数是可以把文件的url替换成你自定义的）。然后会在方法执行时会去寻找你这个id的button，去初始化它，在这个标签下面再去创建一个input标签，在你点击这个id的button的时候他会去隐式的点击下面的input来唤起浏览器选择文件。\n\n好，大概的过程就是这样的。没有什么问题，但是不管文档和demo都只说了只有一个按钮的情况。如果我有一个列表，上面有很多上传按钮这种情况该怎么办？文档上有类似问题：[地址](http://developer.qiniu.com/code/v6/sdk/javascript.html#faq)。但是他这里说的情况是固定的几个按钮，并且知道他的token和key，还有按钮标签的`id`。\n\n这种是不符合我目前需求的，因为我目前整个列表有几个上传按钮都是不确定的，按钮的`id`等等也是不固定的，我要等请求后端接口拿到token和key之后，再去初始化按钮，并且每个按钮和列表每一行的商品要一一对应。所以在完成这个初始化多个上传按钮时碰到了问题。\n\n我们分析一下：如果需要一一对应那么我必须使每一行的button都有自己单独的id、token、和key（因为需要自定义上传图片的url）。\n\n最开始我是这么写的：（大概过程可以看注释）\n\n```js\n//请求商品列表\najax({\n  url: 'http://172.100.101.106:9099/goods/list',\n  method: 'GET',\n  data: data,\n  callback: function (res) {\n    //把初始化队列置空\n    _this.$set('initList', [])\n    if (res.respcd === '0000') {\n      _this.$set('goodsList', res.data.list)\n      //遍历商品列表的每一项，创建一个新的对象包含初始化时需要的id，然后用unionid关联商品列表和新建的初始化列表\n      for (let i = 0, len = res.data.list.length; i < len; i++) {\n        if (res.data.list[i].img === '') {\n          let a = {\n            id: 'img-id-' + res.data.list[i].id,\n            unionid: res.data.list[i].unionid\n          }\n          //把对象push进初始化列表\n          _this.initList.push(a)\n        }\n      }\n    }\n    //这个是vue监听dom渲染完成的事件（可忽略）\n    _this.$nextTick(function () {\n    //初始化列表的每一项进行初始化按钮的操作\n      for (let i = 0, len = _this.initList.length; i < len; i++) {\n        _this.initUpload(_this.initList[i].unionid, _this.initList[i].id)\n      }\n    })\n  }\n})\n\n//方法接受两个参数 \n//unionid 这个参数是最后上传完成后给服务端发请求告知 是哪个商品的图片，让服务端把商品和图片对应起来；\n//id 就是初始化按钮是需要的id；\ninitUpload (unionid, id) {\n        let _this = this\n        //这个是获取token和key的接口，上面过程说明了一下\n        $.ajax({\n          url: 'https://xxxxxxxxx/qiniu_token',\n          type: 'get',\n          dataType: 'json',\n          data: {\n            'appcode':\t'xxxxxx',\n            'func':\t'upload',\n            'format':\t'cors'\n          },\n          async: false,\n          timeout: 3000,\n          success: function (data) {\n            if (data['respcd'] === '0000') {\n              let uptoken = data.data.token\n              ******************\n              let key = data.data.key\n              ******************\n              var uploader = Qiniu.uploader({\n                runtimes: 'html5,flash,html4',    //上传模式,依次退化\n                browse_button: id,       //上传选择的点选按钮，**必需**\n                uptoken: uptoken,\n                domain: 'https://xxxxxxxxx.com/',   //bucket 域名，下载资源时用到，**必需**\n                get_new_uptoken: true,  //设置上传文件的时候是否每次都重新获取新的token\n                max_file_size: '10mb',           //最大文件体积限制\n                flash_swf_url: './flash/Moxie.swf',  //引入flash,相对路径\n                max_retries: 3,                   //上传失败最大重试次数\n                dragdrop: true,                   //开启可拖曳上传\n                drop_element: id,        //拖曳上传区域元素的ID，拖曳文件或文件夹后可触发上传\n                chunk_size: '4mb',                //分块上传时，每片的体积\n                auto_start: true,                 //选择文件后自动上传，若关闭需要自己绑定事件触发上传\n                init: {\n                  'FilesAdded': function (up, files) {\n                    plupload.each(files, function (file) {\n                      // 文件添加进队列后,处理相关的事情\n                    })\n                  },\n                  'BeforeUpload': function (up, file) {\n                    // 每个文件上传前,处理相关的事情\n                  },\n                  'UploadProgress': function (up, file) {\n//                    $('#img_upload-' + rand_num).addClass('spinner')\n                    // 每个文件上传时,处理相关的事情\n                  },\n                  'FileUploaded': function (up, file, info) {\n                    var domain = up.getOption('domain')\n                    var res = JSON.parse(info)\n                    var sourceLink = domain + res.key //获取上传成功后的文件的Url\n\n                    $.ajax({\n                      url: 'http://172.100.101.106:9099/goods/setimg',\n                      type: 'POST',\n                      dataType: 'json',\n                      data: {\n                        'unionid': unionid,\n                        'img': sourceLink\n                      },\n                      success: function (data) {\n                        if (data['respcd'] === '0000') {\n                          window.Materialize.toast('添加商品图片成功', 4000)\n                          _this.getUserInfo(_this.currentPage, _this.pageSize)\n                          }\n                      },\n                      error: function (data) {\n                        window.Materialize.toast(data.respmsg, 4000)\n                      }\n                    })\n                  },\n                  'Error': function (up, err, errTip) {\n                    //上传出错时,处理相关的事情\n                    window.Materialize.toast(errTip, 4000)\n                    $('#img_upload').removeClass('spinner')\n                  },\n                  'UploadComplete': function () {\n                    //队列文件处理完毕后,处理相关的事情\n                  },\n                  'Key': function (up, file) {\n                  \t*************\n                    return key\n                    *************\n                  }\n                }\n              })\n            }\n```\n\n请注意我标********的那几行，我本意是把每一个ajax请求到的key，赋到每一个初始化按钮的方法中去，但是如果我们实际这么去写的话，token是对的，但是key总是最后一个请求的key，原因就是初始化中`'Key'`这个方法，并不是在方法初始化的时候就去执行了，而是你再点击这个按钮的时候再去获取这个key的值，所以当你点击按钮时这个key的值就是最后一次请求到key的值了。（只有一个key会造成上传了多张图片，但是你只会有一个url的情况发生）\n\n那如何去在一个页面用七牛的SDK去初始化N个上传按钮呢？\n\n我当时试了闭包这种方法，大概是这样：\n\n```js\n(function (key) {\n\t//初始化\n\tvar uploader = Qiniu.uploader({}）\n})(key)\n```\n但是并不可以。\n\n找到了一种变通式的解决方法，就是在你每次点击按钮时，去渲染一个新的DOM，再用这个新的DOM去执行初始化的方法：\n\n```js\nvar rand_num = parseInt(Math.random()*100000000)\n$(\"#upload_block\").html(\"\");\nvar html ='<div id=\"img-container-'+rand_num+'\" class=\"dz-default dz-message\"><button id=\"img_upload-'+rand_num+'\" class=\"btn btn-default btn-lg\"><i class=\"glyphicon glyphicon-plus\"></i><span>上传图片</span></button></div>';\n$(\"#upload_block\").html(html);\n\n//然后把这个DOM进行初始化\n```\n这样同步的来进行，一次只有一个token和key，初始化一个按钮，这样就不会存在上面的问题，但是这样就意味着你点击上传按钮之后，又会出来一个蒙层点击蒙层上的按钮才可以选择图片，这样体验未免有些太差了。\n\n#### 解决\n\n最后经过一下午的尝试，最后也是受到了demo的启发：\n\n```js\n'FileUploaded': function(up, file, info) {\n       // 每个文件上传成功后，处理相关的事情\n       // 其中info是文件上传成功后，服务端返回的json，形式如：\n       // {\n       //    \"hash\": \"Fh8xVqod2MQ1mocfI4S4KpRL6D98\",\n       //    \"key\": \"gogopher.jpg\"\n       //  }\n       // 查看简单反馈\n       // var domain = up.getOption('domain');\n       // var res = parseJSON(info);\n       // var sourceLink = domain + res.key; 获取上传成功后的文件的Url\n}\n```\n\n七牛给的上传说明中有这么一段，方法的第一个参数是up，通过注释我们可以看出这个参数可以获取到`Qiniu.uploader`这个方法的一些配置参数的值，比如这一行`var domain = up.getOption('domain');`他就获取到了domain这个配置的值（`即https://xxxxxxxxx.com/`），可以看到`'Key'`这个方法也会接受`up`这个参数，所以可不可以在配置中多加一个keyValue的多余配置，来储存key值呢？\n\n经过试验答案是可以的！大概这样：（相同代码就不再重复）\n\n```js\nvar uploader = Qiniu.uploader({\n    keyValue: key,\n    \n    .....\n    \n    \n    init: {\n    \n    .....\n    \n      'Key': function (up, file) {\n        let key = up.getOption('keyValue')\n        return key\n      }\n    }\n\n```\n\n其他地方不变，这样经过试验可以很好地解决初始化多个按钮的问题！\n\n","source":"_posts/2016-10-17-前端直接生成及下载二维码和使用七牛SDK上传图片.md","raw":"---\nlayout: post\ntitle: 前端直接生成及下载二维码和使用七牛SDK上传图片\ndate: 2016-10-17\ntags: ['工作总结']\ncategories: 工作总结\n---\n\n最近工作比较紧张，除了日常的小需求之外，还做了一个给商户用的后台。技术栈除了vue之外，还用到了`materialize`这个UI库[地址](https://github.com/dogfalo/materialize/)，但是这个库有一个缺点，那就是强依赖与jquery。\n\n因为是后台，依赖juqery倒也没什么，因为是在pc端使用对文件大小的要求不是特别高，而且基于juqery的插件特别多，有些地方如果自己去处理可能会存在一些不兼容的问题，用插件会避免很多怪异的问题。\n\n由于这个业务交互不是特别复杂，其中有两点可以分享的：一个就是前端处理二维码及下载，只需要从后端获取到生成二维码的url，就可以生成二维码以及把他下载下来，不需要后台的处理；另一个是应用七牛的SDK去上传图片，其上传也是从前端来完成，不需要后端处理。\n\n\n*********\n\n\n### 前端直接生成二维码及下载\n\n\n生成二维码这个没什么，就是一个生成二维码的库[地址](http://jeromeetienne.github.com/jquery-qrcode/)这个库是基于jquery的，github上还有不依赖于jquery的库。这样二维码就生成了。\n\n下载二维码，原理是这样的：把生成的img标签利用canvas的`toDataURL()`方法转变为base64格式的，然后把base64的串放到`a标签`的href属性中。利用`a标签`的download属性，就可以把它下载下来。如果不仅仅需要二维码而是需要在二维码中加入一些文字或者背景图的话，就可以利用canvas把二维码和需要的文字背景图都绘制到canvas中，再获取这个canvas的`toDataURL()`，再依据上面的方法去下载下来。\n\n不过这种方法也有不足的地方，比如说批量下载。这种方法如果需要批量下载就必须依靠js，然后去遍历`a标签`去主动触发click事件。\n\n下面贴一下代码就好咯~ \n\n```js\n//生成二维码\n//可能代码和业务会有一定关联，我把大部分关联的都删掉了\n\n$.ajax({\n//请求要生成url接口\n  url\t\t:\t'http://172.100.101.106:9099/merchant_qrcode/dccode',\n  type\t:\t'POST',\n  dataType:\t'json',\n  data\t:\tpost_data,\n  success:function(data){\n    $(\"#qrcode_box\").html(\"\");\n    if(data['respcd'] == '0000') {\n      var qrcodes = data.data.qrcode_list; \n      for(var i=0;i<qrcodes.length;i++)\n      {\n        var box_label = $(\"<label for='\"+qrcodes[i]['num']+\"'></label>\");\n        var img_panel = $(\"<div class='col-lg-4 col-md-4 col-sm-6'></div>\");\n        var checkbox = $(\"<input class='chk' type='checkbox' id='\"+qrcodes[i]['num']+\"' />\")[0];\n\n        var new_panel = $(\"<div class='bg-panel'></div>\");\n        var new_elem = $(\"<div class='qrcode'></div>\")[0];\n        var new_desc = $(\"<div class='text-desc text-center'><span>\"+qrcodes[i]['area_name']+\" \"+qrcodes[i]['num']+\"</span></div>\")[0];\n        var label = $(\"<label for='\"+qrcodes[i]['num']+\"'></label>\");\n\t\t\n\t\t//拼接dom包含checkbox，显示二维码的div，文字信息的div等\n        new_panel.append(checkbox);\n        new_panel.append(label);\n        new_panel.append(new_elem);\n        new_panel.append(new_desc);\n\t\t\n\t\t//生成下载按钮，把一些信息保存到标签的data属性里，比如要拼接到canvas中的文字和url信息等等。\n        var btn_panel = $(\"<div class='btn-panel'></div>\");\n        var download_elem = $(\"<div style='display:inline-flex;'><button class='m-l btn btn-primary download_pngcode' data-num='\"+qrcodes[i]['num']+\"' data-qrcode='\"+qrcodes[i]['qrcode']+\"' data-area_name='\"+qrcodes[i]['area_name']+\"' onclick=download_qrcode_png(this) >下载桌贴</button><button class='m-l download_code btn btn-warning' data-num='\"+qrcodes[i]['num']+\"' data-qrcode='\"+qrcodes[i]['qrcode']+\"' data-area_name='\"+qrcodes[i]['area_name']+\"' onclick=download_qrcode(this) >下载二维码</button></div>\");\n        btn_panel.append(download_elem);\n\n        img_panel.append(new_panel);\n        img_panel.append(btn_panel);\n        box_label.append(img_panel)\n\t\t//生成二维码\n        var qrcode = new QRCode(new_elem,{\n          width : 131,\n          height:\t131\n        });\n        qrcode.makeCode(qrcodes[i].qrcode);\n      }\n      _this.btnDisabled \n    }\n  }\n});\n\n//下载二维码\n\n//仅下载二维码\nexports.download_qrcode = function (e){\n  var new_elem = $(\"<div></div>\")[0];\n  var qrcode = new QRCode(new_elem,{\n    width : 262,//设置宽高\n    height : 262\n  });\n  console.log($(e));\n  qrcode.makeCode($(e).data('qrcode'));\n  var c=document.createElement('canvas'),ctx=c.getContext('2d');\n  var qr_ele = qrcode;\n  c.width=262;\n  c.height=310;\n  ctx.rect(0,0,c.width,c.height);\n  ctx.fillStyle='#fff';\n  ctx.fill();\n  var img = new Image;\n  img.crossOrigin = 'Anonymous'; //解决跨域\n  img.src = qrcode._el.children[0].toDataURL();\n  ctx.drawImage(img,0,0,262,262);\n\n  ctx.fillStyle='#fe9b20';\n  ctx.font = \"bold 32px 黑体\";\n  ctx.textAlign = \"center\";\n  \n//在二维码下方添加文字\n  var fill_txt = \"\";\n  if($(e).data(\"area_name\") !=\"\"){\n    fill_txt = $(e).data(\"area_name\")+\" \";\n  }\n  if($(e).data(\"num\") != \"\"){\n    fill_txt += ($(e).data(\"num\") + '号桌');\n  }\n  ctx.fillText(fill_txt,131,300);\n  \n//读取生成标签中的data属性，生成下载a标签\n  var $a = $(\"<a></a>\").attr(\"href\", c.toDataURL()).attr(\"download\", $(e).data(\"area_name\")+$(e).data(\"num\")+\".png\");\n  $a[0].click();\n}\n\n//下载带背景图的二维码\nexports.download_qrcode_png = function (e){\n  var new_elem = $(\"<div></div>\")[0];\n  var qrcode = new QRCode(new_elem,{\n    width : 262,//设置宽高\n    height : 262\n  });\n  qrcode.makeCode($(e).data('qrcode'));\n  var c=document.createElement('canvas'),ctx=c.getContext('2d');\n  var qr_ele = qrcode;\n  c.width=460;\n  c.height=620;\n  ctx.rect(0,0,c.width,c.height);\n  ctx.fill();\n  //读取背景图\n  var bg_img = $(\"#background_image\")[0];\n  var img = new Image;\n  img.crossOrigin = 'Anonymous'; //解决跨域\n  img.src = qrcode._el.children[0].toDataURL();\n  //画到canvas中\n  ctx.drawImage(bg_img,0,0,460,620);\n  ctx.drawImage(img,98,162,262,262);\n\n  ctx.fillStyle='#fe9b20';\n  ctx.font = \"bold 32px 黑体\";\n  ctx.textAlign = \"center\";\n\n  var fill_txt = \"\";\n  if($(e).data(\"area_name\") !=\"\"){\n    fill_txt = $(e).data(\"area_name\")+\" \";\n  }\n  if($(e).data(\"num\") != \"\"){\n    fill_txt += ($(e).data(\"num\") + '号桌');\n  }\n  ctx.fillText(fill_txt,230,465);\n\n  //document.body.appendChild(c);\n\n  var $a = $(\"<a></a>\").attr(\"href\", c.toDataURL()).attr(\"download\", $(e).data(\"area_name\")+$(e).data(\"num\")+\".png\");\n  $a[0].click();\n}\n\n```\n\n************\n\n### 使用七牛SDK上传图片\n\n七牛的开发文档地址[这里。](http://developer.qiniu.com/code/v6/sdk/javascript.html#upload)\n\n按照七牛文档和demo就可以很快实现一个上传图片的功能。我来说一下上传的大概过程和我遇到的一个问题。\n\n首先服务端的会先做一些[工作](http://developer.qiniu.com/code/v7/sdk/python.html#io-put)，这个我们不太需要关心只要知道我们在上传图片之前，需要先向服务端去发起一次请求去拿到token和key，因为可以看到七牛上传图片时是需要这两个参数的。然后开始上传图片，上传图片后还有一个成功回调事件，在回调事件中可以做一些事情。（告知服务端图片上传成功了，并把这张图片的url告诉服务端，这样才能把图片对应起来）\n\n这里这再插一句，七牛的SDK使用的plupload插件是这样的：他在初始化的时候需要的参数有token，按钮的`id`，还有一个可选的参数key（这个参数是可以把文件的url替换成你自定义的）。然后会在方法执行时会去寻找你这个id的button，去初始化它，在这个标签下面再去创建一个input标签，在你点击这个id的button的时候他会去隐式的点击下面的input来唤起浏览器选择文件。\n\n好，大概的过程就是这样的。没有什么问题，但是不管文档和demo都只说了只有一个按钮的情况。如果我有一个列表，上面有很多上传按钮这种情况该怎么办？文档上有类似问题：[地址](http://developer.qiniu.com/code/v6/sdk/javascript.html#faq)。但是他这里说的情况是固定的几个按钮，并且知道他的token和key，还有按钮标签的`id`。\n\n这种是不符合我目前需求的，因为我目前整个列表有几个上传按钮都是不确定的，按钮的`id`等等也是不固定的，我要等请求后端接口拿到token和key之后，再去初始化按钮，并且每个按钮和列表每一行的商品要一一对应。所以在完成这个初始化多个上传按钮时碰到了问题。\n\n我们分析一下：如果需要一一对应那么我必须使每一行的button都有自己单独的id、token、和key（因为需要自定义上传图片的url）。\n\n最开始我是这么写的：（大概过程可以看注释）\n\n```js\n//请求商品列表\najax({\n  url: 'http://172.100.101.106:9099/goods/list',\n  method: 'GET',\n  data: data,\n  callback: function (res) {\n    //把初始化队列置空\n    _this.$set('initList', [])\n    if (res.respcd === '0000') {\n      _this.$set('goodsList', res.data.list)\n      //遍历商品列表的每一项，创建一个新的对象包含初始化时需要的id，然后用unionid关联商品列表和新建的初始化列表\n      for (let i = 0, len = res.data.list.length; i < len; i++) {\n        if (res.data.list[i].img === '') {\n          let a = {\n            id: 'img-id-' + res.data.list[i].id,\n            unionid: res.data.list[i].unionid\n          }\n          //把对象push进初始化列表\n          _this.initList.push(a)\n        }\n      }\n    }\n    //这个是vue监听dom渲染完成的事件（可忽略）\n    _this.$nextTick(function () {\n    //初始化列表的每一项进行初始化按钮的操作\n      for (let i = 0, len = _this.initList.length; i < len; i++) {\n        _this.initUpload(_this.initList[i].unionid, _this.initList[i].id)\n      }\n    })\n  }\n})\n\n//方法接受两个参数 \n//unionid 这个参数是最后上传完成后给服务端发请求告知 是哪个商品的图片，让服务端把商品和图片对应起来；\n//id 就是初始化按钮是需要的id；\ninitUpload (unionid, id) {\n        let _this = this\n        //这个是获取token和key的接口，上面过程说明了一下\n        $.ajax({\n          url: 'https://xxxxxxxxx/qiniu_token',\n          type: 'get',\n          dataType: 'json',\n          data: {\n            'appcode':\t'xxxxxx',\n            'func':\t'upload',\n            'format':\t'cors'\n          },\n          async: false,\n          timeout: 3000,\n          success: function (data) {\n            if (data['respcd'] === '0000') {\n              let uptoken = data.data.token\n              ******************\n              let key = data.data.key\n              ******************\n              var uploader = Qiniu.uploader({\n                runtimes: 'html5,flash,html4',    //上传模式,依次退化\n                browse_button: id,       //上传选择的点选按钮，**必需**\n                uptoken: uptoken,\n                domain: 'https://xxxxxxxxx.com/',   //bucket 域名，下载资源时用到，**必需**\n                get_new_uptoken: true,  //设置上传文件的时候是否每次都重新获取新的token\n                max_file_size: '10mb',           //最大文件体积限制\n                flash_swf_url: './flash/Moxie.swf',  //引入flash,相对路径\n                max_retries: 3,                   //上传失败最大重试次数\n                dragdrop: true,                   //开启可拖曳上传\n                drop_element: id,        //拖曳上传区域元素的ID，拖曳文件或文件夹后可触发上传\n                chunk_size: '4mb',                //分块上传时，每片的体积\n                auto_start: true,                 //选择文件后自动上传，若关闭需要自己绑定事件触发上传\n                init: {\n                  'FilesAdded': function (up, files) {\n                    plupload.each(files, function (file) {\n                      // 文件添加进队列后,处理相关的事情\n                    })\n                  },\n                  'BeforeUpload': function (up, file) {\n                    // 每个文件上传前,处理相关的事情\n                  },\n                  'UploadProgress': function (up, file) {\n//                    $('#img_upload-' + rand_num).addClass('spinner')\n                    // 每个文件上传时,处理相关的事情\n                  },\n                  'FileUploaded': function (up, file, info) {\n                    var domain = up.getOption('domain')\n                    var res = JSON.parse(info)\n                    var sourceLink = domain + res.key //获取上传成功后的文件的Url\n\n                    $.ajax({\n                      url: 'http://172.100.101.106:9099/goods/setimg',\n                      type: 'POST',\n                      dataType: 'json',\n                      data: {\n                        'unionid': unionid,\n                        'img': sourceLink\n                      },\n                      success: function (data) {\n                        if (data['respcd'] === '0000') {\n                          window.Materialize.toast('添加商品图片成功', 4000)\n                          _this.getUserInfo(_this.currentPage, _this.pageSize)\n                          }\n                      },\n                      error: function (data) {\n                        window.Materialize.toast(data.respmsg, 4000)\n                      }\n                    })\n                  },\n                  'Error': function (up, err, errTip) {\n                    //上传出错时,处理相关的事情\n                    window.Materialize.toast(errTip, 4000)\n                    $('#img_upload').removeClass('spinner')\n                  },\n                  'UploadComplete': function () {\n                    //队列文件处理完毕后,处理相关的事情\n                  },\n                  'Key': function (up, file) {\n                  \t*************\n                    return key\n                    *************\n                  }\n                }\n              })\n            }\n```\n\n请注意我标********的那几行，我本意是把每一个ajax请求到的key，赋到每一个初始化按钮的方法中去，但是如果我们实际这么去写的话，token是对的，但是key总是最后一个请求的key，原因就是初始化中`'Key'`这个方法，并不是在方法初始化的时候就去执行了，而是你再点击这个按钮的时候再去获取这个key的值，所以当你点击按钮时这个key的值就是最后一次请求到key的值了。（只有一个key会造成上传了多张图片，但是你只会有一个url的情况发生）\n\n那如何去在一个页面用七牛的SDK去初始化N个上传按钮呢？\n\n我当时试了闭包这种方法，大概是这样：\n\n```js\n(function (key) {\n\t//初始化\n\tvar uploader = Qiniu.uploader({}）\n})(key)\n```\n但是并不可以。\n\n找到了一种变通式的解决方法，就是在你每次点击按钮时，去渲染一个新的DOM，再用这个新的DOM去执行初始化的方法：\n\n```js\nvar rand_num = parseInt(Math.random()*100000000)\n$(\"#upload_block\").html(\"\");\nvar html ='<div id=\"img-container-'+rand_num+'\" class=\"dz-default dz-message\"><button id=\"img_upload-'+rand_num+'\" class=\"btn btn-default btn-lg\"><i class=\"glyphicon glyphicon-plus\"></i><span>上传图片</span></button></div>';\n$(\"#upload_block\").html(html);\n\n//然后把这个DOM进行初始化\n```\n这样同步的来进行，一次只有一个token和key，初始化一个按钮，这样就不会存在上面的问题，但是这样就意味着你点击上传按钮之后，又会出来一个蒙层点击蒙层上的按钮才可以选择图片，这样体验未免有些太差了。\n\n#### 解决\n\n最后经过一下午的尝试，最后也是受到了demo的启发：\n\n```js\n'FileUploaded': function(up, file, info) {\n       // 每个文件上传成功后，处理相关的事情\n       // 其中info是文件上传成功后，服务端返回的json，形式如：\n       // {\n       //    \"hash\": \"Fh8xVqod2MQ1mocfI4S4KpRL6D98\",\n       //    \"key\": \"gogopher.jpg\"\n       //  }\n       // 查看简单反馈\n       // var domain = up.getOption('domain');\n       // var res = parseJSON(info);\n       // var sourceLink = domain + res.key; 获取上传成功后的文件的Url\n}\n```\n\n七牛给的上传说明中有这么一段，方法的第一个参数是up，通过注释我们可以看出这个参数可以获取到`Qiniu.uploader`这个方法的一些配置参数的值，比如这一行`var domain = up.getOption('domain');`他就获取到了domain这个配置的值（`即https://xxxxxxxxx.com/`），可以看到`'Key'`这个方法也会接受`up`这个参数，所以可不可以在配置中多加一个keyValue的多余配置，来储存key值呢？\n\n经过试验答案是可以的！大概这样：（相同代码就不再重复）\n\n```js\nvar uploader = Qiniu.uploader({\n    keyValue: key,\n    \n    .....\n    \n    \n    init: {\n    \n    .....\n    \n      'Key': function (up, file) {\n        let key = up.getOption('keyValue')\n        return key\n      }\n    }\n\n```\n\n其他地方不变，这样经过试验可以很好地解决初始化多个按钮的问题！\n\n","slug":"前端直接生成及下载二维码和使用七牛SDK上传图片","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg206002xsq5l9nayzzgd","content":"<p>最近工作比较紧张，除了日常的小需求之外，还做了一个给商户用的后台。技术栈除了vue之外，还用到了<code>materialize</code>这个UI库<a href=\"https://github.com/dogfalo/materialize/\" target=\"_blank\" rel=\"external\">地址</a>，但是这个库有一个缺点，那就是强依赖与jquery。</p>\n<p>因为是后台，依赖juqery倒也没什么，因为是在pc端使用对文件大小的要求不是特别高，而且基于juqery的插件特别多，有些地方如果自己去处理可能会存在一些不兼容的问题，用插件会避免很多怪异的问题。</p>\n<p>由于这个业务交互不是特别复杂，其中有两点可以分享的：一个就是前端处理二维码及下载，只需要从后端获取到生成二维码的url，就可以生成二维码以及把他下载下来，不需要后台的处理；另一个是应用七牛的SDK去上传图片，其上传也是从前端来完成，不需要后端处理。</p>\n<hr>\n<h3 id=\"前端直接生成二维码及下载\"><a href=\"#前端直接生成二维码及下载\" class=\"headerlink\" title=\"前端直接生成二维码及下载\"></a>前端直接生成二维码及下载</h3><p>生成二维码这个没什么，就是一个生成二维码的库<a href=\"http://jeromeetienne.github.com/jquery-qrcode/\" target=\"_blank\" rel=\"external\">地址</a>这个库是基于jquery的，github上还有不依赖于jquery的库。这样二维码就生成了。</p>\n<p>下载二维码，原理是这样的：把生成的img标签利用canvas的<code>toDataURL()</code>方法转变为base64格式的，然后把base64的串放到<code>a标签</code>的href属性中。利用<code>a标签</code>的download属性，就可以把它下载下来。如果不仅仅需要二维码而是需要在二维码中加入一些文字或者背景图的话，就可以利用canvas把二维码和需要的文字背景图都绘制到canvas中，再获取这个canvas的<code>toDataURL()</code>，再依据上面的方法去下载下来。</p>\n<p>不过这种方法也有不足的地方，比如说批量下载。这种方法如果需要批量下载就必须依靠js，然后去遍历<code>a标签</code>去主动触发click事件。</p>\n<p>下面贴一下代码就好咯~ </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//生成二维码</span></span><br><span class=\"line\"><span class=\"comment\">//可能代码和业务会有一定关联，我把大部分关联的都删掉了</span></span><br><span class=\"line\"></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\"><span class=\"comment\">//请求要生成url接口</span></span><br><span class=\"line\">  url\t\t:\t<span class=\"string\">'http://172.100.101.106:9099/merchant_qrcode/dccode'</span>,</span><br><span class=\"line\">  type\t:\t<span class=\"string\">'POST'</span>,</span><br><span class=\"line\">  dataType:\t<span class=\"string\">'json'</span>,</span><br><span class=\"line\">  data\t:\tpost_data,</span><br><span class=\"line\">  success:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    $(<span class=\"string\">\"#qrcode_box\"</span>).html(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(data[<span class=\"string\">'respcd'</span>] == <span class=\"string\">'0000'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> qrcodes = data.data.qrcode_list; </span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;qrcodes.length;i++)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> box_label = $(<span class=\"string\">\"&lt;label for='\"</span>+qrcodes[i][<span class=\"string\">'num'</span>]+<span class=\"string\">\"'&gt;&lt;/label&gt;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> img_panel = $(<span class=\"string\">\"&lt;div class='col-lg-4 col-md-4 col-sm-6'&gt;&lt;/div&gt;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> checkbox = $(<span class=\"string\">\"&lt;input class='chk' type='checkbox' id='\"</span>+qrcodes[i][<span class=\"string\">'num'</span>]+<span class=\"string\">\"' /&gt;\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> new_panel = $(<span class=\"string\">\"&lt;div class='bg-panel'&gt;&lt;/div&gt;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> new_elem = $(<span class=\"string\">\"&lt;div class='qrcode'&gt;&lt;/div&gt;\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> new_desc = $(<span class=\"string\">\"&lt;div class='text-desc text-center'&gt;&lt;span&gt;\"</span>+qrcodes[i][<span class=\"string\">'area_name'</span>]+<span class=\"string\">\" \"</span>+qrcodes[i][<span class=\"string\">'num'</span>]+<span class=\"string\">\"&lt;/span&gt;&lt;/div&gt;\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> label = $(<span class=\"string\">\"&lt;label for='\"</span>+qrcodes[i][<span class=\"string\">'num'</span>]+<span class=\"string\">\"'&gt;&lt;/label&gt;\"</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//拼接dom包含checkbox，显示二维码的div，文字信息的div等</span></span><br><span class=\"line\">        new_panel.append(checkbox);</span><br><span class=\"line\">        new_panel.append(label);</span><br><span class=\"line\">        new_panel.append(new_elem);</span><br><span class=\"line\">        new_panel.append(new_desc);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//生成下载按钮，把一些信息保存到标签的data属性里，比如要拼接到canvas中的文字和url信息等等。</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> btn_panel = $(<span class=\"string\">\"&lt;div class='btn-panel'&gt;&lt;/div&gt;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> download_elem = $(<span class=\"string\">\"&lt;div style='display:inline-flex;'&gt;&lt;button class='m-l btn btn-primary download_pngcode' data-num='\"</span>+qrcodes[i][<span class=\"string\">'num'</span>]+<span class=\"string\">\"' data-qrcode='\"</span>+qrcodes[i][<span class=\"string\">'qrcode'</span>]+<span class=\"string\">\"' data-area_name='\"</span>+qrcodes[i][<span class=\"string\">'area_name'</span>]+<span class=\"string\">\"' onclick=download_qrcode_png(this) &gt;下载桌贴&lt;/button&gt;&lt;button class='m-l download_code btn btn-warning' data-num='\"</span>+qrcodes[i][<span class=\"string\">'num'</span>]+<span class=\"string\">\"' data-qrcode='\"</span>+qrcodes[i][<span class=\"string\">'qrcode'</span>]+<span class=\"string\">\"' data-area_name='\"</span>+qrcodes[i][<span class=\"string\">'area_name'</span>]+<span class=\"string\">\"' onclick=download_qrcode(this) &gt;下载二维码&lt;/button&gt;&lt;/div&gt;\"</span>);</span><br><span class=\"line\">        btn_panel.append(download_elem);</span><br><span class=\"line\"></span><br><span class=\"line\">        img_panel.append(new_panel);</span><br><span class=\"line\">        img_panel.append(btn_panel);</span><br><span class=\"line\">        box_label.append(img_panel)</span><br><span class=\"line\">\t\t<span class=\"comment\">//生成二维码</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> qrcode = <span class=\"keyword\">new</span> QRCode(new_elem,&#123;</span><br><span class=\"line\">          width : <span class=\"number\">131</span>,</span><br><span class=\"line\">          height:\t<span class=\"number\">131</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        qrcode.makeCode(qrcodes[i].qrcode);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      _this.btnDisabled </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//下载二维码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//仅下载二维码</span></span><br><span class=\"line\">exports.download_qrcode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> new_elem = $(<span class=\"string\">\"&lt;div&gt;&lt;/div&gt;\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> qrcode = <span class=\"keyword\">new</span> QRCode(new_elem,&#123;</span><br><span class=\"line\">    width : <span class=\"number\">262</span>,<span class=\"comment\">//设置宽高</span></span><br><span class=\"line\">    height : <span class=\"number\">262</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log($(e));</span><br><span class=\"line\">  qrcode.makeCode($(e).data(<span class=\"string\">'qrcode'</span>));</span><br><span class=\"line\">  <span class=\"keyword\">var</span> c=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>),ctx=c.getContext(<span class=\"string\">'2d'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> qr_ele = qrcode;</span><br><span class=\"line\">  c.width=<span class=\"number\">262</span>;</span><br><span class=\"line\">  c.height=<span class=\"number\">310</span>;</span><br><span class=\"line\">  ctx.rect(<span class=\"number\">0</span>,<span class=\"number\">0</span>,c.width,c.height);</span><br><span class=\"line\">  ctx.fillStyle=<span class=\"string\">'#fff'</span>;</span><br><span class=\"line\">  ctx.fill();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image;</span><br><span class=\"line\">  img.crossOrigin = <span class=\"string\">'Anonymous'</span>; <span class=\"comment\">//解决跨域</span></span><br><span class=\"line\">  img.src = qrcode._el.children[<span class=\"number\">0</span>].toDataURL();</span><br><span class=\"line\">  ctx.drawImage(img,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">262</span>,<span class=\"number\">262</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  ctx.fillStyle=<span class=\"string\">'#fe9b20'</span>;</span><br><span class=\"line\">  ctx.font = <span class=\"string\">\"bold 32px 黑体\"</span>;</span><br><span class=\"line\">  ctx.textAlign = <span class=\"string\">\"center\"</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//在二维码下方添加文字</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fill_txt = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>($(e).data(<span class=\"string\">\"area_name\"</span>) !=<span class=\"string\">\"\"</span>)&#123;</span><br><span class=\"line\">    fill_txt = $(e).data(<span class=\"string\">\"area_name\"</span>)+<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>($(e).data(<span class=\"string\">\"num\"</span>) != <span class=\"string\">\"\"</span>)&#123;</span><br><span class=\"line\">    fill_txt += ($(e).data(<span class=\"string\">\"num\"</span>) + <span class=\"string\">'号桌'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ctx.fillText(fill_txt,<span class=\"number\">131</span>,<span class=\"number\">300</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//读取生成标签中的data属性，生成下载a标签</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> $a = $(<span class=\"string\">\"&lt;a&gt;&lt;/a&gt;\"</span>).attr(<span class=\"string\">\"href\"</span>, c.toDataURL()).attr(<span class=\"string\">\"download\"</span>, $(e).data(<span class=\"string\">\"area_name\"</span>)+$(e).data(<span class=\"string\">\"num\"</span>)+<span class=\"string\">\".png\"</span>);</span><br><span class=\"line\">  $a[<span class=\"number\">0</span>].click();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//下载带背景图的二维码</span></span><br><span class=\"line\">exports.download_qrcode_png = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> new_elem = $(<span class=\"string\">\"&lt;div&gt;&lt;/div&gt;\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> qrcode = <span class=\"keyword\">new</span> QRCode(new_elem,&#123;</span><br><span class=\"line\">    width : <span class=\"number\">262</span>,<span class=\"comment\">//设置宽高</span></span><br><span class=\"line\">    height : <span class=\"number\">262</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  qrcode.makeCode($(e).data(<span class=\"string\">'qrcode'</span>));</span><br><span class=\"line\">  <span class=\"keyword\">var</span> c=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>),ctx=c.getContext(<span class=\"string\">'2d'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> qr_ele = qrcode;</span><br><span class=\"line\">  c.width=<span class=\"number\">460</span>;</span><br><span class=\"line\">  c.height=<span class=\"number\">620</span>;</span><br><span class=\"line\">  ctx.rect(<span class=\"number\">0</span>,<span class=\"number\">0</span>,c.width,c.height);</span><br><span class=\"line\">  ctx.fill();</span><br><span class=\"line\">  <span class=\"comment\">//读取背景图</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> bg_img = $(<span class=\"string\">\"#background_image\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image;</span><br><span class=\"line\">  img.crossOrigin = <span class=\"string\">'Anonymous'</span>; <span class=\"comment\">//解决跨域</span></span><br><span class=\"line\">  img.src = qrcode._el.children[<span class=\"number\">0</span>].toDataURL();</span><br><span class=\"line\">  <span class=\"comment\">//画到canvas中</span></span><br><span class=\"line\">  ctx.drawImage(bg_img,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">460</span>,<span class=\"number\">620</span>);</span><br><span class=\"line\">  ctx.drawImage(img,<span class=\"number\">98</span>,<span class=\"number\">162</span>,<span class=\"number\">262</span>,<span class=\"number\">262</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  ctx.fillStyle=<span class=\"string\">'#fe9b20'</span>;</span><br><span class=\"line\">  ctx.font = <span class=\"string\">\"bold 32px 黑体\"</span>;</span><br><span class=\"line\">  ctx.textAlign = <span class=\"string\">\"center\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fill_txt = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>($(e).data(<span class=\"string\">\"area_name\"</span>) !=<span class=\"string\">\"\"</span>)&#123;</span><br><span class=\"line\">    fill_txt = $(e).data(<span class=\"string\">\"area_name\"</span>)+<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>($(e).data(<span class=\"string\">\"num\"</span>) != <span class=\"string\">\"\"</span>)&#123;</span><br><span class=\"line\">    fill_txt += ($(e).data(<span class=\"string\">\"num\"</span>) + <span class=\"string\">'号桌'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ctx.fillText(fill_txt,<span class=\"number\">230</span>,<span class=\"number\">465</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//document.body.appendChild(c);</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> $a = $(<span class=\"string\">\"&lt;a&gt;&lt;/a&gt;\"</span>).attr(<span class=\"string\">\"href\"</span>, c.toDataURL()).attr(<span class=\"string\">\"download\"</span>, $(e).data(<span class=\"string\">\"area_name\"</span>)+$(e).data(<span class=\"string\">\"num\"</span>)+<span class=\"string\">\".png\"</span>);</span><br><span class=\"line\">  $a[<span class=\"number\">0</span>].click();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"使用七牛SDK上传图片\"><a href=\"#使用七牛SDK上传图片\" class=\"headerlink\" title=\"使用七牛SDK上传图片\"></a>使用七牛SDK上传图片</h3><p>七牛的开发文档地址<a href=\"http://developer.qiniu.com/code/v6/sdk/javascript.html#upload\" target=\"_blank\" rel=\"external\">这里。</a></p>\n<p>按照七牛文档和demo就可以很快实现一个上传图片的功能。我来说一下上传的大概过程和我遇到的一个问题。</p>\n<p>首先服务端的会先做一些<a href=\"http://developer.qiniu.com/code/v7/sdk/python.html#io-put\" target=\"_blank\" rel=\"external\">工作</a>，这个我们不太需要关心只要知道我们在上传图片之前，需要先向服务端去发起一次请求去拿到token和key，因为可以看到七牛上传图片时是需要这两个参数的。然后开始上传图片，上传图片后还有一个成功回调事件，在回调事件中可以做一些事情。（告知服务端图片上传成功了，并把这张图片的url告诉服务端，这样才能把图片对应起来）</p>\n<p>这里这再插一句，七牛的SDK使用的plupload插件是这样的：他在初始化的时候需要的参数有token，按钮的<code>id</code>，还有一个可选的参数key（这个参数是可以把文件的url替换成你自定义的）。然后会在方法执行时会去寻找你这个id的button，去初始化它，在这个标签下面再去创建一个input标签，在你点击这个id的button的时候他会去隐式的点击下面的input来唤起浏览器选择文件。</p>\n<p>好，大概的过程就是这样的。没有什么问题，但是不管文档和demo都只说了只有一个按钮的情况。如果我有一个列表，上面有很多上传按钮这种情况该怎么办？文档上有类似问题：<a href=\"http://developer.qiniu.com/code/v6/sdk/javascript.html#faq\" target=\"_blank\" rel=\"external\">地址</a>。但是他这里说的情况是固定的几个按钮，并且知道他的token和key，还有按钮标签的<code>id</code>。</p>\n<p>这种是不符合我目前需求的，因为我目前整个列表有几个上传按钮都是不确定的，按钮的<code>id</code>等等也是不固定的，我要等请求后端接口拿到token和key之后，再去初始化按钮，并且每个按钮和列表每一行的商品要一一对应。所以在完成这个初始化多个上传按钮时碰到了问题。</p>\n<p>我们分析一下：如果需要一一对应那么我必须使每一行的button都有自己单独的id、token、和key（因为需要自定义上传图片的url）。</p>\n<p>最开始我是这么写的：（大概过程可以看注释）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//请求商品列表</span></span><br><span class=\"line\">ajax(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">'http://172.100.101.106:9099/goods/list'</span>,</span><br><span class=\"line\">  method: <span class=\"string\">'GET'</span>,</span><br><span class=\"line\">  data: data,</span><br><span class=\"line\">  callback: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//把初始化队列置空</span></span><br><span class=\"line\">    _this.$set(<span class=\"string\">'initList'</span>, [])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.respcd === <span class=\"string\">'0000'</span>) &#123;</span><br><span class=\"line\">      _this.$set(<span class=\"string\">'goodsList'</span>, res.data.list)</span><br><span class=\"line\">      <span class=\"comment\">//遍历商品列表的每一项，创建一个新的对象包含初始化时需要的id，然后用unionid关联商品列表和新建的初始化列表</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = res.data.list.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res.data.list[i].img === <span class=\"string\">''</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> a = &#123;</span><br><span class=\"line\">            id: <span class=\"string\">'img-id-'</span> + res.data.list[i].id,</span><br><span class=\"line\">            unionid: res.data.list[i].unionid</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">//把对象push进初始化列表</span></span><br><span class=\"line\">          _this.initList.push(a)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//这个是vue监听dom渲染完成的事件（可忽略）</span></span><br><span class=\"line\">    _this.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化列表的每一项进行初始化按钮的操作</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = _this.initList.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        _this.initUpload(_this.initList[i].unionid, _this.initList[i].id)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方法接受两个参数 </span></span><br><span class=\"line\"><span class=\"comment\">//unionid 这个参数是最后上传完成后给服务端发请求告知 是哪个商品的图片，让服务端把商品和图片对应起来；</span></span><br><span class=\"line\"><span class=\"comment\">//id 就是初始化按钮是需要的id；</span></span><br><span class=\"line\">initUpload (unionid, id) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"comment\">//这个是获取token和key的接口，上面过程说明了一下</span></span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">          url: <span class=\"string\">'https://xxxxxxxxx/qiniu_token'</span>,</span><br><span class=\"line\">          type: <span class=\"string\">'get'</span>,</span><br><span class=\"line\">          dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">          data: &#123;</span><br><span class=\"line\">            <span class=\"string\">'appcode'</span>:\t<span class=\"string\">'xxxxxx'</span>,</span><br><span class=\"line\">            <span class=\"string\">'func'</span>:\t<span class=\"string\">'upload'</span>,</span><br><span class=\"line\">            <span class=\"string\">'format'</span>:\t<span class=\"string\">'cors'</span></span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"keyword\">async</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          timeout: <span class=\"number\">3000</span>,</span><br><span class=\"line\">          success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data[<span class=\"string\">'respcd'</span>] === <span class=\"string\">'0000'</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">let</span> uptoken = data.data.token</span><br><span class=\"line\">              ******************</span><br><span class=\"line\">              <span class=\"keyword\">let</span> key = data.data.key</span><br><span class=\"line\">              ******************</span><br><span class=\"line\">              <span class=\"keyword\">var</span> uploader = Qiniu.uploader(&#123;</span><br><span class=\"line\">                runtimes: <span class=\"string\">'html5,flash,html4'</span>,    <span class=\"comment\">//上传模式,依次退化</span></span><br><span class=\"line\">                browse_button: id,       <span class=\"comment\">//上传选择的点选按钮，**必需**</span></span><br><span class=\"line\">                uptoken: uptoken,</span><br><span class=\"line\">                domain: <span class=\"string\">'https://xxxxxxxxx.com/'</span>,   <span class=\"comment\">//bucket 域名，下载资源时用到，**必需**</span></span><br><span class=\"line\">                get_new_uptoken: <span class=\"literal\">true</span>,  <span class=\"comment\">//设置上传文件的时候是否每次都重新获取新的token</span></span><br><span class=\"line\">                max_file_size: <span class=\"string\">'10mb'</span>,           <span class=\"comment\">//最大文件体积限制</span></span><br><span class=\"line\">                flash_swf_url: <span class=\"string\">'./flash/Moxie.swf'</span>,  <span class=\"comment\">//引入flash,相对路径</span></span><br><span class=\"line\">                max_retries: <span class=\"number\">3</span>,                   <span class=\"comment\">//上传失败最大重试次数</span></span><br><span class=\"line\">                dragdrop: <span class=\"literal\">true</span>,                   <span class=\"comment\">//开启可拖曳上传</span></span><br><span class=\"line\">                drop_element: id,        <span class=\"comment\">//拖曳上传区域元素的ID，拖曳文件或文件夹后可触发上传</span></span><br><span class=\"line\">                chunk_size: <span class=\"string\">'4mb'</span>,                <span class=\"comment\">//分块上传时，每片的体积</span></span><br><span class=\"line\">                auto_start: <span class=\"literal\">true</span>,                 <span class=\"comment\">//选择文件后自动上传，若关闭需要自己绑定事件触发上传</span></span><br><span class=\"line\">                init: &#123;</span><br><span class=\"line\">                  <span class=\"string\">'FilesAdded'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, files</span>) </span>&#123;</span><br><span class=\"line\">                    plupload.each(files, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">file</span>) </span>&#123;</span><br><span class=\"line\">                      <span class=\"comment\">// 文件添加进队列后,处理相关的事情</span></span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">'BeforeUpload'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 每个文件上传前,处理相关的事情</span></span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">'UploadProgress'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//                    $('#img_upload-' + rand_num).addClass('spinner')</span></span><br><span class=\"line\">                    <span class=\"comment\">// 每个文件上传时,处理相关的事情</span></span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">'FileUploaded'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, file, info</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> domain = up.getOption(<span class=\"string\">'domain'</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> res = <span class=\"built_in\">JSON</span>.parse(info)</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> sourceLink = domain + res.key <span class=\"comment\">//获取上传成功后的文件的Url</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    $.ajax(&#123;</span><br><span class=\"line\">                      url: <span class=\"string\">'http://172.100.101.106:9099/goods/setimg'</span>,</span><br><span class=\"line\">                      type: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">                      dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">                      data: &#123;</span><br><span class=\"line\">                        <span class=\"string\">'unionid'</span>: unionid,</span><br><span class=\"line\">                        <span class=\"string\">'img'</span>: sourceLink</span><br><span class=\"line\">                      &#125;,</span><br><span class=\"line\">                      success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (data[<span class=\"string\">'respcd'</span>] === <span class=\"string\">'0000'</span>) &#123;</span><br><span class=\"line\">                          <span class=\"built_in\">window</span>.Materialize.toast(<span class=\"string\">'添加商品图片成功'</span>, <span class=\"number\">4000</span>)</span><br><span class=\"line\">                          _this.getUserInfo(_this.currentPage, _this.pageSize)</span><br><span class=\"line\">                          &#125;</span><br><span class=\"line\">                      &#125;,</span><br><span class=\"line\">                      error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"built_in\">window</span>.Materialize.toast(data.respmsg, <span class=\"number\">4000</span>)</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">'Error'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, err, errTip</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//上传出错时,处理相关的事情</span></span><br><span class=\"line\">                    <span class=\"built_in\">window</span>.Materialize.toast(errTip, <span class=\"number\">4000</span>)</span><br><span class=\"line\">                    $(<span class=\"string\">'#img_upload'</span>).removeClass(<span class=\"string\">'spinner'</span>)</span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">'UploadComplete'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//队列文件处理完毕后,处理相关的事情</span></span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">'Key'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\">                  \t*************</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> key</span><br><span class=\"line\">                    *************</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>请注意我标<strong><em>**</em></strong>的那几行，我本意是把每一个ajax请求到的key，赋到每一个初始化按钮的方法中去，但是如果我们实际这么去写的话，token是对的，但是key总是最后一个请求的key，原因就是初始化中<code>&#39;Key&#39;</code>这个方法，并不是在方法初始化的时候就去执行了，而是你再点击这个按钮的时候再去获取这个key的值，所以当你点击按钮时这个key的值就是最后一次请求到key的值了。（只有一个key会造成上传了多张图片，但是你只会有一个url的情况发生）</p>\n<p>那如何去在一个页面用七牛的SDK去初始化N个上传按钮呢？</p>\n<p>我当时试了闭包这种方法，大概是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> uploader = Qiniu.uploader(&#123;&#125;）</span><br><span class=\"line\">&#125;)(key)</span><br></pre></td></tr></table></figure>\n<p>但是并不可以。</p>\n<p>找到了一种变通式的解决方法，就是在你每次点击按钮时，去渲染一个新的DOM，再用这个新的DOM去执行初始化的方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rand_num = <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.random()*<span class=\"number\">100000000</span>)</span><br><span class=\"line\">$(<span class=\"string\">\"#upload_block\"</span>).html(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> html =<span class=\"string\">'&lt;div id=\"img-container-'</span>+rand_num+<span class=\"string\">'\" class=\"dz-default dz-message\"&gt;&lt;button id=\"img_upload-'</span>+rand_num+<span class=\"string\">'\" class=\"btn btn-default btn-lg\"&gt;&lt;i class=\"glyphicon glyphicon-plus\"&gt;&lt;/i&gt;&lt;span&gt;上传图片&lt;/span&gt;&lt;/button&gt;&lt;/div&gt;'</span>;</span><br><span class=\"line\">$(<span class=\"string\">\"#upload_block\"</span>).html(html);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//然后把这个DOM进行初始化</span></span><br></pre></td></tr></table></figure>\n<p>这样同步的来进行，一次只有一个token和key，初始化一个按钮，这样就不会存在上面的问题，但是这样就意味着你点击上传按钮之后，又会出来一个蒙层点击蒙层上的按钮才可以选择图片，这样体验未免有些太差了。</p>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><p>最后经过一下午的尝试，最后也是受到了demo的启发：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'FileUploaded'</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, file, info</span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 每个文件上传成功后，处理相关的事情</span></span><br><span class=\"line\">       <span class=\"comment\">// 其中info是文件上传成功后，服务端返回的json，形式如：</span></span><br><span class=\"line\">       <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">       <span class=\"comment\">//    \"hash\": \"Fh8xVqod2MQ1mocfI4S4KpRL6D98\",</span></span><br><span class=\"line\">       <span class=\"comment\">//    \"key\": \"gogopher.jpg\"</span></span><br><span class=\"line\">       <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">       <span class=\"comment\">// 查看简单反馈</span></span><br><span class=\"line\">       <span class=\"comment\">// var domain = up.getOption('domain');</span></span><br><span class=\"line\">       <span class=\"comment\">// var res = parseJSON(info);</span></span><br><span class=\"line\">       <span class=\"comment\">// var sourceLink = domain + res.key; 获取上传成功后的文件的Url</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>七牛给的上传说明中有这么一段，方法的第一个参数是up，通过注释我们可以看出这个参数可以获取到<code>Qiniu.uploader</code>这个方法的一些配置参数的值，比如这一行<code>var domain = up.getOption(&#39;domain&#39;);</code>他就获取到了domain这个配置的值（<code>即https://xxxxxxxxx.com/</code>），可以看到<code>&#39;Key&#39;</code>这个方法也会接受<code>up</code>这个参数，所以可不可以在配置中多加一个keyValue的多余配置，来储存key值呢？</p>\n<p>经过试验答案是可以的！大概这样：（相同代码就不再重复）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> uploader = Qiniu.uploader(&#123;</span><br><span class=\"line\">    keyValue: key,</span><br><span class=\"line\">    </span><br><span class=\"line\">    .....</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    init: &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    .....</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"string\">'Key'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> key = up.getOption(<span class=\"string\">'keyValue'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其他地方不变，这样经过试验可以很好地解决初始化多个按钮的问题！</p>\n","excerpt":"","more":"<p>最近工作比较紧张，除了日常的小需求之外，还做了一个给商户用的后台。技术栈除了vue之外，还用到了<code>materialize</code>这个UI库<a href=\"https://github.com/dogfalo/materialize/\">地址</a>，但是这个库有一个缺点，那就是强依赖与jquery。</p>\n<p>因为是后台，依赖juqery倒也没什么，因为是在pc端使用对文件大小的要求不是特别高，而且基于juqery的插件特别多，有些地方如果自己去处理可能会存在一些不兼容的问题，用插件会避免很多怪异的问题。</p>\n<p>由于这个业务交互不是特别复杂，其中有两点可以分享的：一个就是前端处理二维码及下载，只需要从后端获取到生成二维码的url，就可以生成二维码以及把他下载下来，不需要后台的处理；另一个是应用七牛的SDK去上传图片，其上传也是从前端来完成，不需要后端处理。</p>\n<hr>\n<h3 id=\"前端直接生成二维码及下载\"><a href=\"#前端直接生成二维码及下载\" class=\"headerlink\" title=\"前端直接生成二维码及下载\"></a>前端直接生成二维码及下载</h3><p>生成二维码这个没什么，就是一个生成二维码的库<a href=\"http://jeromeetienne.github.com/jquery-qrcode/\">地址</a>这个库是基于jquery的，github上还有不依赖于jquery的库。这样二维码就生成了。</p>\n<p>下载二维码，原理是这样的：把生成的img标签利用canvas的<code>toDataURL()</code>方法转变为base64格式的，然后把base64的串放到<code>a标签</code>的href属性中。利用<code>a标签</code>的download属性，就可以把它下载下来。如果不仅仅需要二维码而是需要在二维码中加入一些文字或者背景图的话，就可以利用canvas把二维码和需要的文字背景图都绘制到canvas中，再获取这个canvas的<code>toDataURL()</code>，再依据上面的方法去下载下来。</p>\n<p>不过这种方法也有不足的地方，比如说批量下载。这种方法如果需要批量下载就必须依靠js，然后去遍历<code>a标签</code>去主动触发click事件。</p>\n<p>下面贴一下代码就好咯~ </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//生成二维码</span></span><br><span class=\"line\"><span class=\"comment\">//可能代码和业务会有一定关联，我把大部分关联的都删掉了</span></span><br><span class=\"line\"></span><br><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\"><span class=\"comment\">//请求要生成url接口</span></span><br><span class=\"line\">  url\t\t:\t<span class=\"string\">'http://172.100.101.106:9099/merchant_qrcode/dccode'</span>,</span><br><span class=\"line\">  type\t:\t<span class=\"string\">'POST'</span>,</span><br><span class=\"line\">  dataType:\t<span class=\"string\">'json'</span>,</span><br><span class=\"line\">  data\t:\tpost_data,</span><br><span class=\"line\">  success:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    $(<span class=\"string\">\"#qrcode_box\"</span>).html(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(data[<span class=\"string\">'respcd'</span>] == <span class=\"string\">'0000'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> qrcodes = data.data.qrcode_list; </span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;qrcodes.length;i++)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> box_label = $(<span class=\"string\">\"&lt;label for='\"</span>+qrcodes[i][<span class=\"string\">'num'</span>]+<span class=\"string\">\"'&gt;&lt;/label&gt;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> img_panel = $(<span class=\"string\">\"&lt;div class='col-lg-4 col-md-4 col-sm-6'&gt;&lt;/div&gt;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> checkbox = $(<span class=\"string\">\"&lt;input class='chk' type='checkbox' id='\"</span>+qrcodes[i][<span class=\"string\">'num'</span>]+<span class=\"string\">\"' /&gt;\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> new_panel = $(<span class=\"string\">\"&lt;div class='bg-panel'&gt;&lt;/div&gt;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> new_elem = $(<span class=\"string\">\"&lt;div class='qrcode'&gt;&lt;/div&gt;\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> new_desc = $(<span class=\"string\">\"&lt;div class='text-desc text-center'&gt;&lt;span&gt;\"</span>+qrcodes[i][<span class=\"string\">'area_name'</span>]+<span class=\"string\">\" \"</span>+qrcodes[i][<span class=\"string\">'num'</span>]+<span class=\"string\">\"&lt;/span&gt;&lt;/div&gt;\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> label = $(<span class=\"string\">\"&lt;label for='\"</span>+qrcodes[i][<span class=\"string\">'num'</span>]+<span class=\"string\">\"'&gt;&lt;/label&gt;\"</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//拼接dom包含checkbox，显示二维码的div，文字信息的div等</span></span><br><span class=\"line\">        new_panel.append(checkbox);</span><br><span class=\"line\">        new_panel.append(label);</span><br><span class=\"line\">        new_panel.append(new_elem);</span><br><span class=\"line\">        new_panel.append(new_desc);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//生成下载按钮，把一些信息保存到标签的data属性里，比如要拼接到canvas中的文字和url信息等等。</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> btn_panel = $(<span class=\"string\">\"&lt;div class='btn-panel'&gt;&lt;/div&gt;\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> download_elem = $(<span class=\"string\">\"&lt;div style='display:inline-flex;'&gt;&lt;button class='m-l btn btn-primary download_pngcode' data-num='\"</span>+qrcodes[i][<span class=\"string\">'num'</span>]+<span class=\"string\">\"' data-qrcode='\"</span>+qrcodes[i][<span class=\"string\">'qrcode'</span>]+<span class=\"string\">\"' data-area_name='\"</span>+qrcodes[i][<span class=\"string\">'area_name'</span>]+<span class=\"string\">\"' onclick=download_qrcode_png(this) &gt;下载桌贴&lt;/button&gt;&lt;button class='m-l download_code btn btn-warning' data-num='\"</span>+qrcodes[i][<span class=\"string\">'num'</span>]+<span class=\"string\">\"' data-qrcode='\"</span>+qrcodes[i][<span class=\"string\">'qrcode'</span>]+<span class=\"string\">\"' data-area_name='\"</span>+qrcodes[i][<span class=\"string\">'area_name'</span>]+<span class=\"string\">\"' onclick=download_qrcode(this) &gt;下载二维码&lt;/button&gt;&lt;/div&gt;\"</span>);</span><br><span class=\"line\">        btn_panel.append(download_elem);</span><br><span class=\"line\"></span><br><span class=\"line\">        img_panel.append(new_panel);</span><br><span class=\"line\">        img_panel.append(btn_panel);</span><br><span class=\"line\">        box_label.append(img_panel)</span><br><span class=\"line\">\t\t<span class=\"comment\">//生成二维码</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> qrcode = <span class=\"keyword\">new</span> QRCode(new_elem,&#123;</span><br><span class=\"line\">          width : <span class=\"number\">131</span>,</span><br><span class=\"line\">          height:\t<span class=\"number\">131</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        qrcode.makeCode(qrcodes[i].qrcode);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      _this.btnDisabled </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//下载二维码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//仅下载二维码</span></span><br><span class=\"line\">exports.download_qrcode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> new_elem = $(<span class=\"string\">\"&lt;div&gt;&lt;/div&gt;\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> qrcode = <span class=\"keyword\">new</span> QRCode(new_elem,&#123;</span><br><span class=\"line\">    width : <span class=\"number\">262</span>,<span class=\"comment\">//设置宽高</span></span><br><span class=\"line\">    height : <span class=\"number\">262</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log($(e));</span><br><span class=\"line\">  qrcode.makeCode($(e).data(<span class=\"string\">'qrcode'</span>));</span><br><span class=\"line\">  <span class=\"keyword\">var</span> c=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>),ctx=c.getContext(<span class=\"string\">'2d'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> qr_ele = qrcode;</span><br><span class=\"line\">  c.width=<span class=\"number\">262</span>;</span><br><span class=\"line\">  c.height=<span class=\"number\">310</span>;</span><br><span class=\"line\">  ctx.rect(<span class=\"number\">0</span>,<span class=\"number\">0</span>,c.width,c.height);</span><br><span class=\"line\">  ctx.fillStyle=<span class=\"string\">'#fff'</span>;</span><br><span class=\"line\">  ctx.fill();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image;</span><br><span class=\"line\">  img.crossOrigin = <span class=\"string\">'Anonymous'</span>; <span class=\"comment\">//解决跨域</span></span><br><span class=\"line\">  img.src = qrcode._el.children[<span class=\"number\">0</span>].toDataURL();</span><br><span class=\"line\">  ctx.drawImage(img,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">262</span>,<span class=\"number\">262</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  ctx.fillStyle=<span class=\"string\">'#fe9b20'</span>;</span><br><span class=\"line\">  ctx.font = <span class=\"string\">\"bold 32px 黑体\"</span>;</span><br><span class=\"line\">  ctx.textAlign = <span class=\"string\">\"center\"</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//在二维码下方添加文字</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fill_txt = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>($(e).data(<span class=\"string\">\"area_name\"</span>) !=<span class=\"string\">\"\"</span>)&#123;</span><br><span class=\"line\">    fill_txt = $(e).data(<span class=\"string\">\"area_name\"</span>)+<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>($(e).data(<span class=\"string\">\"num\"</span>) != <span class=\"string\">\"\"</span>)&#123;</span><br><span class=\"line\">    fill_txt += ($(e).data(<span class=\"string\">\"num\"</span>) + <span class=\"string\">'号桌'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ctx.fillText(fill_txt,<span class=\"number\">131</span>,<span class=\"number\">300</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">//读取生成标签中的data属性，生成下载a标签</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> $a = $(<span class=\"string\">\"&lt;a&gt;&lt;/a&gt;\"</span>).attr(<span class=\"string\">\"href\"</span>, c.toDataURL()).attr(<span class=\"string\">\"download\"</span>, $(e).data(<span class=\"string\">\"area_name\"</span>)+$(e).data(<span class=\"string\">\"num\"</span>)+<span class=\"string\">\".png\"</span>);</span><br><span class=\"line\">  $a[<span class=\"number\">0</span>].click();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//下载带背景图的二维码</span></span><br><span class=\"line\">exports.download_qrcode_png = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> new_elem = $(<span class=\"string\">\"&lt;div&gt;&lt;/div&gt;\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> qrcode = <span class=\"keyword\">new</span> QRCode(new_elem,&#123;</span><br><span class=\"line\">    width : <span class=\"number\">262</span>,<span class=\"comment\">//设置宽高</span></span><br><span class=\"line\">    height : <span class=\"number\">262</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  qrcode.makeCode($(e).data(<span class=\"string\">'qrcode'</span>));</span><br><span class=\"line\">  <span class=\"keyword\">var</span> c=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>),ctx=c.getContext(<span class=\"string\">'2d'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> qr_ele = qrcode;</span><br><span class=\"line\">  c.width=<span class=\"number\">460</span>;</span><br><span class=\"line\">  c.height=<span class=\"number\">620</span>;</span><br><span class=\"line\">  ctx.rect(<span class=\"number\">0</span>,<span class=\"number\">0</span>,c.width,c.height);</span><br><span class=\"line\">  ctx.fill();</span><br><span class=\"line\">  <span class=\"comment\">//读取背景图</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> bg_img = $(<span class=\"string\">\"#background_image\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image;</span><br><span class=\"line\">  img.crossOrigin = <span class=\"string\">'Anonymous'</span>; <span class=\"comment\">//解决跨域</span></span><br><span class=\"line\">  img.src = qrcode._el.children[<span class=\"number\">0</span>].toDataURL();</span><br><span class=\"line\">  <span class=\"comment\">//画到canvas中</span></span><br><span class=\"line\">  ctx.drawImage(bg_img,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">460</span>,<span class=\"number\">620</span>);</span><br><span class=\"line\">  ctx.drawImage(img,<span class=\"number\">98</span>,<span class=\"number\">162</span>,<span class=\"number\">262</span>,<span class=\"number\">262</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  ctx.fillStyle=<span class=\"string\">'#fe9b20'</span>;</span><br><span class=\"line\">  ctx.font = <span class=\"string\">\"bold 32px 黑体\"</span>;</span><br><span class=\"line\">  ctx.textAlign = <span class=\"string\">\"center\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fill_txt = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>($(e).data(<span class=\"string\">\"area_name\"</span>) !=<span class=\"string\">\"\"</span>)&#123;</span><br><span class=\"line\">    fill_txt = $(e).data(<span class=\"string\">\"area_name\"</span>)+<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>($(e).data(<span class=\"string\">\"num\"</span>) != <span class=\"string\">\"\"</span>)&#123;</span><br><span class=\"line\">    fill_txt += ($(e).data(<span class=\"string\">\"num\"</span>) + <span class=\"string\">'号桌'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ctx.fillText(fill_txt,<span class=\"number\">230</span>,<span class=\"number\">465</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//document.body.appendChild(c);</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> $a = $(<span class=\"string\">\"&lt;a&gt;&lt;/a&gt;\"</span>).attr(<span class=\"string\">\"href\"</span>, c.toDataURL()).attr(<span class=\"string\">\"download\"</span>, $(e).data(<span class=\"string\">\"area_name\"</span>)+$(e).data(<span class=\"string\">\"num\"</span>)+<span class=\"string\">\".png\"</span>);</span><br><span class=\"line\">  $a[<span class=\"number\">0</span>].click();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"使用七牛SDK上传图片\"><a href=\"#使用七牛SDK上传图片\" class=\"headerlink\" title=\"使用七牛SDK上传图片\"></a>使用七牛SDK上传图片</h3><p>七牛的开发文档地址<a href=\"http://developer.qiniu.com/code/v6/sdk/javascript.html#upload\">这里。</a></p>\n<p>按照七牛文档和demo就可以很快实现一个上传图片的功能。我来说一下上传的大概过程和我遇到的一个问题。</p>\n<p>首先服务端的会先做一些<a href=\"http://developer.qiniu.com/code/v7/sdk/python.html#io-put\">工作</a>，这个我们不太需要关心只要知道我们在上传图片之前，需要先向服务端去发起一次请求去拿到token和key，因为可以看到七牛上传图片时是需要这两个参数的。然后开始上传图片，上传图片后还有一个成功回调事件，在回调事件中可以做一些事情。（告知服务端图片上传成功了，并把这张图片的url告诉服务端，这样才能把图片对应起来）</p>\n<p>这里这再插一句，七牛的SDK使用的plupload插件是这样的：他在初始化的时候需要的参数有token，按钮的<code>id</code>，还有一个可选的参数key（这个参数是可以把文件的url替换成你自定义的）。然后会在方法执行时会去寻找你这个id的button，去初始化它，在这个标签下面再去创建一个input标签，在你点击这个id的button的时候他会去隐式的点击下面的input来唤起浏览器选择文件。</p>\n<p>好，大概的过程就是这样的。没有什么问题，但是不管文档和demo都只说了只有一个按钮的情况。如果我有一个列表，上面有很多上传按钮这种情况该怎么办？文档上有类似问题：<a href=\"http://developer.qiniu.com/code/v6/sdk/javascript.html#faq\">地址</a>。但是他这里说的情况是固定的几个按钮，并且知道他的token和key，还有按钮标签的<code>id</code>。</p>\n<p>这种是不符合我目前需求的，因为我目前整个列表有几个上传按钮都是不确定的，按钮的<code>id</code>等等也是不固定的，我要等请求后端接口拿到token和key之后，再去初始化按钮，并且每个按钮和列表每一行的商品要一一对应。所以在完成这个初始化多个上传按钮时碰到了问题。</p>\n<p>我们分析一下：如果需要一一对应那么我必须使每一行的button都有自己单独的id、token、和key（因为需要自定义上传图片的url）。</p>\n<p>最开始我是这么写的：（大概过程可以看注释）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//请求商品列表</span></span><br><span class=\"line\">ajax(&#123;</span><br><span class=\"line\">  url: <span class=\"string\">'http://172.100.101.106:9099/goods/list'</span>,</span><br><span class=\"line\">  method: <span class=\"string\">'GET'</span>,</span><br><span class=\"line\">  data: data,</span><br><span class=\"line\">  callback: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//把初始化队列置空</span></span><br><span class=\"line\">    _this.$set(<span class=\"string\">'initList'</span>, [])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.respcd === <span class=\"string\">'0000'</span>) &#123;</span><br><span class=\"line\">      _this.$set(<span class=\"string\">'goodsList'</span>, res.data.list)</span><br><span class=\"line\">      <span class=\"comment\">//遍历商品列表的每一项，创建一个新的对象包含初始化时需要的id，然后用unionid关联商品列表和新建的初始化列表</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = res.data.list.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res.data.list[i].img === <span class=\"string\">''</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> a = &#123;</span><br><span class=\"line\">            id: <span class=\"string\">'img-id-'</span> + res.data.list[i].id,</span><br><span class=\"line\">            unionid: res.data.list[i].unionid</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">//把对象push进初始化列表</span></span><br><span class=\"line\">          _this.initList.push(a)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//这个是vue监听dom渲染完成的事件（可忽略）</span></span><br><span class=\"line\">    _this.$nextTick(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化列表的每一项进行初始化按钮的操作</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = _this.initList.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        _this.initUpload(_this.initList[i].unionid, _this.initList[i].id)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方法接受两个参数 </span></span><br><span class=\"line\"><span class=\"comment\">//unionid 这个参数是最后上传完成后给服务端发请求告知 是哪个商品的图片，让服务端把商品和图片对应起来；</span></span><br><span class=\"line\"><span class=\"comment\">//id 就是初始化按钮是需要的id；</span></span><br><span class=\"line\">initUpload (unionid, id) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"comment\">//这个是获取token和key的接口，上面过程说明了一下</span></span><br><span class=\"line\">        $.ajax(&#123;</span><br><span class=\"line\">          url: <span class=\"string\">'https://xxxxxxxxx/qiniu_token'</span>,</span><br><span class=\"line\">          type: <span class=\"string\">'get'</span>,</span><br><span class=\"line\">          dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">          data: &#123;</span><br><span class=\"line\">            <span class=\"string\">'appcode'</span>:\t<span class=\"string\">'xxxxxx'</span>,</span><br><span class=\"line\">            <span class=\"string\">'func'</span>:\t<span class=\"string\">'upload'</span>,</span><br><span class=\"line\">            <span class=\"string\">'format'</span>:\t<span class=\"string\">'cors'</span></span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          <span class=\"keyword\">async</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">          timeout: <span class=\"number\">3000</span>,</span><br><span class=\"line\">          success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data[<span class=\"string\">'respcd'</span>] === <span class=\"string\">'0000'</span>) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">let</span> uptoken = data.data.token</span><br><span class=\"line\">              ******************</span><br><span class=\"line\">              <span class=\"keyword\">let</span> key = data.data.key</span><br><span class=\"line\">              ******************</span><br><span class=\"line\">              <span class=\"keyword\">var</span> uploader = Qiniu.uploader(&#123;</span><br><span class=\"line\">                runtimes: <span class=\"string\">'html5,flash,html4'</span>,    <span class=\"comment\">//上传模式,依次退化</span></span><br><span class=\"line\">                browse_button: id,       <span class=\"comment\">//上传选择的点选按钮，**必需**</span></span><br><span class=\"line\">                uptoken: uptoken,</span><br><span class=\"line\">                domain: <span class=\"string\">'https://xxxxxxxxx.com/'</span>,   <span class=\"comment\">//bucket 域名，下载资源时用到，**必需**</span></span><br><span class=\"line\">                get_new_uptoken: <span class=\"literal\">true</span>,  <span class=\"comment\">//设置上传文件的时候是否每次都重新获取新的token</span></span><br><span class=\"line\">                max_file_size: <span class=\"string\">'10mb'</span>,           <span class=\"comment\">//最大文件体积限制</span></span><br><span class=\"line\">                flash_swf_url: <span class=\"string\">'./flash/Moxie.swf'</span>,  <span class=\"comment\">//引入flash,相对路径</span></span><br><span class=\"line\">                max_retries: <span class=\"number\">3</span>,                   <span class=\"comment\">//上传失败最大重试次数</span></span><br><span class=\"line\">                dragdrop: <span class=\"literal\">true</span>,                   <span class=\"comment\">//开启可拖曳上传</span></span><br><span class=\"line\">                drop_element: id,        <span class=\"comment\">//拖曳上传区域元素的ID，拖曳文件或文件夹后可触发上传</span></span><br><span class=\"line\">                chunk_size: <span class=\"string\">'4mb'</span>,                <span class=\"comment\">//分块上传时，每片的体积</span></span><br><span class=\"line\">                auto_start: <span class=\"literal\">true</span>,                 <span class=\"comment\">//选择文件后自动上传，若关闭需要自己绑定事件触发上传</span></span><br><span class=\"line\">                init: &#123;</span><br><span class=\"line\">                  <span class=\"string\">'FilesAdded'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, files</span>) </span>&#123;</span><br><span class=\"line\">                    plupload.each(files, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">file</span>) </span>&#123;</span><br><span class=\"line\">                      <span class=\"comment\">// 文件添加进队列后,处理相关的事情</span></span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">'BeforeUpload'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 每个文件上传前,处理相关的事情</span></span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">'UploadProgress'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//                    $('#img_upload-' + rand_num).addClass('spinner')</span></span><br><span class=\"line\">                    <span class=\"comment\">// 每个文件上传时,处理相关的事情</span></span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">'FileUploaded'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, file, info</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> domain = up.getOption(<span class=\"string\">'domain'</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> res = <span class=\"built_in\">JSON</span>.parse(info)</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> sourceLink = domain + res.key <span class=\"comment\">//获取上传成功后的文件的Url</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    $.ajax(&#123;</span><br><span class=\"line\">                      url: <span class=\"string\">'http://172.100.101.106:9099/goods/setimg'</span>,</span><br><span class=\"line\">                      type: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">                      dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">                      data: &#123;</span><br><span class=\"line\">                        <span class=\"string\">'unionid'</span>: unionid,</span><br><span class=\"line\">                        <span class=\"string\">'img'</span>: sourceLink</span><br><span class=\"line\">                      &#125;,</span><br><span class=\"line\">                      success: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (data[<span class=\"string\">'respcd'</span>] === <span class=\"string\">'0000'</span>) &#123;</span><br><span class=\"line\">                          <span class=\"built_in\">window</span>.Materialize.toast(<span class=\"string\">'添加商品图片成功'</span>, <span class=\"number\">4000</span>)</span><br><span class=\"line\">                          _this.getUserInfo(_this.currentPage, _this.pageSize)</span><br><span class=\"line\">                          &#125;</span><br><span class=\"line\">                      &#125;,</span><br><span class=\"line\">                      error: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">                        <span class=\"built_in\">window</span>.Materialize.toast(data.respmsg, <span class=\"number\">4000</span>)</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">'Error'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, err, errTip</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//上传出错时,处理相关的事情</span></span><br><span class=\"line\">                    <span class=\"built_in\">window</span>.Materialize.toast(errTip, <span class=\"number\">4000</span>)</span><br><span class=\"line\">                    $(<span class=\"string\">'#img_upload'</span>).removeClass(<span class=\"string\">'spinner'</span>)</span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">'UploadComplete'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//队列文件处理完毕后,处理相关的事情</span></span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">'Key'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\">                  \t*************</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> key</span><br><span class=\"line\">                    *************</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              &#125;)</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<p>请注意我标<strong><em>**</em></strong>的那几行，我本意是把每一个ajax请求到的key，赋到每一个初始化按钮的方法中去，但是如果我们实际这么去写的话，token是对的，但是key总是最后一个请求的key，原因就是初始化中<code>&#39;Key&#39;</code>这个方法，并不是在方法初始化的时候就去执行了，而是你再点击这个按钮的时候再去获取这个key的值，所以当你点击按钮时这个key的值就是最后一次请求到key的值了。（只有一个key会造成上传了多张图片，但是你只会有一个url的情况发生）</p>\n<p>那如何去在一个页面用七牛的SDK去初始化N个上传按钮呢？</p>\n<p>我当时试了闭包这种方法，大概是这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> uploader = Qiniu.uploader(&#123;&#125;）</span><br><span class=\"line\">&#125;)(key)</span><br></pre></td></tr></table></figure>\n<p>但是并不可以。</p>\n<p>找到了一种变通式的解决方法，就是在你每次点击按钮时，去渲染一个新的DOM，再用这个新的DOM去执行初始化的方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rand_num = <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.random()*<span class=\"number\">100000000</span>)</span><br><span class=\"line\">$(<span class=\"string\">\"#upload_block\"</span>).html(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> html =<span class=\"string\">'&lt;div id=\"img-container-'</span>+rand_num+<span class=\"string\">'\" class=\"dz-default dz-message\"&gt;&lt;button id=\"img_upload-'</span>+rand_num+<span class=\"string\">'\" class=\"btn btn-default btn-lg\"&gt;&lt;i class=\"glyphicon glyphicon-plus\"&gt;&lt;/i&gt;&lt;span&gt;上传图片&lt;/span&gt;&lt;/button&gt;&lt;/div&gt;'</span>;</span><br><span class=\"line\">$(<span class=\"string\">\"#upload_block\"</span>).html(html);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//然后把这个DOM进行初始化</span></span><br></pre></td></tr></table></figure>\n<p>这样同步的来进行，一次只有一个token和key，初始化一个按钮，这样就不会存在上面的问题，但是这样就意味着你点击上传按钮之后，又会出来一个蒙层点击蒙层上的按钮才可以选择图片，这样体验未免有些太差了。</p>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><p>最后经过一下午的尝试，最后也是受到了demo的启发：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'FileUploaded'</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">up, file, info</span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">// 每个文件上传成功后，处理相关的事情</span></span><br><span class=\"line\">       <span class=\"comment\">// 其中info是文件上传成功后，服务端返回的json，形式如：</span></span><br><span class=\"line\">       <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">       <span class=\"comment\">//    \"hash\": \"Fh8xVqod2MQ1mocfI4S4KpRL6D98\",</span></span><br><span class=\"line\">       <span class=\"comment\">//    \"key\": \"gogopher.jpg\"</span></span><br><span class=\"line\">       <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\">       <span class=\"comment\">// 查看简单反馈</span></span><br><span class=\"line\">       <span class=\"comment\">// var domain = up.getOption('domain');</span></span><br><span class=\"line\">       <span class=\"comment\">// var res = parseJSON(info);</span></span><br><span class=\"line\">       <span class=\"comment\">// var sourceLink = domain + res.key; 获取上传成功后的文件的Url</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>七牛给的上传说明中有这么一段，方法的第一个参数是up，通过注释我们可以看出这个参数可以获取到<code>Qiniu.uploader</code>这个方法的一些配置参数的值，比如这一行<code>var domain = up.getOption(&#39;domain&#39;);</code>他就获取到了domain这个配置的值（<code>即https://xxxxxxxxx.com/</code>），可以看到<code>&#39;Key&#39;</code>这个方法也会接受<code>up</code>这个参数，所以可不可以在配置中多加一个keyValue的多余配置，来储存key值呢？</p>\n<p>经过试验答案是可以的！大概这样：（相同代码就不再重复）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> uploader = Qiniu.uploader(&#123;</span><br><span class=\"line\">    keyValue: key,</span><br><span class=\"line\">    </span><br><span class=\"line\">    .....</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    init: &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    .....</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"string\">'Key'</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">up, file</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> key = up.getOption(<span class=\"string\">'keyValue'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其他地方不变，这样经过试验可以很好地解决初始化多个按钮的问题！</p>\n"},{"layout":"post","title":"时间是个贼啊","date":"2016-12-01T16:00:00.000Z","_content":"\n无事 今天看了岁月神偷\n电影缓缓的把那份感动讲述了出来\n看到了生死之外其实所有的事情都会过去\n人生本来就是这样一脚佳一脚难\n走呀走呀\n就走了到苦海的那边去\n\n可能是因为我还没当父母\n没有活在当时的那个环境下\n感受不到真的生活艰难\n感受不到为人父母的那份不易\n父母辛辛苦苦一辈子不就是为了我们生活的更好嘛  \n\n当时看到进二和奶奶那段\n我特别想哭\n我想起了我的奶奶\n她的样子我早就模糊了\n奶奶走的早\n能记得的事情就是小的时候奶奶总是在冬天给我冻糖水的冰坨\n冻好之后用勺子让我一点一点来刮着吃\n在夏天不能冻的时候\n奶奶就会去买小布丁\n我一根奶奶一根我俩就坐在院子葡萄架下的阴凉里\n一口一口的吃着雪糕\n好不惬意\n怀念那时无忧无虑的日子\n也想念奶奶\n影片里说逝去的人都会到苦海的另一边\n想要见到逝去的亲人的办法\n就是把自己所有珍贵的东西扔到苦海中\n把苦海填满\n这样就可以到苦海那边去了\n如果真的可以去苦海那边再见到奶奶\n我愿意把我所有重要的宝贵的东西全部扔掉\n去苦海的那面去看望奶奶\n\n让我第一次对死亡有了印象的就是大舅走的时候\n那会应该是07、08年的时候\n我初三\n那年家里的气氛就很不对劲\n因为大舅得了癌症住院了\n原来去姥姥家过年\n男的 女的各能凑成一桌麻将\n而我们弟兄三个总会去家附近的游戏厅去玩游戏 去广场放炮\n可那之后\n麻将只能凑齐一桌了\n再也没有那么热闹了\n我还清楚的记得大舅临走的时候\n大舅病重以后很久没有那么清楚的说过话了\n应该是回光返照吧\n他吩咐我哥好好学习\n那四个字清楚的印在我的记忆里\n大舅一直认为只有好好学习才会有出息\n那是我第一次体会到时间是一个无情的小偷\n他会偷走你的亲人  偷走你所在乎的东西\n\n故事还讲了关于爱情\n是啊在懵懂的时候\n那种感情是很值得怀念的\n故事讲的是一个悲剧\n一个熊穷小子喜欢上了一个富家小姐\n因为自卑他选择了放弃\n可是女生的的主动让他知道了他们是互相喜欢的\n知道了但是也无能为力了\n记得我初中的时候  也喜欢过一个女孩子\n女孩子呢大概也喜欢我吧\n上课传纸条\n有时候说上一句话就高兴半天\n我还清楚的记得那时冬天去数学老师家补课\n我俩坐在一起\n她突然就抓住了我的手\n就那样我俩紧紧的抓了一节课\n补完课又一起拉手回的家\n记得在期末考试完返校领成绩单的时候\n她说她要转学走了\n我真的特别舍不得她\n那时候班里就我们两个人了\n可是我什么都不敢去做只能笑着和她说到那面一切都要好好的\n就像影片里面进一和女孩说我一定会拿第一一样\n现在想起来我应该给她一个大大的拥抱才对\n那会没有手机书信来往过一次\n座机联系过  后来慢慢就没有了\n有了微信互相加了\n但是谁都不会说话\n各自都有了各自的生活圈子\n那\n应该算我们  至少是我自己的一段美好回忆吧\n\n亲情爱情影片里都讲了\n但是没有讲友情\n其实时间也偷走了我们的朋友\n记得幼儿园的时候和我最好的朋友叫郭昌\n他坐我旁边  整个幼儿园我和他都最好\n可是分开了之后慢慢也就淡了\n小学一二年级的时候  和我最好的叫丁强\n后来他转学了再也没有联系了\n我曾经的还有很多好朋友辛茂林 付强  徐凯超 潘宇鹏 等等\n他们在某一段时间里都和我有很重要的联系\n但是因为某一件事可能是小到我现在都忘了是什么的事情\n可能是因为时间  因为距离 慢慢的时间把他们从我的身边都偷走了\n朋友大概就是这样  之间需要互动\n像http三次握手一样\n我请求你需要有回应\n如果没有这次连接就算中断了\n如果总是中断没有回应\n我认为这个访问的地址就是无效得了  我可能不会再去主动访问了   \n\n时间还会偷走很多很多\n唯有把握当下\n抓住一分一秒用力的活\n才能从小偷那里夺回来一些\n\n夺回来！","source":"_posts/2016-12-02-时间是个贼啊.md","raw":"---\nlayout: post\ntitle: 时间是个贼啊\ndate: 2016-12-02 \ntags: ['杂事二三']\ncategories: 杂事二三\n---\n\n无事 今天看了岁月神偷\n电影缓缓的把那份感动讲述了出来\n看到了生死之外其实所有的事情都会过去\n人生本来就是这样一脚佳一脚难\n走呀走呀\n就走了到苦海的那边去\n\n可能是因为我还没当父母\n没有活在当时的那个环境下\n感受不到真的生活艰难\n感受不到为人父母的那份不易\n父母辛辛苦苦一辈子不就是为了我们生活的更好嘛  \n\n当时看到进二和奶奶那段\n我特别想哭\n我想起了我的奶奶\n她的样子我早就模糊了\n奶奶走的早\n能记得的事情就是小的时候奶奶总是在冬天给我冻糖水的冰坨\n冻好之后用勺子让我一点一点来刮着吃\n在夏天不能冻的时候\n奶奶就会去买小布丁\n我一根奶奶一根我俩就坐在院子葡萄架下的阴凉里\n一口一口的吃着雪糕\n好不惬意\n怀念那时无忧无虑的日子\n也想念奶奶\n影片里说逝去的人都会到苦海的另一边\n想要见到逝去的亲人的办法\n就是把自己所有珍贵的东西扔到苦海中\n把苦海填满\n这样就可以到苦海那边去了\n如果真的可以去苦海那边再见到奶奶\n我愿意把我所有重要的宝贵的东西全部扔掉\n去苦海的那面去看望奶奶\n\n让我第一次对死亡有了印象的就是大舅走的时候\n那会应该是07、08年的时候\n我初三\n那年家里的气氛就很不对劲\n因为大舅得了癌症住院了\n原来去姥姥家过年\n男的 女的各能凑成一桌麻将\n而我们弟兄三个总会去家附近的游戏厅去玩游戏 去广场放炮\n可那之后\n麻将只能凑齐一桌了\n再也没有那么热闹了\n我还清楚的记得大舅临走的时候\n大舅病重以后很久没有那么清楚的说过话了\n应该是回光返照吧\n他吩咐我哥好好学习\n那四个字清楚的印在我的记忆里\n大舅一直认为只有好好学习才会有出息\n那是我第一次体会到时间是一个无情的小偷\n他会偷走你的亲人  偷走你所在乎的东西\n\n故事还讲了关于爱情\n是啊在懵懂的时候\n那种感情是很值得怀念的\n故事讲的是一个悲剧\n一个熊穷小子喜欢上了一个富家小姐\n因为自卑他选择了放弃\n可是女生的的主动让他知道了他们是互相喜欢的\n知道了但是也无能为力了\n记得我初中的时候  也喜欢过一个女孩子\n女孩子呢大概也喜欢我吧\n上课传纸条\n有时候说上一句话就高兴半天\n我还清楚的记得那时冬天去数学老师家补课\n我俩坐在一起\n她突然就抓住了我的手\n就那样我俩紧紧的抓了一节课\n补完课又一起拉手回的家\n记得在期末考试完返校领成绩单的时候\n她说她要转学走了\n我真的特别舍不得她\n那时候班里就我们两个人了\n可是我什么都不敢去做只能笑着和她说到那面一切都要好好的\n就像影片里面进一和女孩说我一定会拿第一一样\n现在想起来我应该给她一个大大的拥抱才对\n那会没有手机书信来往过一次\n座机联系过  后来慢慢就没有了\n有了微信互相加了\n但是谁都不会说话\n各自都有了各自的生活圈子\n那\n应该算我们  至少是我自己的一段美好回忆吧\n\n亲情爱情影片里都讲了\n但是没有讲友情\n其实时间也偷走了我们的朋友\n记得幼儿园的时候和我最好的朋友叫郭昌\n他坐我旁边  整个幼儿园我和他都最好\n可是分开了之后慢慢也就淡了\n小学一二年级的时候  和我最好的叫丁强\n后来他转学了再也没有联系了\n我曾经的还有很多好朋友辛茂林 付强  徐凯超 潘宇鹏 等等\n他们在某一段时间里都和我有很重要的联系\n但是因为某一件事可能是小到我现在都忘了是什么的事情\n可能是因为时间  因为距离 慢慢的时间把他们从我的身边都偷走了\n朋友大概就是这样  之间需要互动\n像http三次握手一样\n我请求你需要有回应\n如果没有这次连接就算中断了\n如果总是中断没有回应\n我认为这个访问的地址就是无效得了  我可能不会再去主动访问了   \n\n时间还会偷走很多很多\n唯有把握当下\n抓住一分一秒用力的活\n才能从小偷那里夺回来一些\n\n夺回来！","slug":"时间是个贼啊","published":1,"updated":"2017-01-03T03:29:55.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg2080032sq5lrk99kh39","content":"<p>无事 今天看了岁月神偷<br>电影缓缓的把那份感动讲述了出来<br>看到了生死之外其实所有的事情都会过去<br>人生本来就是这样一脚佳一脚难<br>走呀走呀<br>就走了到苦海的那边去</p>\n<p>可能是因为我还没当父母<br>没有活在当时的那个环境下<br>感受不到真的生活艰难<br>感受不到为人父母的那份不易<br>父母辛辛苦苦一辈子不就是为了我们生活的更好嘛  </p>\n<p>当时看到进二和奶奶那段<br>我特别想哭<br>我想起了我的奶奶<br>她的样子我早就模糊了<br>奶奶走的早<br>能记得的事情就是小的时候奶奶总是在冬天给我冻糖水的冰坨<br>冻好之后用勺子让我一点一点来刮着吃<br>在夏天不能冻的时候<br>奶奶就会去买小布丁<br>我一根奶奶一根我俩就坐在院子葡萄架下的阴凉里<br>一口一口的吃着雪糕<br>好不惬意<br>怀念那时无忧无虑的日子<br>也想念奶奶<br>影片里说逝去的人都会到苦海的另一边<br>想要见到逝去的亲人的办法<br>就是把自己所有珍贵的东西扔到苦海中<br>把苦海填满<br>这样就可以到苦海那边去了<br>如果真的可以去苦海那边再见到奶奶<br>我愿意把我所有重要的宝贵的东西全部扔掉<br>去苦海的那面去看望奶奶</p>\n<p>让我第一次对死亡有了印象的就是大舅走的时候<br>那会应该是07、08年的时候<br>我初三<br>那年家里的气氛就很不对劲<br>因为大舅得了癌症住院了<br>原来去姥姥家过年<br>男的 女的各能凑成一桌麻将<br>而我们弟兄三个总会去家附近的游戏厅去玩游戏 去广场放炮<br>可那之后<br>麻将只能凑齐一桌了<br>再也没有那么热闹了<br>我还清楚的记得大舅临走的时候<br>大舅病重以后很久没有那么清楚的说过话了<br>应该是回光返照吧<br>他吩咐我哥好好学习<br>那四个字清楚的印在我的记忆里<br>大舅一直认为只有好好学习才会有出息<br>那是我第一次体会到时间是一个无情的小偷<br>他会偷走你的亲人  偷走你所在乎的东西</p>\n<p>故事还讲了关于爱情<br>是啊在懵懂的时候<br>那种感情是很值得怀念的<br>故事讲的是一个悲剧<br>一个熊穷小子喜欢上了一个富家小姐<br>因为自卑他选择了放弃<br>可是女生的的主动让他知道了他们是互相喜欢的<br>知道了但是也无能为力了<br>记得我初中的时候  也喜欢过一个女孩子<br>女孩子呢大概也喜欢我吧<br>上课传纸条<br>有时候说上一句话就高兴半天<br>我还清楚的记得那时冬天去数学老师家补课<br>我俩坐在一起<br>她突然就抓住了我的手<br>就那样我俩紧紧的抓了一节课<br>补完课又一起拉手回的家<br>记得在期末考试完返校领成绩单的时候<br>她说她要转学走了<br>我真的特别舍不得她<br>那时候班里就我们两个人了<br>可是我什么都不敢去做只能笑着和她说到那面一切都要好好的<br>就像影片里面进一和女孩说我一定会拿第一一样<br>现在想起来我应该给她一个大大的拥抱才对<br>那会没有手机书信来往过一次<br>座机联系过  后来慢慢就没有了<br>有了微信互相加了<br>但是谁都不会说话<br>各自都有了各自的生活圈子<br>那<br>应该算我们  至少是我自己的一段美好回忆吧</p>\n<p>亲情爱情影片里都讲了<br>但是没有讲友情<br>其实时间也偷走了我们的朋友<br>记得幼儿园的时候和我最好的朋友叫郭昌<br>他坐我旁边  整个幼儿园我和他都最好<br>可是分开了之后慢慢也就淡了<br>小学一二年级的时候  和我最好的叫丁强<br>后来他转学了再也没有联系了<br>我曾经的还有很多好朋友辛茂林 付强  徐凯超 潘宇鹏 等等<br>他们在某一段时间里都和我有很重要的联系<br>但是因为某一件事可能是小到我现在都忘了是什么的事情<br>可能是因为时间  因为距离 慢慢的时间把他们从我的身边都偷走了<br>朋友大概就是这样  之间需要互动<br>像http三次握手一样<br>我请求你需要有回应<br>如果没有这次连接就算中断了<br>如果总是中断没有回应<br>我认为这个访问的地址就是无效得了  我可能不会再去主动访问了   </p>\n<p>时间还会偷走很多很多<br>唯有把握当下<br>抓住一分一秒用力的活<br>才能从小偷那里夺回来一些</p>\n<p>夺回来！</p>\n","excerpt":"","more":"<p>无事 今天看了岁月神偷<br>电影缓缓的把那份感动讲述了出来<br>看到了生死之外其实所有的事情都会过去<br>人生本来就是这样一脚佳一脚难<br>走呀走呀<br>就走了到苦海的那边去</p>\n<p>可能是因为我还没当父母<br>没有活在当时的那个环境下<br>感受不到真的生活艰难<br>感受不到为人父母的那份不易<br>父母辛辛苦苦一辈子不就是为了我们生活的更好嘛  </p>\n<p>当时看到进二和奶奶那段<br>我特别想哭<br>我想起了我的奶奶<br>她的样子我早就模糊了<br>奶奶走的早<br>能记得的事情就是小的时候奶奶总是在冬天给我冻糖水的冰坨<br>冻好之后用勺子让我一点一点来刮着吃<br>在夏天不能冻的时候<br>奶奶就会去买小布丁<br>我一根奶奶一根我俩就坐在院子葡萄架下的阴凉里<br>一口一口的吃着雪糕<br>好不惬意<br>怀念那时无忧无虑的日子<br>也想念奶奶<br>影片里说逝去的人都会到苦海的另一边<br>想要见到逝去的亲人的办法<br>就是把自己所有珍贵的东西扔到苦海中<br>把苦海填满<br>这样就可以到苦海那边去了<br>如果真的可以去苦海那边再见到奶奶<br>我愿意把我所有重要的宝贵的东西全部扔掉<br>去苦海的那面去看望奶奶</p>\n<p>让我第一次对死亡有了印象的就是大舅走的时候<br>那会应该是07、08年的时候<br>我初三<br>那年家里的气氛就很不对劲<br>因为大舅得了癌症住院了<br>原来去姥姥家过年<br>男的 女的各能凑成一桌麻将<br>而我们弟兄三个总会去家附近的游戏厅去玩游戏 去广场放炮<br>可那之后<br>麻将只能凑齐一桌了<br>再也没有那么热闹了<br>我还清楚的记得大舅临走的时候<br>大舅病重以后很久没有那么清楚的说过话了<br>应该是回光返照吧<br>他吩咐我哥好好学习<br>那四个字清楚的印在我的记忆里<br>大舅一直认为只有好好学习才会有出息<br>那是我第一次体会到时间是一个无情的小偷<br>他会偷走你的亲人  偷走你所在乎的东西</p>\n<p>故事还讲了关于爱情<br>是啊在懵懂的时候<br>那种感情是很值得怀念的<br>故事讲的是一个悲剧<br>一个熊穷小子喜欢上了一个富家小姐<br>因为自卑他选择了放弃<br>可是女生的的主动让他知道了他们是互相喜欢的<br>知道了但是也无能为力了<br>记得我初中的时候  也喜欢过一个女孩子<br>女孩子呢大概也喜欢我吧<br>上课传纸条<br>有时候说上一句话就高兴半天<br>我还清楚的记得那时冬天去数学老师家补课<br>我俩坐在一起<br>她突然就抓住了我的手<br>就那样我俩紧紧的抓了一节课<br>补完课又一起拉手回的家<br>记得在期末考试完返校领成绩单的时候<br>她说她要转学走了<br>我真的特别舍不得她<br>那时候班里就我们两个人了<br>可是我什么都不敢去做只能笑着和她说到那面一切都要好好的<br>就像影片里面进一和女孩说我一定会拿第一一样<br>现在想起来我应该给她一个大大的拥抱才对<br>那会没有手机书信来往过一次<br>座机联系过  后来慢慢就没有了<br>有了微信互相加了<br>但是谁都不会说话<br>各自都有了各自的生活圈子<br>那<br>应该算我们  至少是我自己的一段美好回忆吧</p>\n<p>亲情爱情影片里都讲了<br>但是没有讲友情<br>其实时间也偷走了我们的朋友<br>记得幼儿园的时候和我最好的朋友叫郭昌<br>他坐我旁边  整个幼儿园我和他都最好<br>可是分开了之后慢慢也就淡了<br>小学一二年级的时候  和我最好的叫丁强<br>后来他转学了再也没有联系了<br>我曾经的还有很多好朋友辛茂林 付强  徐凯超 潘宇鹏 等等<br>他们在某一段时间里都和我有很重要的联系<br>但是因为某一件事可能是小到我现在都忘了是什么的事情<br>可能是因为时间  因为距离 慢慢的时间把他们从我的身边都偷走了<br>朋友大概就是这样  之间需要互动<br>像http三次握手一样<br>我请求你需要有回应<br>如果没有这次连接就算中断了<br>如果总是中断没有回应<br>我认为这个访问的地址就是无效得了  我可能不会再去主动访问了   </p>\n<p>时间还会偷走很多很多<br>唯有把握当下<br>抓住一分一秒用力的活<br>才能从小偷那里夺回来一些</p>\n<p>夺回来！</p>\n"},{"layout":"post","title":"写在2016年末","date":"2016-12-31T16:00:00.000Z","_content":"\n回想起2016年是不是什么都记不起来了 对啊一年又匆忙的过去了 这一年和往年并没有任何不一样 还是一样谨慎 一样平凡 不管是在哪方面 都是那么普通 我一直都和别人说 我的一生就是谨慎的一生  人生一直都在既定的轨道上前行 没有任何出格的事情  学习 工作 生活  \n\n昨天和朋友讨论 到底什么算是出格的事情呢？  当时想了很久 也没有想到一个满意的答案  今天在想起来 到底什么才算是出格的事情呢  我想就是你为了不想在既定的轨道上前行 所做的努力 这算不算应该叫做出格的事情   我想了很久 觉得这个答案在我心里是认可的  \n\n前几天看过一个谈话类的节目  里面说  现在社会中仿佛每个人的选择有很多种 但其实在每个人的选择是很少的 确实啊  我总会想 我想当一个木匠  当一个画家  但是如果你放弃了现在的工作 你用什么来立命呢？ 所以藏在心里的梦想 敢去追逐  打破既定那就是出格了 \n\n我呢 只能是藏在这个面具下面 谨慎的前行了吧 现在在回北京的火车上写下了自己想到的一些  说矫情也确实挺矫情的  早晨出门的时候天还没亮 说是回家回家  但是真的在家陪伴家人的时间却又是多少?  大部分时间都是和朋友一起玩  说起来也挺惭愧的  拿这个当借口元旦放假回来了 \n\n往常我如果只放三天的假 我是不会回家的 因为在路上就花去了大部分时间  我回去是有私心的 我以为可以感动别人 其实只是感动了自己而已  仅此而已 现在看起来也只能是无奈的笑笑了  我原来说过一句话：人生无非两种情况 当初为什么那么傻逼 当初为什么不那么傻逼  对 我就是回来践行当初为什么不那么傻逼  \n\n起码一些东西明白了 心里就能不时常去牵挂了 朋友说我是活在自己世界里的一个人 固执倔强 有自己的想法 但是不自信 太敏感 有些事其实不用去想那么多 都没什么的  我想了一下还真是挺符合我的 我是太容易想多了 把一些捕风捉影的事情看得太重了  这也就给自己造了一个笼子  熟悉了 都不敢在天空了中飞翔了  \n\n总是很羡慕电影里的男主角  总是很有勇气的和女主角表白  没有那么多顾虑 很羡慕这种坦然  不知道自己什么时候也可以变成这样的坦然的人\n\n说了这么多 但标题是总结2016 那我还是应该努力回想起今年到底做了什么事 是可以让我小小总结一下的\n第一个应该是工作吧  在这一年里工作中 慢慢从一个新手变成了一个熟手 大部分工作都可以自己独立完成了 从一开始的一个菜鸟 慢慢成长了起来 说起现在的工作 说不上有多喜欢 但是并不反感  很享受那种独立完成工作的成就感 学习新东西时候的喜悦感  那种体验让我觉得 工作就应该是这样的 总可以给你一个新鲜感 让你孜孜不倦的探索 收获  整个一年 上半年都应该属于一个刚刚入门的状态 看到什么都特别好奇 看过react node webpack  等等等等 但是回过头来你发现你还是什么都不会 你只是为了看而在看 当用的时候你依然什么都不会  基本上上半年就属于这么一个贪多嚼不烂的状态  那会还信心满满的去了锤子面个了个试结果可想而知  下半年因为公司新来了一个技术不错的同事  我们的技术从原来的grunt+zepto这种形式转变成了vue+webpack+postcss 这样的套路  从那会就开始学习vue  至今已经半年多了 现在把vue用到工作中已经得心应手了 期间也为了练习vue 写了知乎日报这样的小项目去练手 但是我深知自己在基础方面的是很缺乏的 所以接下来的一段时间应该会重点看看基础上的东西 哦对了 我最近一直在看react+redux 的技术栈  为了可以练手 我还是准备写知乎日报的小项目 因为对他的接口逻辑都熟悉一些 在基友的帮助下 现在这个项目已经完成了百分之三十左右了 希望在年前我可以把 这个项目写完 然后可以熟悉了react方面的一些知识  工作也不是说一口可以吃成一个胖子的 继续努力吧\n\n生活方面也有一些变化吧 从原来的一起合租变成了自己住 再也没有同学在一起插科打诨了 时常会聚一下 但是大多数时候还是自己一个人在家 还好我是一个比较安静的人 可以适应那种独处的生活 也因为我有一把琴吧  闲着无聊的大多数时间还是跟他打交道的  排解一下无聊的生活  周末在家每周会打扫打扫家 给自己一个新的心情吧  吃饭成了最大的难题 到底周末吃什么呢？ 想原来一起做饭吃的日子还是很怀念的呀 自己还是坚持着弹琴录歌  这是第三年了 希望我还能坚持下去  在着新的一年里 我想把自己的生活 过的更有趣一点 我要尝试学习写歌 因为作为一个矫情的人 肯定会有很多抱怨的可以写成歌词吧  希望这个愿望可以在新的一年里成真  既然都说到这里了  我先放词为敬  昨天朋友说我活在自己的世界里 所以我这么写了些：\n\n\n>我想逃离我的世界 不想自信倔强独自表演\n>\n>我想逃离我的世界 不想凭空想象蜜语甜言\n>\n>我想活到你的世界 重要的角色由你扮演\n>\n>我想活到你的世界 分享秘密随风飘到天边\n>\n>我想逃离我的世界 心理支撑不下大大的冒险\n>\n>我想逃离我的世界 双手拥抱摸到自己的肩\n>\n>我想活到你的世界 共同坚强坦然面对一切\n>\n>我想活到你的世界 一起 一起走到海角天边\n>\n\n矫情死了 \n\n情感方面 总是缺少一些果决 缺少了一些更喜欢 上面都那么矫情的说了一些 所以只能希望可以发现那个人吧 \n\n\n回去就准备剪断那个三千烦恼丝吧  在新的一年里 能从头开始  为了能做一个有趣的 自在如风的人去努力吧  \n\n在这人世间 有些路是非要单独一个去面对 单独一个人去跋涉的 路再长再远 夜再黑再暗  也得独自默默地走下去 ———— 席慕蓉\n\n就这样吧 让我默默carry一会 \n\n再加一句吧   电影里说，“你我之间本无缘分，全靠我死撑，我明白的。”以前觉得这话直抵泪点，现在却觉得，说白了，爱一个人真的就是自己一个人的事儿，得拿出过日子一样的态度。只要还想继续，就大不了哭一场，硬着头皮爱下去。世间什么缘分不缘分，都是撑来的。——七堇年","source":"_posts/2017-01-01-写在2016年末.md","raw":"---\nlayout: post\ntitle: 写在2016年末\ndate: 2017-01-01\ntags: ['杂事二三']\ncategories: 杂事二三\n---\n\n回想起2016年是不是什么都记不起来了 对啊一年又匆忙的过去了 这一年和往年并没有任何不一样 还是一样谨慎 一样平凡 不管是在哪方面 都是那么普通 我一直都和别人说 我的一生就是谨慎的一生  人生一直都在既定的轨道上前行 没有任何出格的事情  学习 工作 生活  \n\n昨天和朋友讨论 到底什么算是出格的事情呢？  当时想了很久 也没有想到一个满意的答案  今天在想起来 到底什么才算是出格的事情呢  我想就是你为了不想在既定的轨道上前行 所做的努力 这算不算应该叫做出格的事情   我想了很久 觉得这个答案在我心里是认可的  \n\n前几天看过一个谈话类的节目  里面说  现在社会中仿佛每个人的选择有很多种 但其实在每个人的选择是很少的 确实啊  我总会想 我想当一个木匠  当一个画家  但是如果你放弃了现在的工作 你用什么来立命呢？ 所以藏在心里的梦想 敢去追逐  打破既定那就是出格了 \n\n我呢 只能是藏在这个面具下面 谨慎的前行了吧 现在在回北京的火车上写下了自己想到的一些  说矫情也确实挺矫情的  早晨出门的时候天还没亮 说是回家回家  但是真的在家陪伴家人的时间却又是多少?  大部分时间都是和朋友一起玩  说起来也挺惭愧的  拿这个当借口元旦放假回来了 \n\n往常我如果只放三天的假 我是不会回家的 因为在路上就花去了大部分时间  我回去是有私心的 我以为可以感动别人 其实只是感动了自己而已  仅此而已 现在看起来也只能是无奈的笑笑了  我原来说过一句话：人生无非两种情况 当初为什么那么傻逼 当初为什么不那么傻逼  对 我就是回来践行当初为什么不那么傻逼  \n\n起码一些东西明白了 心里就能不时常去牵挂了 朋友说我是活在自己世界里的一个人 固执倔强 有自己的想法 但是不自信 太敏感 有些事其实不用去想那么多 都没什么的  我想了一下还真是挺符合我的 我是太容易想多了 把一些捕风捉影的事情看得太重了  这也就给自己造了一个笼子  熟悉了 都不敢在天空了中飞翔了  \n\n总是很羡慕电影里的男主角  总是很有勇气的和女主角表白  没有那么多顾虑 很羡慕这种坦然  不知道自己什么时候也可以变成这样的坦然的人\n\n说了这么多 但标题是总结2016 那我还是应该努力回想起今年到底做了什么事 是可以让我小小总结一下的\n第一个应该是工作吧  在这一年里工作中 慢慢从一个新手变成了一个熟手 大部分工作都可以自己独立完成了 从一开始的一个菜鸟 慢慢成长了起来 说起现在的工作 说不上有多喜欢 但是并不反感  很享受那种独立完成工作的成就感 学习新东西时候的喜悦感  那种体验让我觉得 工作就应该是这样的 总可以给你一个新鲜感 让你孜孜不倦的探索 收获  整个一年 上半年都应该属于一个刚刚入门的状态 看到什么都特别好奇 看过react node webpack  等等等等 但是回过头来你发现你还是什么都不会 你只是为了看而在看 当用的时候你依然什么都不会  基本上上半年就属于这么一个贪多嚼不烂的状态  那会还信心满满的去了锤子面个了个试结果可想而知  下半年因为公司新来了一个技术不错的同事  我们的技术从原来的grunt+zepto这种形式转变成了vue+webpack+postcss 这样的套路  从那会就开始学习vue  至今已经半年多了 现在把vue用到工作中已经得心应手了 期间也为了练习vue 写了知乎日报这样的小项目去练手 但是我深知自己在基础方面的是很缺乏的 所以接下来的一段时间应该会重点看看基础上的东西 哦对了 我最近一直在看react+redux 的技术栈  为了可以练手 我还是准备写知乎日报的小项目 因为对他的接口逻辑都熟悉一些 在基友的帮助下 现在这个项目已经完成了百分之三十左右了 希望在年前我可以把 这个项目写完 然后可以熟悉了react方面的一些知识  工作也不是说一口可以吃成一个胖子的 继续努力吧\n\n生活方面也有一些变化吧 从原来的一起合租变成了自己住 再也没有同学在一起插科打诨了 时常会聚一下 但是大多数时候还是自己一个人在家 还好我是一个比较安静的人 可以适应那种独处的生活 也因为我有一把琴吧  闲着无聊的大多数时间还是跟他打交道的  排解一下无聊的生活  周末在家每周会打扫打扫家 给自己一个新的心情吧  吃饭成了最大的难题 到底周末吃什么呢？ 想原来一起做饭吃的日子还是很怀念的呀 自己还是坚持着弹琴录歌  这是第三年了 希望我还能坚持下去  在着新的一年里 我想把自己的生活 过的更有趣一点 我要尝试学习写歌 因为作为一个矫情的人 肯定会有很多抱怨的可以写成歌词吧  希望这个愿望可以在新的一年里成真  既然都说到这里了  我先放词为敬  昨天朋友说我活在自己的世界里 所以我这么写了些：\n\n\n>我想逃离我的世界 不想自信倔强独自表演\n>\n>我想逃离我的世界 不想凭空想象蜜语甜言\n>\n>我想活到你的世界 重要的角色由你扮演\n>\n>我想活到你的世界 分享秘密随风飘到天边\n>\n>我想逃离我的世界 心理支撑不下大大的冒险\n>\n>我想逃离我的世界 双手拥抱摸到自己的肩\n>\n>我想活到你的世界 共同坚强坦然面对一切\n>\n>我想活到你的世界 一起 一起走到海角天边\n>\n\n矫情死了 \n\n情感方面 总是缺少一些果决 缺少了一些更喜欢 上面都那么矫情的说了一些 所以只能希望可以发现那个人吧 \n\n\n回去就准备剪断那个三千烦恼丝吧  在新的一年里 能从头开始  为了能做一个有趣的 自在如风的人去努力吧  \n\n在这人世间 有些路是非要单独一个去面对 单独一个人去跋涉的 路再长再远 夜再黑再暗  也得独自默默地走下去 ———— 席慕蓉\n\n就这样吧 让我默默carry一会 \n\n再加一句吧   电影里说，“你我之间本无缘分，全靠我死撑，我明白的。”以前觉得这话直抵泪点，现在却觉得，说白了，爱一个人真的就是自己一个人的事儿，得拿出过日子一样的态度。只要还想继续，就大不了哭一场，硬着头皮爱下去。世间什么缘分不缘分，都是撑来的。——七堇年","slug":"写在2016年末","published":1,"updated":"2017-01-03T03:47:08.000Z","comments":1,"photos":[],"link":"","_id":"cixgzg2090035sq5lvyp67wzd","content":"<p>回想起2016年是不是什么都记不起来了 对啊一年又匆忙的过去了 这一年和往年并没有任何不一样 还是一样谨慎 一样平凡 不管是在哪方面 都是那么普通 我一直都和别人说 我的一生就是谨慎的一生  人生一直都在既定的轨道上前行 没有任何出格的事情  学习 工作 生活  </p>\n<p>昨天和朋友讨论 到底什么算是出格的事情呢？  当时想了很久 也没有想到一个满意的答案  今天在想起来 到底什么才算是出格的事情呢  我想就是你为了不想在既定的轨道上前行 所做的努力 这算不算应该叫做出格的事情   我想了很久 觉得这个答案在我心里是认可的  </p>\n<p>前几天看过一个谈话类的节目  里面说  现在社会中仿佛每个人的选择有很多种 但其实在每个人的选择是很少的 确实啊  我总会想 我想当一个木匠  当一个画家  但是如果你放弃了现在的工作 你用什么来立命呢？ 所以藏在心里的梦想 敢去追逐  打破既定那就是出格了 </p>\n<p>我呢 只能是藏在这个面具下面 谨慎的前行了吧 现在在回北京的火车上写下了自己想到的一些  说矫情也确实挺矫情的  早晨出门的时候天还没亮 说是回家回家  但是真的在家陪伴家人的时间却又是多少?  大部分时间都是和朋友一起玩  说起来也挺惭愧的  拿这个当借口元旦放假回来了 </p>\n<p>往常我如果只放三天的假 我是不会回家的 因为在路上就花去了大部分时间  我回去是有私心的 我以为可以感动别人 其实只是感动了自己而已  仅此而已 现在看起来也只能是无奈的笑笑了  我原来说过一句话：人生无非两种情况 当初为什么那么傻逼 当初为什么不那么傻逼  对 我就是回来践行当初为什么不那么傻逼  </p>\n<p>起码一些东西明白了 心里就能不时常去牵挂了 朋友说我是活在自己世界里的一个人 固执倔强 有自己的想法 但是不自信 太敏感 有些事其实不用去想那么多 都没什么的  我想了一下还真是挺符合我的 我是太容易想多了 把一些捕风捉影的事情看得太重了  这也就给自己造了一个笼子  熟悉了 都不敢在天空了中飞翔了  </p>\n<p>总是很羡慕电影里的男主角  总是很有勇气的和女主角表白  没有那么多顾虑 很羡慕这种坦然  不知道自己什么时候也可以变成这样的坦然的人</p>\n<p>说了这么多 但标题是总结2016 那我还是应该努力回想起今年到底做了什么事 是可以让我小小总结一下的<br>第一个应该是工作吧  在这一年里工作中 慢慢从一个新手变成了一个熟手 大部分工作都可以自己独立完成了 从一开始的一个菜鸟 慢慢成长了起来 说起现在的工作 说不上有多喜欢 但是并不反感  很享受那种独立完成工作的成就感 学习新东西时候的喜悦感  那种体验让我觉得 工作就应该是这样的 总可以给你一个新鲜感 让你孜孜不倦的探索 收获  整个一年 上半年都应该属于一个刚刚入门的状态 看到什么都特别好奇 看过react node webpack  等等等等 但是回过头来你发现你还是什么都不会 你只是为了看而在看 当用的时候你依然什么都不会  基本上上半年就属于这么一个贪多嚼不烂的状态  那会还信心满满的去了锤子面个了个试结果可想而知  下半年因为公司新来了一个技术不错的同事  我们的技术从原来的grunt+zepto这种形式转变成了vue+webpack+postcss 这样的套路  从那会就开始学习vue  至今已经半年多了 现在把vue用到工作中已经得心应手了 期间也为了练习vue 写了知乎日报这样的小项目去练手 但是我深知自己在基础方面的是很缺乏的 所以接下来的一段时间应该会重点看看基础上的东西 哦对了 我最近一直在看react+redux 的技术栈  为了可以练手 我还是准备写知乎日报的小项目 因为对他的接口逻辑都熟悉一些 在基友的帮助下 现在这个项目已经完成了百分之三十左右了 希望在年前我可以把 这个项目写完 然后可以熟悉了react方面的一些知识  工作也不是说一口可以吃成一个胖子的 继续努力吧</p>\n<p>生活方面也有一些变化吧 从原来的一起合租变成了自己住 再也没有同学在一起插科打诨了 时常会聚一下 但是大多数时候还是自己一个人在家 还好我是一个比较安静的人 可以适应那种独处的生活 也因为我有一把琴吧  闲着无聊的大多数时间还是跟他打交道的  排解一下无聊的生活  周末在家每周会打扫打扫家 给自己一个新的心情吧  吃饭成了最大的难题 到底周末吃什么呢？ 想原来一起做饭吃的日子还是很怀念的呀 自己还是坚持着弹琴录歌  这是第三年了 希望我还能坚持下去  在着新的一年里 我想把自己的生活 过的更有趣一点 我要尝试学习写歌 因为作为一个矫情的人 肯定会有很多抱怨的可以写成歌词吧  希望这个愿望可以在新的一年里成真  既然都说到这里了  我先放词为敬  昨天朋友说我活在自己的世界里 所以我这么写了些：</p>\n<blockquote>\n<p>我想逃离我的世界 不想自信倔强独自表演</p>\n<p>我想逃离我的世界 不想凭空想象蜜语甜言</p>\n<p>我想活到你的世界 重要的角色由你扮演</p>\n<p>我想活到你的世界 分享秘密随风飘到天边</p>\n<p>我想逃离我的世界 心理支撑不下大大的冒险</p>\n<p>我想逃离我的世界 双手拥抱摸到自己的肩</p>\n<p>我想活到你的世界 共同坚强坦然面对一切</p>\n<p>我想活到你的世界 一起 一起走到海角天边</p>\n</blockquote>\n<p>矫情死了 </p>\n<p>情感方面 总是缺少一些果决 缺少了一些更喜欢 上面都那么矫情的说了一些 所以只能希望可以发现那个人吧 </p>\n<p>回去就准备剪断那个三千烦恼丝吧  在新的一年里 能从头开始  为了能做一个有趣的 自在如风的人去努力吧  </p>\n<p>在这人世间 有些路是非要单独一个去面对 单独一个人去跋涉的 路再长再远 夜再黑再暗  也得独自默默地走下去 ———— 席慕蓉</p>\n<p>就这样吧 让我默默carry一会 </p>\n<p>再加一句吧   电影里说，“你我之间本无缘分，全靠我死撑，我明白的。”以前觉得这话直抵泪点，现在却觉得，说白了，爱一个人真的就是自己一个人的事儿，得拿出过日子一样的态度。只要还想继续，就大不了哭一场，硬着头皮爱下去。世间什么缘分不缘分，都是撑来的。——七堇年</p>\n","excerpt":"","more":"<p>回想起2016年是不是什么都记不起来了 对啊一年又匆忙的过去了 这一年和往年并没有任何不一样 还是一样谨慎 一样平凡 不管是在哪方面 都是那么普通 我一直都和别人说 我的一生就是谨慎的一生  人生一直都在既定的轨道上前行 没有任何出格的事情  学习 工作 生活  </p>\n<p>昨天和朋友讨论 到底什么算是出格的事情呢？  当时想了很久 也没有想到一个满意的答案  今天在想起来 到底什么才算是出格的事情呢  我想就是你为了不想在既定的轨道上前行 所做的努力 这算不算应该叫做出格的事情   我想了很久 觉得这个答案在我心里是认可的  </p>\n<p>前几天看过一个谈话类的节目  里面说  现在社会中仿佛每个人的选择有很多种 但其实在每个人的选择是很少的 确实啊  我总会想 我想当一个木匠  当一个画家  但是如果你放弃了现在的工作 你用什么来立命呢？ 所以藏在心里的梦想 敢去追逐  打破既定那就是出格了 </p>\n<p>我呢 只能是藏在这个面具下面 谨慎的前行了吧 现在在回北京的火车上写下了自己想到的一些  说矫情也确实挺矫情的  早晨出门的时候天还没亮 说是回家回家  但是真的在家陪伴家人的时间却又是多少?  大部分时间都是和朋友一起玩  说起来也挺惭愧的  拿这个当借口元旦放假回来了 </p>\n<p>往常我如果只放三天的假 我是不会回家的 因为在路上就花去了大部分时间  我回去是有私心的 我以为可以感动别人 其实只是感动了自己而已  仅此而已 现在看起来也只能是无奈的笑笑了  我原来说过一句话：人生无非两种情况 当初为什么那么傻逼 当初为什么不那么傻逼  对 我就是回来践行当初为什么不那么傻逼  </p>\n<p>起码一些东西明白了 心里就能不时常去牵挂了 朋友说我是活在自己世界里的一个人 固执倔强 有自己的想法 但是不自信 太敏感 有些事其实不用去想那么多 都没什么的  我想了一下还真是挺符合我的 我是太容易想多了 把一些捕风捉影的事情看得太重了  这也就给自己造了一个笼子  熟悉了 都不敢在天空了中飞翔了  </p>\n<p>总是很羡慕电影里的男主角  总是很有勇气的和女主角表白  没有那么多顾虑 很羡慕这种坦然  不知道自己什么时候也可以变成这样的坦然的人</p>\n<p>说了这么多 但标题是总结2016 那我还是应该努力回想起今年到底做了什么事 是可以让我小小总结一下的<br>第一个应该是工作吧  在这一年里工作中 慢慢从一个新手变成了一个熟手 大部分工作都可以自己独立完成了 从一开始的一个菜鸟 慢慢成长了起来 说起现在的工作 说不上有多喜欢 但是并不反感  很享受那种独立完成工作的成就感 学习新东西时候的喜悦感  那种体验让我觉得 工作就应该是这样的 总可以给你一个新鲜感 让你孜孜不倦的探索 收获  整个一年 上半年都应该属于一个刚刚入门的状态 看到什么都特别好奇 看过react node webpack  等等等等 但是回过头来你发现你还是什么都不会 你只是为了看而在看 当用的时候你依然什么都不会  基本上上半年就属于这么一个贪多嚼不烂的状态  那会还信心满满的去了锤子面个了个试结果可想而知  下半年因为公司新来了一个技术不错的同事  我们的技术从原来的grunt+zepto这种形式转变成了vue+webpack+postcss 这样的套路  从那会就开始学习vue  至今已经半年多了 现在把vue用到工作中已经得心应手了 期间也为了练习vue 写了知乎日报这样的小项目去练手 但是我深知自己在基础方面的是很缺乏的 所以接下来的一段时间应该会重点看看基础上的东西 哦对了 我最近一直在看react+redux 的技术栈  为了可以练手 我还是准备写知乎日报的小项目 因为对他的接口逻辑都熟悉一些 在基友的帮助下 现在这个项目已经完成了百分之三十左右了 希望在年前我可以把 这个项目写完 然后可以熟悉了react方面的一些知识  工作也不是说一口可以吃成一个胖子的 继续努力吧</p>\n<p>生活方面也有一些变化吧 从原来的一起合租变成了自己住 再也没有同学在一起插科打诨了 时常会聚一下 但是大多数时候还是自己一个人在家 还好我是一个比较安静的人 可以适应那种独处的生活 也因为我有一把琴吧  闲着无聊的大多数时间还是跟他打交道的  排解一下无聊的生活  周末在家每周会打扫打扫家 给自己一个新的心情吧  吃饭成了最大的难题 到底周末吃什么呢？ 想原来一起做饭吃的日子还是很怀念的呀 自己还是坚持着弹琴录歌  这是第三年了 希望我还能坚持下去  在着新的一年里 我想把自己的生活 过的更有趣一点 我要尝试学习写歌 因为作为一个矫情的人 肯定会有很多抱怨的可以写成歌词吧  希望这个愿望可以在新的一年里成真  既然都说到这里了  我先放词为敬  昨天朋友说我活在自己的世界里 所以我这么写了些：</p>\n<blockquote>\n<p>我想逃离我的世界 不想自信倔强独自表演</p>\n<p>我想逃离我的世界 不想凭空想象蜜语甜言</p>\n<p>我想活到你的世界 重要的角色由你扮演</p>\n<p>我想活到你的世界 分享秘密随风飘到天边</p>\n<p>我想逃离我的世界 心理支撑不下大大的冒险</p>\n<p>我想逃离我的世界 双手拥抱摸到自己的肩</p>\n<p>我想活到你的世界 共同坚强坦然面对一切</p>\n<p>我想活到你的世界 一起 一起走到海角天边</p>\n</blockquote>\n<p>矫情死了 </p>\n<p>情感方面 总是缺少一些果决 缺少了一些更喜欢 上面都那么矫情的说了一些 所以只能希望可以发现那个人吧 </p>\n<p>回去就准备剪断那个三千烦恼丝吧  在新的一年里 能从头开始  为了能做一个有趣的 自在如风的人去努力吧  </p>\n<p>在这人世间 有些路是非要单独一个去面对 单独一个人去跋涉的 路再长再远 夜再黑再暗  也得独自默默地走下去 ———— 席慕蓉</p>\n<p>就这样吧 让我默默carry一会 </p>\n<p>再加一句吧   电影里说，“你我之间本无缘分，全靠我死撑，我明白的。”以前觉得这话直抵泪点，现在却觉得，说白了，爱一个人真的就是自己一个人的事儿，得拿出过日子一样的态度。只要还想继续，就大不了哭一场，硬着头皮爱下去。世间什么缘分不缘分，都是撑来的。——七堇年</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cixgzg1xq0003sq5lfclda3kh","category_id":"cixgzg1xy0007sq5l9supfcr9","_id":"cixgzg1y8000gsq5laatajyzg"},{"post_id":"cixgzg1y7000fsq5lffe8tiha","category_id":"cixgzg1xy0007sq5l9supfcr9","_id":"cixgzg1yc000msq5lhwna8ftx"},{"post_id":"cixgzg1xs0005sq5l09fs9cbv","category_id":"cixgzg1xy0007sq5l9supfcr9","_id":"cixgzg1ye000rsq5l3wniivrv"},{"post_id":"cixgzg1y10009sq5ldajc4t6r","category_id":"cixgzg1xy0007sq5l9supfcr9","_id":"cixgzg1yh000tsq5lw4z88qz6"},{"post_id":"cixgzg1y3000asq5l9j1h01sk","category_id":"cixgzg1ye000psq5ll8db7f8b","_id":"cixgzg1yo0011sq5lw0mh8mii"},{"post_id":"cixgzg1yi000usq5lcckrgpl2","category_id":"cixgzg1xy0007sq5l9supfcr9","_id":"cixgzg1yp0016sq5lzs6xofgm"},{"post_id":"cixgzg1yl000ysq5lefuxdsu8","category_id":"cixgzg1xy0007sq5l9supfcr9","_id":"cixgzg1ys0019sq5l2qvxrapj"},{"post_id":"cixgzg1y4000csq5lsa29tqov","category_id":"cixgzg1yl000wsq5ldgoxdlub","_id":"cixgzg1yu001dsq5lwubk5dih"},{"post_id":"cixgzg1y8000isq5l10y2cg5n","category_id":"cixgzg1yl000wsq5ldgoxdlub","_id":"cixgzg1yx001gsq5luk1npxn7"},{"post_id":"cixgzg1yt001csq5l0x4cpk5v","category_id":"cixgzg1xy0007sq5l9supfcr9","_id":"cixgzg1z1001lsq5lrrh1t8um"},{"post_id":"cixgzg1yb000lsq5ljzvemayo","category_id":"cixgzg1ys001asq5l6xra40hr","_id":"cixgzg1z5001nsq5l8jb1njsk"},{"post_id":"cixgzg1yd000osq5l9ayyeg9x","category_id":"cixgzg1yx001isq5l83us8sm2","_id":"cixgzg1za001ssq5l1jph6ai5"},{"post_id":"cixgzg1yg000ssq5lbzkgaexm","category_id":"cixgzg1yl000wsq5ldgoxdlub","_id":"cixgzg1ze001ysq5lainq20en"},{"post_id":"cixgzg1yn0010sq5lkeu6fv4y","category_id":"cixgzg1zc001usq5lpkpyexet","_id":"cixgzg1zm0026sq5lq70h1nrl"},{"post_id":"cixgzg1ze0020sq5lngchajun","category_id":"cixgzg1zc001usq5lpkpyexet","_id":"cixgzg1zp002asq5leik6h0x4"},{"post_id":"cixgzg1yo0015sq5l4epynmyy","category_id":"cixgzg1zf0021sq5lg48ju4rd","_id":"cixgzg1zs002dsq5lrqx2p1y7"},{"post_id":"cixgzg1yq0018sq5lre8syy0i","category_id":"cixgzg1zc001usq5lpkpyexet","_id":"cixgzg1zv002isq5lvguwr85c"},{"post_id":"cixgzg1zt002gsq5ln0yi0kdh","category_id":"cixgzg1zc001usq5lpkpyexet","_id":"cixgzg200002msq5luuhjq45g"},{"post_id":"cixgzg1yv001fsq5l5yfru4xr","category_id":"cixgzg1zs002esq5ling5yz0v","_id":"cixgzg201002osq5ljqez0drz"},{"post_id":"cixgzg1zy002lsq5l7l56yw8o","category_id":"cixgzg1yl000wsq5ldgoxdlub","_id":"cixgzg204002ssq5lqkushn1r"},{"post_id":"cixgzg1yy001jsq5letvmc6g4","category_id":"cixgzg1zs002esq5ling5yz0v","_id":"cixgzg206002vsq5lrhnidv20"},{"post_id":"cixgzg200002nsq5l8ei4forg","category_id":"cixgzg1zc001usq5lpkpyexet","_id":"cixgzg2080030sq5lglpi5hv2"},{"post_id":"cixgzg202002qsq5lzw5dnojv","category_id":"cixgzg1zc001usq5lpkpyexet","_id":"cixgzg2090033sq5lnnumrm9f"},{"post_id":"cixgzg1z1001msq5l7sti4h5y","category_id":"cixgzg202002psq5l4klm8zgp","_id":"cixgzg20d0038sq5l08fgn07n"},{"post_id":"cixgzg206002xsq5l9nayzzgd","category_id":"cixgzg1zc001usq5lpkpyexet","_id":"cixgzg20d003asq5ldqiy8z05"},{"post_id":"cixgzg2080032sq5lrk99kh39","category_id":"cixgzg1xy0007sq5l9supfcr9","_id":"cixgzg20f003dsq5lv83enw3s"},{"post_id":"cixgzg1z7001psq5lbcx40w6f","category_id":"cixgzg202002psq5l4klm8zgp","_id":"cixgzg20g003gsq5lsdgnyl0e"},{"post_id":"cixgzg2090035sq5lvyp67wzd","category_id":"cixgzg1xy0007sq5l9supfcr9","_id":"cixgzg20g003jsq5lu85nww5v"},{"post_id":"cixgzg1z9001rsq5l2h0cr1x4","category_id":"cixgzg1zc001usq5lpkpyexet","_id":"cixgzg20g003lsq5lw9cjz150"},{"post_id":"cixgzg1zb001tsq5lxy3hjpwb","category_id":"cixgzg1zc001usq5lpkpyexet","_id":"cixgzg20h003nsq5ljgkbork3"},{"post_id":"cixgzg1zd001xsq5l93c5pgj0","category_id":"cixgzg202002psq5l4klm8zgp","_id":"cixgzg20i003psq5lhuon05oj"},{"post_id":"cixgzg1zg0023sq5l1lipac0n","category_id":"cixgzg202002psq5l4klm8zgp","_id":"cixgzg20j003usq5lqbqm78l4"},{"post_id":"cixgzg1zj0025sq5l8r18eofv","category_id":"cixgzg202002psq5l4klm8zgp","_id":"cixgzg20k003xsq5lg5das1ba"},{"post_id":"cixgzg1zo0029sq5l9frg5p9m","category_id":"cixgzg20j003vsq5lgrp1qdx9","_id":"cixgzg20l0042sq5lhukr6036"},{"post_id":"cixgzg1zp002csq5ljpbgrsra","category_id":"cixgzg20k003ysq5l9zk1egf3","_id":"cixgzg20o0045sq5lt0u6vmvg"},{"post_id":"cixgzg1zu002hsq5ljknkq66v","category_id":"cixgzg20j003vsq5lgrp1qdx9","_id":"cixgzg20p0049sq5lde7fkxfc"},{"post_id":"cixgzg204002usq5lbfity65p","category_id":"cixgzg20o0046sq5lgx5hgx56","_id":"cixgzg20p004bsq5lq9hilyg4"}],"PostTag":[{"post_id":"cixgzg1xq0003sq5lfclda3kh","tag_id":"cixgzg1xt0006sq5l7ekisxxu","_id":"cixgzg1y6000esq5lqhk48xy5"},{"post_id":"cixgzg1xs0005sq5l09fs9cbv","tag_id":"cixgzg1xt0006sq5l7ekisxxu","_id":"cixgzg1ya000ksq5lpvst2aza"},{"post_id":"cixgzg1y10009sq5ldajc4t6r","tag_id":"cixgzg1xt0006sq5l7ekisxxu","_id":"cixgzg1ye000qsq5lon4mzx8k"},{"post_id":"cixgzg1y3000asq5l9j1h01sk","tag_id":"cixgzg1yc000nsq5lbel05odt","_id":"cixgzg1yl000xsq5lb4m875pp"},{"post_id":"cixgzg1yi000usq5lcckrgpl2","tag_id":"cixgzg1xt0006sq5l7ekisxxu","_id":"cixgzg1yn000zsq5l640qwyal"},{"post_id":"cixgzg1yl000ysq5lefuxdsu8","tag_id":"cixgzg1xt0006sq5l7ekisxxu","_id":"cixgzg1yo0014sq5lltag23jl"},{"post_id":"cixgzg1y4000csq5lsa29tqov","tag_id":"cixgzg1yk000vsq5l0sg9328p","_id":"cixgzg1yq0017sq5l6gm01jei"},{"post_id":"cixgzg1y7000fsq5lffe8tiha","tag_id":"cixgzg1yo0012sq5lqbnge66h","_id":"cixgzg1yv001esq5lhrmpbm0c"},{"post_id":"cixgzg1y8000isq5l10y2cg5n","tag_id":"cixgzg1yk000vsq5l0sg9328p","_id":"cixgzg1z1001ksq5lecou8qyg"},{"post_id":"cixgzg1yb000lsq5ljzvemayo","tag_id":"cixgzg1yx001hsq5lwbno7tfg","_id":"cixgzg1zd001wsq5lfqhepr69"},{"post_id":"cixgzg1yb000lsq5ljzvemayo","tag_id":"cixgzg1z6001osq5l14b7c5un","_id":"cixgzg1ze001zsq5lnv4yv4a7"},{"post_id":"cixgzg1yd000osq5l9ayyeg9x","tag_id":"cixgzg1zd001vsq5l69r357c4","_id":"cixgzg1zi0024sq5l4l6h5dib"},{"post_id":"cixgzg1yg000ssq5lbzkgaexm","tag_id":"cixgzg1yk000vsq5l0sg9328p","_id":"cixgzg1zp002bsq5lw9wfdbtk"},{"post_id":"cixgzg1yn0010sq5lkeu6fv4y","tag_id":"cixgzg1zn0027sq5ln4e0l26u","_id":"cixgzg204002tsq5lx5dmxl4j"},{"post_id":"cixgzg1yn0010sq5lkeu6fv4y","tag_id":"cixgzg1zt002fsq5lpatv9n5d","_id":"cixgzg206002wsq5lxbhr75gu"},{"post_id":"cixgzg1yn0010sq5lkeu6fv4y","tag_id":"cixgzg1zy002ksq5l66xrchm3","_id":"cixgzg2080031sq5l9ib1k6mi"},{"post_id":"cixgzg1yo0015sq5l4epynmyy","tag_id":"cixgzg204002rsq5lm1g6vfue","_id":"cixgzg2090034sq5lvewef9ny"},{"post_id":"cixgzg2080032sq5lrk99kh39","tag_id":"cixgzg1xt0006sq5l7ekisxxu","_id":"cixgzg20d0039sq5lqzpuxww0"},{"post_id":"cixgzg2090035sq5lvyp67wzd","tag_id":"cixgzg1xt0006sq5l7ekisxxu","_id":"cixgzg20e003bsq5l0qmiv46j"},{"post_id":"cixgzg1yq0018sq5lre8syy0i","tag_id":"cixgzg208002zsq5lwn51etp8","_id":"cixgzg20f003fsq5l4tg7lkfx"},{"post_id":"cixgzg1yq0018sq5lre8syy0i","tag_id":"cixgzg20d0037sq5lveio3avt","_id":"cixgzg20g003isq5lan3kr6rn"},{"post_id":"cixgzg1z1001msq5l7sti4h5y","tag_id":"cixgzg20f003esq5l16bg95dh","_id":"cixgzg20i003rsq5lijif2dnf"},{"post_id":"cixgzg1z1001msq5l7sti4h5y","tag_id":"cixgzg20g003ksq5l7bd4e25c","_id":"cixgzg20i003ssq5lbyz866an"},{"post_id":"cixgzg1z7001psq5lbcx40w6f","tag_id":"cixgzg20f003esq5l16bg95dh","_id":"cixgzg20k003zsq5l8z0gwye1"},{"post_id":"cixgzg1z7001psq5lbcx40w6f","tag_id":"cixgzg20j003tsq5lycp9grc8","_id":"cixgzg20l0040sq5lwzwceehu"},{"post_id":"cixgzg1z9001rsq5l2h0cr1x4","tag_id":"cixgzg20k003wsq5l9xlclv4l","_id":"cixgzg20p0047sq5lux8rvdds"},{"post_id":"cixgzg1z9001rsq5l2h0cr1x4","tag_id":"cixgzg20l0041sq5lrzfx57k2","_id":"cixgzg20p0048sq5l539i9g6p"},{"post_id":"cixgzg1zb001tsq5lxy3hjpwb","tag_id":"cixgzg20o0044sq5l4hifpvpq","_id":"cixgzg20q004fsq5lfphz3hiq"},{"post_id":"cixgzg1zb001tsq5lxy3hjpwb","tag_id":"cixgzg20p004asq5lfqck34bu","_id":"cixgzg20r004gsq5laeui29q8"},{"post_id":"cixgzg1zb001tsq5lxy3hjpwb","tag_id":"cixgzg20p004csq5l8gqw4idf","_id":"cixgzg20r004isq5lfxnhimfv"},{"post_id":"cixgzg1zb001tsq5lxy3hjpwb","tag_id":"cixgzg20q004dsq5lsh0yvda5","_id":"cixgzg20r004jsq5l2mom90cq"},{"post_id":"cixgzg1zd001xsq5l93c5pgj0","tag_id":"cixgzg20f003esq5l16bg95dh","_id":"cixgzg20s004lsq5l5zc04mx9"},{"post_id":"cixgzg1zd001xsq5l93c5pgj0","tag_id":"cixgzg20r004hsq5lc3vmjaaz","_id":"cixgzg20s004msq5lx8teeadu"},{"post_id":"cixgzg1ze0020sq5lngchajun","tag_id":"cixgzg20r004ksq5l5dd7btsf","_id":"cixgzg20u004psq5ll6ioly8a"},{"post_id":"cixgzg1ze0020sq5lngchajun","tag_id":"cixgzg20s004nsq5losctck25","_id":"cixgzg20u004qsq5l5rdj5jzz"},{"post_id":"cixgzg1zg0023sq5l1lipac0n","tag_id":"cixgzg20f003esq5l16bg95dh","_id":"cixgzg20v004ssq5luh4lxq5v"},{"post_id":"cixgzg1zj0025sq5l8r18eofv","tag_id":"cixgzg20f003esq5l16bg95dh","_id":"cixgzg20v004usq5lftwjnh53"},{"post_id":"cixgzg1zo0029sq5l9frg5p9m","tag_id":"cixgzg20v004tsq5lmp4bovdv","_id":"cixgzg20w004wsq5lnqxcxxbl"},{"post_id":"cixgzg1zp002csq5ljpbgrsra","tag_id":"cixgzg20v004vsq5lotinpeo1","_id":"cixgzg20x004ysq5lqfpro548"},{"post_id":"cixgzg1zt002gsq5ln0yi0kdh","tag_id":"cixgzg20v004tsq5lmp4bovdv","_id":"cixgzg20x0051sq5luui01u2n"},{"post_id":"cixgzg1zt002gsq5ln0yi0kdh","tag_id":"cixgzg20x004zsq5lz1snxfzv","_id":"cixgzg20y0052sq5l68uogte8"},{"post_id":"cixgzg1zu002hsq5ljknkq66v","tag_id":"cixgzg20v004tsq5lmp4bovdv","_id":"cixgzg20y0055sq5lj8pio6m3"},{"post_id":"cixgzg1zu002hsq5ljknkq66v","tag_id":"cixgzg20y0053sq5lkdt1j5vb","_id":"cixgzg20y0056sq5lp6zqjens"},{"post_id":"cixgzg200002nsq5l8ei4forg","tag_id":"cixgzg20y0054sq5lhaf17fxp","_id":"cixgzg20y0058sq5ls7upcemk"},{"post_id":"cixgzg202002qsq5lzw5dnojv","tag_id":"cixgzg20y0054sq5lhaf17fxp","_id":"cixgzg20z005asq5lthcdya59"},{"post_id":"cixgzg204002usq5lbfity65p","tag_id":"cixgzg20z0059sq5ly6g6pozb","_id":"cixgzg20z005csq5l9wlv3i68"},{"post_id":"cixgzg206002xsq5l9nayzzgd","tag_id":"cixgzg20y0054sq5lhaf17fxp","_id":"cixgzg211005dsq5l6gkim6xl"}],"Tag":[{"name":"杂事二三","_id":"cixgzg1xt0006sq5l7ekisxxu"},{"name":"markdown","_id":"cixgzg1yc000nsq5lbel05odt"},{"name":"ES6","_id":"cixgzg1yk000vsq5l0sg9328p"},{"name":"好的博客","_id":"cixgzg1yo0012sq5lqbnge66h"},{"name":"Charles","_id":"cixgzg1yx001hsq5lwbno7tfg"},{"name":"跨域问题","_id":"cixgzg1z6001osq5l14b7c5un"},{"name":"webpack","_id":"cixgzg1zd001vsq5l69r357c4"},{"name":"handlebars","_id":"cixgzg1zn0027sq5ln4e0l26u"},{"name":"小数点精确","_id":"cixgzg1zt002fsq5lpatv9n5d"},{"name":"url携带参数","_id":"cixgzg1zy002ksq5l66xrchm3"},{"name":"React","_id":"cixgzg204002rsq5lm1g6vfue"},{"name":"JSSDK","_id":"cixgzg208002zsq5lwn51etp8"},{"name":"iOS微信二维码","_id":"cixgzg20d0037sq5lveio3avt"},{"name":"JavaScript","_id":"cixgzg20f003esq5l16bg95dh"},{"name":"作用域","_id":"cixgzg20g003ksq5l7bd4e25c"},{"name":"闭包","_id":"cixgzg20j003tsq5lycp9grc8"},{"name":"ngrok","_id":"cixgzg20k003wsq5l9xlclv4l"},{"name":"内网穿透","_id":"cixgzg20l0041sq5lrzfx57k2"},{"name":"微信JSSDK","_id":"cixgzg20o0044sq5l4hifpvpq"},{"name":"跨域","_id":"cixgzg20p004asq5lfqck34bu"},{"name":"appid","_id":"cixgzg20p004csq5l8gqw4idf"},{"name":"referer","_id":"cixgzg20q004dsq5lsh0yvda5"},{"name":"this","_id":"cixgzg20r004hsq5lc3vmjaaz"},{"name":"WebStorage","_id":"cixgzg20r004ksq5l5dd7btsf"},{"name":"页面储存","_id":"cixgzg20s004nsq5losctck25"},{"name":"vue","_id":"cixgzg20v004tsq5lmp4bovdv"},{"name":"webstorm","_id":"cixgzg20v004vsq5lotinpeo1"},{"name":"文件上传","_id":"cixgzg20x004zsq5lz1snxfzv"},{"name":"知乎日报","_id":"cixgzg20y0053sq5lkdt1j5vb"},{"name":"工作总结","_id":"cixgzg20y0054sq5lhaf17fxp"},{"name":"微信小程序","_id":"cixgzg20z0059sq5ly6g6pozb"}]}}